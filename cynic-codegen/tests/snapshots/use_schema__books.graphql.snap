---
source: cynic-codegen/tests/use-schema.rs
expression: "format_code(format!(\"{}\", tokens))"
---
impl cynic::schema::QueryRoot for QueryRoot {}
impl cynic::schema::MutationRoot for MutationRoot {}
impl cynic::schema::SubscriptionRoot for SubscriptionRoot {}
pub struct Book;
pub struct BookChanged;
pub struct MutationRoot;
pub struct MutationType {}
pub struct QueryRoot;
pub struct SubscriptionRoot;
impl cynic::schema::NamedType for Book {
    const NAME: &'static str = "Book";
}
impl cynic::schema::NamedType for BookChanged {
    const NAME: &'static str = "BookChanged";
}
impl cynic::schema::NamedType for MutationRoot {
    const NAME: &'static str = "MutationRoot";
}
impl cynic::schema::NamedType for QueryRoot {
    const NAME: &'static str = "QueryRoot";
}
impl cynic::schema::NamedType for SubscriptionRoot {
    const NAME: &'static str = "SubscriptionRoot";
}
#[allow(non_snake_case, non_camel_case_types)]
pub mod __fields {
    pub mod Book {
        pub struct id;
        impl cynic::schema::HasField<id> for super::super::Book {
            type Type = super::super::String;
            const NAME: &'static str = "id";
        }
        pub struct name;
        impl cynic::schema::HasField<name> for super::super::Book {
            type Type = super::super::String;
            const NAME: &'static str = "name";
        }
        pub struct author;
        impl cynic::schema::HasField<author> for super::super::Book {
            type Type = super::super::String;
            const NAME: &'static str = "author";
        }
        pub struct __typename;
        impl cynic::schema::HasField<__typename> for super::super::Book {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
    }
    pub mod BookChanged {
        pub struct mutationType;
        impl cynic::schema::HasField<mutationType> for super::super::BookChanged {
            type Type = super::super::MutationType;
            const NAME: &'static str = "mutationType";
        }
        pub struct id;
        impl cynic::schema::HasField<id> for super::super::BookChanged {
            type Type = super::super::ID;
            const NAME: &'static str = "id";
        }
        pub struct book;
        impl cynic::schema::HasField<book> for super::super::BookChanged {
            type Type = Option<super::super::Book>;
            const NAME: &'static str = "book";
        }
        pub struct __typename;
        impl cynic::schema::HasField<__typename> for super::super::BookChanged {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
    }
    pub mod MutationRoot {
        pub struct createBook;
        impl cynic::schema::HasField<createBook> for super::super::MutationRoot {
            type Type = super::super::ID;
            const NAME: &'static str = "createBook";
        }
        pub mod _create_book_arguments {
            pub struct name;
            impl cynic::schema::HasArgument<name> for super::createBook {
                type ArgumentType = super::super::super::String;
                const NAME: &'static str = "name";
            }
            pub struct author;
            impl cynic::schema::HasArgument<author> for super::createBook {
                type ArgumentType = super::super::super::String;
                const NAME: &'static str = "author";
            }
        }
        pub struct deleteBook;
        impl cynic::schema::HasField<deleteBook> for super::super::MutationRoot {
            type Type = super::super::Boolean;
            const NAME: &'static str = "deleteBook";
        }
        pub mod _delete_book_arguments {
            pub struct id;
            impl cynic::schema::HasArgument<id> for super::deleteBook {
                type ArgumentType = super::super::super::ID;
                const NAME: &'static str = "id";
            }
        }
        pub struct __typename;
        impl cynic::schema::HasField<__typename> for super::super::MutationRoot {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
    }
    pub mod QueryRoot {
        pub struct books;
        impl cynic::schema::HasField<books> for super::super::QueryRoot {
            type Type = Vec<super::super::Book>;
            const NAME: &'static str = "books";
        }
        pub struct __typename;
        impl cynic::schema::HasField<__typename> for super::super::QueryRoot {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
    }
    pub mod SubscriptionRoot {
        pub struct interval;
        impl cynic::schema::HasField<interval> for super::super::SubscriptionRoot {
            type Type = super::super::Int;
            const NAME: &'static str = "interval";
        }
        pub mod _interval_arguments {
            pub struct n;
            impl cynic::schema::HasArgument<n> for super::interval {
                type ArgumentType = super::super::super::Int;
                const NAME: &'static str = "n";
            }
        }
        pub struct books;
        impl cynic::schema::HasField<books> for super::super::SubscriptionRoot {
            type Type = super::super::BookChanged;
            const NAME: &'static str = "books";
        }
        pub mod _books_arguments {
            pub struct mutationType;
            impl cynic::schema::HasArgument<mutationType> for super::books {
                type ArgumentType = Option<super::super::super::MutationType>;
                const NAME: &'static str = "mutationType";
            }
        }
        pub struct __typename;
        impl cynic::schema::HasField<__typename> for super::super::SubscriptionRoot {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
    }
}
pub type Boolean = bool;
pub type String = std::string::String;
pub type Float = f64;
pub type Int = i32;
pub type ID = cynic::Id;
pub mod variable {
    use cynic::variables::VariableType;
    #[doc = r" Used to determine the type of a given variable that"]
    #[doc = r" appears in an argument struct."]
    pub trait Variable {
        const TYPE: VariableType;
    }
    impl<T> Variable for &T
    where
        T: ?::core::marker::Sized + Variable,
    {
        const TYPE: VariableType = T::TYPE;
    }
    impl<T> Variable for Option<T>
    where
        T: Variable,
    {
        const TYPE: VariableType = VariableType::Nullable(&T::TYPE);
    }
    impl<T> Variable for [T]
    where
        T: Variable,
    {
        const TYPE: VariableType = VariableType::List(&T::TYPE);
    }
    impl<T> Variable for Vec<T>
    where
        T: Variable,
    {
        const TYPE: VariableType = VariableType::List(&T::TYPE);
    }
    impl<T> Variable for Box<T>
    where
        T: Variable,
    {
        const TYPE: VariableType = T::TYPE;
    }
    impl<T> Variable for std::rc::Rc<T>
    where
        T: Variable,
    {
        const TYPE: VariableType = T::TYPE;
    }
    impl<T> Variable for std::sync::Arc<T>
    where
        T: Variable,
    {
        const TYPE: VariableType = T::TYPE;
    }
    impl<T> Variable for std::borrow::Cow<'_, T>
    where
        T: ?::core::marker::Sized + Variable + ToOwned,
    {
        const TYPE: VariableType = T::TYPE;
    }
    impl Variable for bool {
        const TYPE: VariableType = VariableType::Named("Boolean");
    }
    impl Variable for str {
        const TYPE: VariableType = VariableType::Named("String");
    }
    impl Variable for String {
        const TYPE: VariableType = <str as Variable>::TYPE;
    }
    impl Variable for f64 {
        const TYPE: VariableType = VariableType::Named("Float");
    }
    impl Variable for i32 {
        const TYPE: VariableType = VariableType::Named("Int");
    }
    impl Variable for cynic::Id {
        const TYPE: VariableType = VariableType::Named("ID");
    }
}

