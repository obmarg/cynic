---
source: cynic-codegen/tests/use-schema.rs
assertion_line: 30
expression: "format_code(format!(\"{}\", tokens))"
---
impl ::cynic::schema::QueryRoot for Root {}
pub struct Film;
pub mod film_fields {
    pub struct title;
    impl ::cynic::schema::Field for title {
        type Type = Option<super::String>;
        const NAME: &'static str = "title";
    }
    impl ::cynic::schema::HasField<title> for super::Film {
        type Type = Option<super::String>;
    }
    pub struct episodeID;
    impl ::cynic::schema::Field for episodeID {
        type Type = Option<super::Int>;
        const NAME: &'static str = "episodeID";
    }
    impl ::cynic::schema::HasField<episodeID> for super::Film {
        type Type = Option<super::Int>;
    }
    pub struct openingCrawl;
    impl ::cynic::schema::Field for openingCrawl {
        type Type = Option<super::String>;
        const NAME: &'static str = "openingCrawl";
    }
    impl ::cynic::schema::HasField<openingCrawl> for super::Film {
        type Type = Option<super::String>;
    }
    pub struct director;
    impl ::cynic::schema::Field for director {
        type Type = Option<super::String>;
        const NAME: &'static str = "director";
    }
    impl ::cynic::schema::HasField<director> for super::Film {
        type Type = Option<super::String>;
    }
    pub struct producers;
    impl ::cynic::schema::Field for producers {
        type Type = Option<Vec<Option<super::String>>>;
        const NAME: &'static str = "producers";
    }
    impl ::cynic::schema::HasField<producers> for super::Film {
        type Type = Option<Vec<Option<super::String>>>;
    }
    pub struct releaseDate;
    impl ::cynic::schema::Field for releaseDate {
        type Type = Option<super::String>;
        const NAME: &'static str = "releaseDate";
    }
    impl ::cynic::schema::HasField<releaseDate> for super::Film {
        type Type = Option<super::String>;
    }
    pub struct speciesConnection;
    impl ::cynic::schema::Field for speciesConnection {
        type Type = Option<super::FilmSpeciesConnection>;
        const NAME: &'static str = "speciesConnection";
    }
    impl ::cynic::schema::HasField<speciesConnection> for super::Film {
        type Type = Option<super::FilmSpeciesConnection>;
    }
    pub mod species_connection_arguments {
        pub struct after;
        impl ::cynic::schema::HasArgument<after> for super::speciesConnection {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "after";
        }
        pub struct first;
        impl ::cynic::schema::HasArgument<first> for super::speciesConnection {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "first";
        }
        pub struct before;
        impl ::cynic::schema::HasArgument<before> for super::speciesConnection {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "before";
        }
        pub struct last;
        impl ::cynic::schema::HasArgument<last> for super::speciesConnection {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "last";
        }
    }
    pub struct starshipConnection;
    impl ::cynic::schema::Field for starshipConnection {
        type Type = Option<super::FilmStarshipsConnection>;
        const NAME: &'static str = "starshipConnection";
    }
    impl ::cynic::schema::HasField<starshipConnection> for super::Film {
        type Type = Option<super::FilmStarshipsConnection>;
    }
    pub mod starship_connection_arguments {
        pub struct after;
        impl ::cynic::schema::HasArgument<after> for super::starshipConnection {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "after";
        }
        pub struct first;
        impl ::cynic::schema::HasArgument<first> for super::starshipConnection {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "first";
        }
        pub struct before;
        impl ::cynic::schema::HasArgument<before> for super::starshipConnection {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "before";
        }
        pub struct last;
        impl ::cynic::schema::HasArgument<last> for super::starshipConnection {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "last";
        }
    }
    pub struct vehicleConnection;
    impl ::cynic::schema::Field for vehicleConnection {
        type Type = Option<super::FilmVehiclesConnection>;
        const NAME: &'static str = "vehicleConnection";
    }
    impl ::cynic::schema::HasField<vehicleConnection> for super::Film {
        type Type = Option<super::FilmVehiclesConnection>;
    }
    pub mod vehicle_connection_arguments {
        pub struct after;
        impl ::cynic::schema::HasArgument<after> for super::vehicleConnection {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "after";
        }
        pub struct first;
        impl ::cynic::schema::HasArgument<first> for super::vehicleConnection {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "first";
        }
        pub struct before;
        impl ::cynic::schema::HasArgument<before> for super::vehicleConnection {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "before";
        }
        pub struct last;
        impl ::cynic::schema::HasArgument<last> for super::vehicleConnection {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "last";
        }
    }
    pub struct characterConnection;
    impl ::cynic::schema::Field for characterConnection {
        type Type = Option<super::FilmCharactersConnection>;
        const NAME: &'static str = "characterConnection";
    }
    impl ::cynic::schema::HasField<characterConnection> for super::Film {
        type Type = Option<super::FilmCharactersConnection>;
    }
    pub mod character_connection_arguments {
        pub struct after;
        impl ::cynic::schema::HasArgument<after> for super::characterConnection {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "after";
        }
        pub struct first;
        impl ::cynic::schema::HasArgument<first> for super::characterConnection {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "first";
        }
        pub struct before;
        impl ::cynic::schema::HasArgument<before> for super::characterConnection {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "before";
        }
        pub struct last;
        impl ::cynic::schema::HasArgument<last> for super::characterConnection {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "last";
        }
    }
    pub struct planetConnection;
    impl ::cynic::schema::Field for planetConnection {
        type Type = Option<super::FilmPlanetsConnection>;
        const NAME: &'static str = "planetConnection";
    }
    impl ::cynic::schema::HasField<planetConnection> for super::Film {
        type Type = Option<super::FilmPlanetsConnection>;
    }
    pub mod planet_connection_arguments {
        pub struct after;
        impl ::cynic::schema::HasArgument<after> for super::planetConnection {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "after";
        }
        pub struct first;
        impl ::cynic::schema::HasArgument<first> for super::planetConnection {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "first";
        }
        pub struct before;
        impl ::cynic::schema::HasArgument<before> for super::planetConnection {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "before";
        }
        pub struct last;
        impl ::cynic::schema::HasArgument<last> for super::planetConnection {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "last";
        }
    }
    pub struct created;
    impl ::cynic::schema::Field for created {
        type Type = Option<super::String>;
        const NAME: &'static str = "created";
    }
    impl ::cynic::schema::HasField<created> for super::Film {
        type Type = Option<super::String>;
    }
    pub struct edited;
    impl ::cynic::schema::Field for edited {
        type Type = Option<super::String>;
        const NAME: &'static str = "edited";
    }
    impl ::cynic::schema::HasField<edited> for super::Film {
        type Type = Option<super::String>;
    }
    pub struct id;
    impl ::cynic::schema::Field for id {
        type Type = super::ID;
        const NAME: &'static str = "id";
    }
    impl ::cynic::schema::HasField<id> for super::Film {
        type Type = super::ID;
    }
}
pub struct FilmCharactersConnection;
pub mod film_characters_connection_fields {
    pub struct pageInfo;
    impl ::cynic::schema::Field for pageInfo {
        type Type = super::PageInfo;
        const NAME: &'static str = "pageInfo";
    }
    impl ::cynic::schema::HasField<pageInfo> for super::FilmCharactersConnection {
        type Type = super::PageInfo;
    }
    pub struct edges;
    impl ::cynic::schema::Field for edges {
        type Type = Option<Vec<Option<super::FilmCharactersEdge>>>;
        const NAME: &'static str = "edges";
    }
    impl ::cynic::schema::HasField<edges> for super::FilmCharactersConnection {
        type Type = Option<Vec<Option<super::FilmCharactersEdge>>>;
    }
    pub struct totalCount;
    impl ::cynic::schema::Field for totalCount {
        type Type = Option<super::Int>;
        const NAME: &'static str = "totalCount";
    }
    impl ::cynic::schema::HasField<totalCount> for super::FilmCharactersConnection {
        type Type = Option<super::Int>;
    }
    pub struct characters;
    impl ::cynic::schema::Field for characters {
        type Type = Option<Vec<Option<super::Person>>>;
        const NAME: &'static str = "characters";
    }
    impl ::cynic::schema::HasField<characters> for super::FilmCharactersConnection {
        type Type = Option<Vec<Option<super::Person>>>;
    }
}
pub struct FilmCharactersEdge;
pub mod film_characters_edge_fields {
    pub struct node;
    impl ::cynic::schema::Field for node {
        type Type = Option<super::Person>;
        const NAME: &'static str = "node";
    }
    impl ::cynic::schema::HasField<node> for super::FilmCharactersEdge {
        type Type = Option<super::Person>;
    }
    pub struct cursor;
    impl ::cynic::schema::Field for cursor {
        type Type = super::String;
        const NAME: &'static str = "cursor";
    }
    impl ::cynic::schema::HasField<cursor> for super::FilmCharactersEdge {
        type Type = super::String;
    }
}
pub struct FilmPlanetsConnection;
pub mod film_planets_connection_fields {
    pub struct pageInfo;
    impl ::cynic::schema::Field for pageInfo {
        type Type = super::PageInfo;
        const NAME: &'static str = "pageInfo";
    }
    impl ::cynic::schema::HasField<pageInfo> for super::FilmPlanetsConnection {
        type Type = super::PageInfo;
    }
    pub struct edges;
    impl ::cynic::schema::Field for edges {
        type Type = Option<Vec<Option<super::FilmPlanetsEdge>>>;
        const NAME: &'static str = "edges";
    }
    impl ::cynic::schema::HasField<edges> for super::FilmPlanetsConnection {
        type Type = Option<Vec<Option<super::FilmPlanetsEdge>>>;
    }
    pub struct totalCount;
    impl ::cynic::schema::Field for totalCount {
        type Type = Option<super::Int>;
        const NAME: &'static str = "totalCount";
    }
    impl ::cynic::schema::HasField<totalCount> for super::FilmPlanetsConnection {
        type Type = Option<super::Int>;
    }
    pub struct planets;
    impl ::cynic::schema::Field for planets {
        type Type = Option<Vec<Option<super::Planet>>>;
        const NAME: &'static str = "planets";
    }
    impl ::cynic::schema::HasField<planets> for super::FilmPlanetsConnection {
        type Type = Option<Vec<Option<super::Planet>>>;
    }
}
pub struct FilmPlanetsEdge;
pub mod film_planets_edge_fields {
    pub struct node;
    impl ::cynic::schema::Field for node {
        type Type = Option<super::Planet>;
        const NAME: &'static str = "node";
    }
    impl ::cynic::schema::HasField<node> for super::FilmPlanetsEdge {
        type Type = Option<super::Planet>;
    }
    pub struct cursor;
    impl ::cynic::schema::Field for cursor {
        type Type = super::String;
        const NAME: &'static str = "cursor";
    }
    impl ::cynic::schema::HasField<cursor> for super::FilmPlanetsEdge {
        type Type = super::String;
    }
}
pub struct FilmSpeciesConnection;
pub mod film_species_connection_fields {
    pub struct pageInfo;
    impl ::cynic::schema::Field for pageInfo {
        type Type = super::PageInfo;
        const NAME: &'static str = "pageInfo";
    }
    impl ::cynic::schema::HasField<pageInfo> for super::FilmSpeciesConnection {
        type Type = super::PageInfo;
    }
    pub struct edges;
    impl ::cynic::schema::Field for edges {
        type Type = Option<Vec<Option<super::FilmSpeciesEdge>>>;
        const NAME: &'static str = "edges";
    }
    impl ::cynic::schema::HasField<edges> for super::FilmSpeciesConnection {
        type Type = Option<Vec<Option<super::FilmSpeciesEdge>>>;
    }
    pub struct totalCount;
    impl ::cynic::schema::Field for totalCount {
        type Type = Option<super::Int>;
        const NAME: &'static str = "totalCount";
    }
    impl ::cynic::schema::HasField<totalCount> for super::FilmSpeciesConnection {
        type Type = Option<super::Int>;
    }
    pub struct species;
    impl ::cynic::schema::Field for species {
        type Type = Option<Vec<Option<super::Species>>>;
        const NAME: &'static str = "species";
    }
    impl ::cynic::schema::HasField<species> for super::FilmSpeciesConnection {
        type Type = Option<Vec<Option<super::Species>>>;
    }
}
pub struct FilmSpeciesEdge;
pub mod film_species_edge_fields {
    pub struct node;
    impl ::cynic::schema::Field for node {
        type Type = Option<super::Species>;
        const NAME: &'static str = "node";
    }
    impl ::cynic::schema::HasField<node> for super::FilmSpeciesEdge {
        type Type = Option<super::Species>;
    }
    pub struct cursor;
    impl ::cynic::schema::Field for cursor {
        type Type = super::String;
        const NAME: &'static str = "cursor";
    }
    impl ::cynic::schema::HasField<cursor> for super::FilmSpeciesEdge {
        type Type = super::String;
    }
}
pub struct FilmStarshipsConnection;
pub mod film_starships_connection_fields {
    pub struct pageInfo;
    impl ::cynic::schema::Field for pageInfo {
        type Type = super::PageInfo;
        const NAME: &'static str = "pageInfo";
    }
    impl ::cynic::schema::HasField<pageInfo> for super::FilmStarshipsConnection {
        type Type = super::PageInfo;
    }
    pub struct edges;
    impl ::cynic::schema::Field for edges {
        type Type = Option<Vec<Option<super::FilmStarshipsEdge>>>;
        const NAME: &'static str = "edges";
    }
    impl ::cynic::schema::HasField<edges> for super::FilmStarshipsConnection {
        type Type = Option<Vec<Option<super::FilmStarshipsEdge>>>;
    }
    pub struct totalCount;
    impl ::cynic::schema::Field for totalCount {
        type Type = Option<super::Int>;
        const NAME: &'static str = "totalCount";
    }
    impl ::cynic::schema::HasField<totalCount> for super::FilmStarshipsConnection {
        type Type = Option<super::Int>;
    }
    pub struct starships;
    impl ::cynic::schema::Field for starships {
        type Type = Option<Vec<Option<super::Starship>>>;
        const NAME: &'static str = "starships";
    }
    impl ::cynic::schema::HasField<starships> for super::FilmStarshipsConnection {
        type Type = Option<Vec<Option<super::Starship>>>;
    }
}
pub struct FilmStarshipsEdge;
pub mod film_starships_edge_fields {
    pub struct node;
    impl ::cynic::schema::Field for node {
        type Type = Option<super::Starship>;
        const NAME: &'static str = "node";
    }
    impl ::cynic::schema::HasField<node> for super::FilmStarshipsEdge {
        type Type = Option<super::Starship>;
    }
    pub struct cursor;
    impl ::cynic::schema::Field for cursor {
        type Type = super::String;
        const NAME: &'static str = "cursor";
    }
    impl ::cynic::schema::HasField<cursor> for super::FilmStarshipsEdge {
        type Type = super::String;
    }
}
pub struct FilmVehiclesConnection;
pub mod film_vehicles_connection_fields {
    pub struct pageInfo;
    impl ::cynic::schema::Field for pageInfo {
        type Type = super::PageInfo;
        const NAME: &'static str = "pageInfo";
    }
    impl ::cynic::schema::HasField<pageInfo> for super::FilmVehiclesConnection {
        type Type = super::PageInfo;
    }
    pub struct edges;
    impl ::cynic::schema::Field for edges {
        type Type = Option<Vec<Option<super::FilmVehiclesEdge>>>;
        const NAME: &'static str = "edges";
    }
    impl ::cynic::schema::HasField<edges> for super::FilmVehiclesConnection {
        type Type = Option<Vec<Option<super::FilmVehiclesEdge>>>;
    }
    pub struct totalCount;
    impl ::cynic::schema::Field for totalCount {
        type Type = Option<super::Int>;
        const NAME: &'static str = "totalCount";
    }
    impl ::cynic::schema::HasField<totalCount> for super::FilmVehiclesConnection {
        type Type = Option<super::Int>;
    }
    pub struct vehicles;
    impl ::cynic::schema::Field for vehicles {
        type Type = Option<Vec<Option<super::Vehicle>>>;
        const NAME: &'static str = "vehicles";
    }
    impl ::cynic::schema::HasField<vehicles> for super::FilmVehiclesConnection {
        type Type = Option<Vec<Option<super::Vehicle>>>;
    }
}
pub struct FilmVehiclesEdge;
pub mod film_vehicles_edge_fields {
    pub struct node;
    impl ::cynic::schema::Field for node {
        type Type = Option<super::Vehicle>;
        const NAME: &'static str = "node";
    }
    impl ::cynic::schema::HasField<node> for super::FilmVehiclesEdge {
        type Type = Option<super::Vehicle>;
    }
    pub struct cursor;
    impl ::cynic::schema::Field for cursor {
        type Type = super::String;
        const NAME: &'static str = "cursor";
    }
    impl ::cynic::schema::HasField<cursor> for super::FilmVehiclesEdge {
        type Type = super::String;
    }
}
pub struct FilmsConnection;
pub mod films_connection_fields {
    pub struct pageInfo;
    impl ::cynic::schema::Field for pageInfo {
        type Type = super::PageInfo;
        const NAME: &'static str = "pageInfo";
    }
    impl ::cynic::schema::HasField<pageInfo> for super::FilmsConnection {
        type Type = super::PageInfo;
    }
    pub struct edges;
    impl ::cynic::schema::Field for edges {
        type Type = Option<Vec<Option<super::FilmsEdge>>>;
        const NAME: &'static str = "edges";
    }
    impl ::cynic::schema::HasField<edges> for super::FilmsConnection {
        type Type = Option<Vec<Option<super::FilmsEdge>>>;
    }
    pub struct totalCount;
    impl ::cynic::schema::Field for totalCount {
        type Type = Option<super::Int>;
        const NAME: &'static str = "totalCount";
    }
    impl ::cynic::schema::HasField<totalCount> for super::FilmsConnection {
        type Type = Option<super::Int>;
    }
    pub struct films;
    impl ::cynic::schema::Field for films {
        type Type = Option<Vec<Option<super::Film>>>;
        const NAME: &'static str = "films";
    }
    impl ::cynic::schema::HasField<films> for super::FilmsConnection {
        type Type = Option<Vec<Option<super::Film>>>;
    }
}
pub struct FilmsEdge;
pub mod films_edge_fields {
    pub struct node;
    impl ::cynic::schema::Field for node {
        type Type = Option<super::Film>;
        const NAME: &'static str = "node";
    }
    impl ::cynic::schema::HasField<node> for super::FilmsEdge {
        type Type = Option<super::Film>;
    }
    pub struct cursor;
    impl ::cynic::schema::Field for cursor {
        type Type = super::String;
        const NAME: &'static str = "cursor";
    }
    impl ::cynic::schema::HasField<cursor> for super::FilmsEdge {
        type Type = super::String;
    }
}
pub struct Node;
pub mod node_fields {
    pub struct id;
    impl ::cynic::schema::Field for id {
        type Type = super::ID;
        const NAME: &'static str = "id";
    }
    impl ::cynic::schema::HasField<id> for super::Node {
        type Type = super::ID;
    }
}
pub struct PageInfo;
pub mod page_info_fields {
    pub struct hasNextPage;
    impl ::cynic::schema::Field for hasNextPage {
        type Type = super::Boolean;
        const NAME: &'static str = "hasNextPage";
    }
    impl ::cynic::schema::HasField<hasNextPage> for super::PageInfo {
        type Type = super::Boolean;
    }
    pub struct hasPreviousPage;
    impl ::cynic::schema::Field for hasPreviousPage {
        type Type = super::Boolean;
        const NAME: &'static str = "hasPreviousPage";
    }
    impl ::cynic::schema::HasField<hasPreviousPage> for super::PageInfo {
        type Type = super::Boolean;
    }
    pub struct startCursor;
    impl ::cynic::schema::Field for startCursor {
        type Type = Option<super::String>;
        const NAME: &'static str = "startCursor";
    }
    impl ::cynic::schema::HasField<startCursor> for super::PageInfo {
        type Type = Option<super::String>;
    }
    pub struct endCursor;
    impl ::cynic::schema::Field for endCursor {
        type Type = Option<super::String>;
        const NAME: &'static str = "endCursor";
    }
    impl ::cynic::schema::HasField<endCursor> for super::PageInfo {
        type Type = Option<super::String>;
    }
}
pub struct PeopleConnection;
pub mod people_connection_fields {
    pub struct pageInfo;
    impl ::cynic::schema::Field for pageInfo {
        type Type = super::PageInfo;
        const NAME: &'static str = "pageInfo";
    }
    impl ::cynic::schema::HasField<pageInfo> for super::PeopleConnection {
        type Type = super::PageInfo;
    }
    pub struct edges;
    impl ::cynic::schema::Field for edges {
        type Type = Option<Vec<Option<super::PeopleEdge>>>;
        const NAME: &'static str = "edges";
    }
    impl ::cynic::schema::HasField<edges> for super::PeopleConnection {
        type Type = Option<Vec<Option<super::PeopleEdge>>>;
    }
    pub struct totalCount;
    impl ::cynic::schema::Field for totalCount {
        type Type = Option<super::Int>;
        const NAME: &'static str = "totalCount";
    }
    impl ::cynic::schema::HasField<totalCount> for super::PeopleConnection {
        type Type = Option<super::Int>;
    }
    pub struct people;
    impl ::cynic::schema::Field for people {
        type Type = Option<Vec<Option<super::Person>>>;
        const NAME: &'static str = "people";
    }
    impl ::cynic::schema::HasField<people> for super::PeopleConnection {
        type Type = Option<Vec<Option<super::Person>>>;
    }
}
pub struct PeopleEdge;
pub mod people_edge_fields {
    pub struct node;
    impl ::cynic::schema::Field for node {
        type Type = Option<super::Person>;
        const NAME: &'static str = "node";
    }
    impl ::cynic::schema::HasField<node> for super::PeopleEdge {
        type Type = Option<super::Person>;
    }
    pub struct cursor;
    impl ::cynic::schema::Field for cursor {
        type Type = super::String;
        const NAME: &'static str = "cursor";
    }
    impl ::cynic::schema::HasField<cursor> for super::PeopleEdge {
        type Type = super::String;
    }
}
pub struct Person;
pub mod person_fields {
    pub struct name;
    impl ::cynic::schema::Field for name {
        type Type = Option<super::String>;
        const NAME: &'static str = "name";
    }
    impl ::cynic::schema::HasField<name> for super::Person {
        type Type = Option<super::String>;
    }
    pub struct birthYear;
    impl ::cynic::schema::Field for birthYear {
        type Type = Option<super::String>;
        const NAME: &'static str = "birthYear";
    }
    impl ::cynic::schema::HasField<birthYear> for super::Person {
        type Type = Option<super::String>;
    }
    pub struct eyeColor;
    impl ::cynic::schema::Field for eyeColor {
        type Type = Option<super::String>;
        const NAME: &'static str = "eyeColor";
    }
    impl ::cynic::schema::HasField<eyeColor> for super::Person {
        type Type = Option<super::String>;
    }
    pub struct gender;
    impl ::cynic::schema::Field for gender {
        type Type = Option<super::String>;
        const NAME: &'static str = "gender";
    }
    impl ::cynic::schema::HasField<gender> for super::Person {
        type Type = Option<super::String>;
    }
    pub struct hairColor;
    impl ::cynic::schema::Field for hairColor {
        type Type = Option<super::String>;
        const NAME: &'static str = "hairColor";
    }
    impl ::cynic::schema::HasField<hairColor> for super::Person {
        type Type = Option<super::String>;
    }
    pub struct height;
    impl ::cynic::schema::Field for height {
        type Type = Option<super::Int>;
        const NAME: &'static str = "height";
    }
    impl ::cynic::schema::HasField<height> for super::Person {
        type Type = Option<super::Int>;
    }
    pub struct mass;
    impl ::cynic::schema::Field for mass {
        type Type = Option<super::Float>;
        const NAME: &'static str = "mass";
    }
    impl ::cynic::schema::HasField<mass> for super::Person {
        type Type = Option<super::Float>;
    }
    pub struct skinColor;
    impl ::cynic::schema::Field for skinColor {
        type Type = Option<super::String>;
        const NAME: &'static str = "skinColor";
    }
    impl ::cynic::schema::HasField<skinColor> for super::Person {
        type Type = Option<super::String>;
    }
    pub struct homeworld;
    impl ::cynic::schema::Field for homeworld {
        type Type = Option<super::Planet>;
        const NAME: &'static str = "homeworld";
    }
    impl ::cynic::schema::HasField<homeworld> for super::Person {
        type Type = Option<super::Planet>;
    }
    pub struct filmConnection;
    impl ::cynic::schema::Field for filmConnection {
        type Type = Option<super::PersonFilmsConnection>;
        const NAME: &'static str = "filmConnection";
    }
    impl ::cynic::schema::HasField<filmConnection> for super::Person {
        type Type = Option<super::PersonFilmsConnection>;
    }
    pub mod film_connection_arguments {
        pub struct after;
        impl ::cynic::schema::HasArgument<after> for super::filmConnection {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "after";
        }
        pub struct first;
        impl ::cynic::schema::HasArgument<first> for super::filmConnection {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "first";
        }
        pub struct before;
        impl ::cynic::schema::HasArgument<before> for super::filmConnection {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "before";
        }
        pub struct last;
        impl ::cynic::schema::HasArgument<last> for super::filmConnection {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "last";
        }
    }
    pub struct species;
    impl ::cynic::schema::Field for species {
        type Type = Option<super::Species>;
        const NAME: &'static str = "species";
    }
    impl ::cynic::schema::HasField<species> for super::Person {
        type Type = Option<super::Species>;
    }
    pub struct starshipConnection;
    impl ::cynic::schema::Field for starshipConnection {
        type Type = Option<super::PersonStarshipsConnection>;
        const NAME: &'static str = "starshipConnection";
    }
    impl ::cynic::schema::HasField<starshipConnection> for super::Person {
        type Type = Option<super::PersonStarshipsConnection>;
    }
    pub mod starship_connection_arguments {
        pub struct after;
        impl ::cynic::schema::HasArgument<after> for super::starshipConnection {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "after";
        }
        pub struct first;
        impl ::cynic::schema::HasArgument<first> for super::starshipConnection {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "first";
        }
        pub struct before;
        impl ::cynic::schema::HasArgument<before> for super::starshipConnection {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "before";
        }
        pub struct last;
        impl ::cynic::schema::HasArgument<last> for super::starshipConnection {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "last";
        }
    }
    pub struct vehicleConnection;
    impl ::cynic::schema::Field for vehicleConnection {
        type Type = Option<super::PersonVehiclesConnection>;
        const NAME: &'static str = "vehicleConnection";
    }
    impl ::cynic::schema::HasField<vehicleConnection> for super::Person {
        type Type = Option<super::PersonVehiclesConnection>;
    }
    pub mod vehicle_connection_arguments {
        pub struct after;
        impl ::cynic::schema::HasArgument<after> for super::vehicleConnection {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "after";
        }
        pub struct first;
        impl ::cynic::schema::HasArgument<first> for super::vehicleConnection {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "first";
        }
        pub struct before;
        impl ::cynic::schema::HasArgument<before> for super::vehicleConnection {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "before";
        }
        pub struct last;
        impl ::cynic::schema::HasArgument<last> for super::vehicleConnection {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "last";
        }
    }
    pub struct created;
    impl ::cynic::schema::Field for created {
        type Type = Option<super::String>;
        const NAME: &'static str = "created";
    }
    impl ::cynic::schema::HasField<created> for super::Person {
        type Type = Option<super::String>;
    }
    pub struct edited;
    impl ::cynic::schema::Field for edited {
        type Type = Option<super::String>;
        const NAME: &'static str = "edited";
    }
    impl ::cynic::schema::HasField<edited> for super::Person {
        type Type = Option<super::String>;
    }
    pub struct id;
    impl ::cynic::schema::Field for id {
        type Type = super::ID;
        const NAME: &'static str = "id";
    }
    impl ::cynic::schema::HasField<id> for super::Person {
        type Type = super::ID;
    }
}
pub struct PersonFilmsConnection;
pub mod person_films_connection_fields {
    pub struct pageInfo;
    impl ::cynic::schema::Field for pageInfo {
        type Type = super::PageInfo;
        const NAME: &'static str = "pageInfo";
    }
    impl ::cynic::schema::HasField<pageInfo> for super::PersonFilmsConnection {
        type Type = super::PageInfo;
    }
    pub struct edges;
    impl ::cynic::schema::Field for edges {
        type Type = Option<Vec<Option<super::PersonFilmsEdge>>>;
        const NAME: &'static str = "edges";
    }
    impl ::cynic::schema::HasField<edges> for super::PersonFilmsConnection {
        type Type = Option<Vec<Option<super::PersonFilmsEdge>>>;
    }
    pub struct totalCount;
    impl ::cynic::schema::Field for totalCount {
        type Type = Option<super::Int>;
        const NAME: &'static str = "totalCount";
    }
    impl ::cynic::schema::HasField<totalCount> for super::PersonFilmsConnection {
        type Type = Option<super::Int>;
    }
    pub struct films;
    impl ::cynic::schema::Field for films {
        type Type = Option<Vec<Option<super::Film>>>;
        const NAME: &'static str = "films";
    }
    impl ::cynic::schema::HasField<films> for super::PersonFilmsConnection {
        type Type = Option<Vec<Option<super::Film>>>;
    }
}
pub struct PersonFilmsEdge;
pub mod person_films_edge_fields {
    pub struct node;
    impl ::cynic::schema::Field for node {
        type Type = Option<super::Film>;
        const NAME: &'static str = "node";
    }
    impl ::cynic::schema::HasField<node> for super::PersonFilmsEdge {
        type Type = Option<super::Film>;
    }
    pub struct cursor;
    impl ::cynic::schema::Field for cursor {
        type Type = super::String;
        const NAME: &'static str = "cursor";
    }
    impl ::cynic::schema::HasField<cursor> for super::PersonFilmsEdge {
        type Type = super::String;
    }
}
pub struct PersonStarshipsConnection;
pub mod person_starships_connection_fields {
    pub struct pageInfo;
    impl ::cynic::schema::Field for pageInfo {
        type Type = super::PageInfo;
        const NAME: &'static str = "pageInfo";
    }
    impl ::cynic::schema::HasField<pageInfo> for super::PersonStarshipsConnection {
        type Type = super::PageInfo;
    }
    pub struct edges;
    impl ::cynic::schema::Field for edges {
        type Type = Option<Vec<Option<super::PersonStarshipsEdge>>>;
        const NAME: &'static str = "edges";
    }
    impl ::cynic::schema::HasField<edges> for super::PersonStarshipsConnection {
        type Type = Option<Vec<Option<super::PersonStarshipsEdge>>>;
    }
    pub struct totalCount;
    impl ::cynic::schema::Field for totalCount {
        type Type = Option<super::Int>;
        const NAME: &'static str = "totalCount";
    }
    impl ::cynic::schema::HasField<totalCount> for super::PersonStarshipsConnection {
        type Type = Option<super::Int>;
    }
    pub struct starships;
    impl ::cynic::schema::Field for starships {
        type Type = Option<Vec<Option<super::Starship>>>;
        const NAME: &'static str = "starships";
    }
    impl ::cynic::schema::HasField<starships> for super::PersonStarshipsConnection {
        type Type = Option<Vec<Option<super::Starship>>>;
    }
}
pub struct PersonStarshipsEdge;
pub mod person_starships_edge_fields {
    pub struct node;
    impl ::cynic::schema::Field for node {
        type Type = Option<super::Starship>;
        const NAME: &'static str = "node";
    }
    impl ::cynic::schema::HasField<node> for super::PersonStarshipsEdge {
        type Type = Option<super::Starship>;
    }
    pub struct cursor;
    impl ::cynic::schema::Field for cursor {
        type Type = super::String;
        const NAME: &'static str = "cursor";
    }
    impl ::cynic::schema::HasField<cursor> for super::PersonStarshipsEdge {
        type Type = super::String;
    }
}
pub struct PersonVehiclesConnection;
pub mod person_vehicles_connection_fields {
    pub struct pageInfo;
    impl ::cynic::schema::Field for pageInfo {
        type Type = super::PageInfo;
        const NAME: &'static str = "pageInfo";
    }
    impl ::cynic::schema::HasField<pageInfo> for super::PersonVehiclesConnection {
        type Type = super::PageInfo;
    }
    pub struct edges;
    impl ::cynic::schema::Field for edges {
        type Type = Option<Vec<Option<super::PersonVehiclesEdge>>>;
        const NAME: &'static str = "edges";
    }
    impl ::cynic::schema::HasField<edges> for super::PersonVehiclesConnection {
        type Type = Option<Vec<Option<super::PersonVehiclesEdge>>>;
    }
    pub struct totalCount;
    impl ::cynic::schema::Field for totalCount {
        type Type = Option<super::Int>;
        const NAME: &'static str = "totalCount";
    }
    impl ::cynic::schema::HasField<totalCount> for super::PersonVehiclesConnection {
        type Type = Option<super::Int>;
    }
    pub struct vehicles;
    impl ::cynic::schema::Field for vehicles {
        type Type = Option<Vec<Option<super::Vehicle>>>;
        const NAME: &'static str = "vehicles";
    }
    impl ::cynic::schema::HasField<vehicles> for super::PersonVehiclesConnection {
        type Type = Option<Vec<Option<super::Vehicle>>>;
    }
}
pub struct PersonVehiclesEdge;
pub mod person_vehicles_edge_fields {
    pub struct node;
    impl ::cynic::schema::Field for node {
        type Type = Option<super::Vehicle>;
        const NAME: &'static str = "node";
    }
    impl ::cynic::schema::HasField<node> for super::PersonVehiclesEdge {
        type Type = Option<super::Vehicle>;
    }
    pub struct cursor;
    impl ::cynic::schema::Field for cursor {
        type Type = super::String;
        const NAME: &'static str = "cursor";
    }
    impl ::cynic::schema::HasField<cursor> for super::PersonVehiclesEdge {
        type Type = super::String;
    }
}
pub struct Planet;
pub mod planet_fields {
    pub struct name;
    impl ::cynic::schema::Field for name {
        type Type = Option<super::String>;
        const NAME: &'static str = "name";
    }
    impl ::cynic::schema::HasField<name> for super::Planet {
        type Type = Option<super::String>;
    }
    pub struct diameter;
    impl ::cynic::schema::Field for diameter {
        type Type = Option<super::Int>;
        const NAME: &'static str = "diameter";
    }
    impl ::cynic::schema::HasField<diameter> for super::Planet {
        type Type = Option<super::Int>;
    }
    pub struct rotationPeriod;
    impl ::cynic::schema::Field for rotationPeriod {
        type Type = Option<super::Int>;
        const NAME: &'static str = "rotationPeriod";
    }
    impl ::cynic::schema::HasField<rotationPeriod> for super::Planet {
        type Type = Option<super::Int>;
    }
    pub struct orbitalPeriod;
    impl ::cynic::schema::Field for orbitalPeriod {
        type Type = Option<super::Int>;
        const NAME: &'static str = "orbitalPeriod";
    }
    impl ::cynic::schema::HasField<orbitalPeriod> for super::Planet {
        type Type = Option<super::Int>;
    }
    pub struct gravity;
    impl ::cynic::schema::Field for gravity {
        type Type = Option<super::String>;
        const NAME: &'static str = "gravity";
    }
    impl ::cynic::schema::HasField<gravity> for super::Planet {
        type Type = Option<super::String>;
    }
    pub struct population;
    impl ::cynic::schema::Field for population {
        type Type = Option<super::Float>;
        const NAME: &'static str = "population";
    }
    impl ::cynic::schema::HasField<population> for super::Planet {
        type Type = Option<super::Float>;
    }
    pub struct climates;
    impl ::cynic::schema::Field for climates {
        type Type = Option<Vec<Option<super::String>>>;
        const NAME: &'static str = "climates";
    }
    impl ::cynic::schema::HasField<climates> for super::Planet {
        type Type = Option<Vec<Option<super::String>>>;
    }
    pub struct terrains;
    impl ::cynic::schema::Field for terrains {
        type Type = Option<Vec<Option<super::String>>>;
        const NAME: &'static str = "terrains";
    }
    impl ::cynic::schema::HasField<terrains> for super::Planet {
        type Type = Option<Vec<Option<super::String>>>;
    }
    pub struct surfaceWater;
    impl ::cynic::schema::Field for surfaceWater {
        type Type = Option<super::Float>;
        const NAME: &'static str = "surfaceWater";
    }
    impl ::cynic::schema::HasField<surfaceWater> for super::Planet {
        type Type = Option<super::Float>;
    }
    pub struct residentConnection;
    impl ::cynic::schema::Field for residentConnection {
        type Type = Option<super::PlanetResidentsConnection>;
        const NAME: &'static str = "residentConnection";
    }
    impl ::cynic::schema::HasField<residentConnection> for super::Planet {
        type Type = Option<super::PlanetResidentsConnection>;
    }
    pub mod resident_connection_arguments {
        pub struct after;
        impl ::cynic::schema::HasArgument<after> for super::residentConnection {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "after";
        }
        pub struct first;
        impl ::cynic::schema::HasArgument<first> for super::residentConnection {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "first";
        }
        pub struct before;
        impl ::cynic::schema::HasArgument<before> for super::residentConnection {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "before";
        }
        pub struct last;
        impl ::cynic::schema::HasArgument<last> for super::residentConnection {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "last";
        }
    }
    pub struct filmConnection;
    impl ::cynic::schema::Field for filmConnection {
        type Type = Option<super::PlanetFilmsConnection>;
        const NAME: &'static str = "filmConnection";
    }
    impl ::cynic::schema::HasField<filmConnection> for super::Planet {
        type Type = Option<super::PlanetFilmsConnection>;
    }
    pub mod film_connection_arguments {
        pub struct after;
        impl ::cynic::schema::HasArgument<after> for super::filmConnection {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "after";
        }
        pub struct first;
        impl ::cynic::schema::HasArgument<first> for super::filmConnection {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "first";
        }
        pub struct before;
        impl ::cynic::schema::HasArgument<before> for super::filmConnection {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "before";
        }
        pub struct last;
        impl ::cynic::schema::HasArgument<last> for super::filmConnection {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "last";
        }
    }
    pub struct created;
    impl ::cynic::schema::Field for created {
        type Type = Option<super::String>;
        const NAME: &'static str = "created";
    }
    impl ::cynic::schema::HasField<created> for super::Planet {
        type Type = Option<super::String>;
    }
    pub struct edited;
    impl ::cynic::schema::Field for edited {
        type Type = Option<super::String>;
        const NAME: &'static str = "edited";
    }
    impl ::cynic::schema::HasField<edited> for super::Planet {
        type Type = Option<super::String>;
    }
    pub struct id;
    impl ::cynic::schema::Field for id {
        type Type = super::ID;
        const NAME: &'static str = "id";
    }
    impl ::cynic::schema::HasField<id> for super::Planet {
        type Type = super::ID;
    }
}
pub struct PlanetFilmsConnection;
pub mod planet_films_connection_fields {
    pub struct pageInfo;
    impl ::cynic::schema::Field for pageInfo {
        type Type = super::PageInfo;
        const NAME: &'static str = "pageInfo";
    }
    impl ::cynic::schema::HasField<pageInfo> for super::PlanetFilmsConnection {
        type Type = super::PageInfo;
    }
    pub struct edges;
    impl ::cynic::schema::Field for edges {
        type Type = Option<Vec<Option<super::PlanetFilmsEdge>>>;
        const NAME: &'static str = "edges";
    }
    impl ::cynic::schema::HasField<edges> for super::PlanetFilmsConnection {
        type Type = Option<Vec<Option<super::PlanetFilmsEdge>>>;
    }
    pub struct totalCount;
    impl ::cynic::schema::Field for totalCount {
        type Type = Option<super::Int>;
        const NAME: &'static str = "totalCount";
    }
    impl ::cynic::schema::HasField<totalCount> for super::PlanetFilmsConnection {
        type Type = Option<super::Int>;
    }
    pub struct films;
    impl ::cynic::schema::Field for films {
        type Type = Option<Vec<Option<super::Film>>>;
        const NAME: &'static str = "films";
    }
    impl ::cynic::schema::HasField<films> for super::PlanetFilmsConnection {
        type Type = Option<Vec<Option<super::Film>>>;
    }
}
pub struct PlanetFilmsEdge;
pub mod planet_films_edge_fields {
    pub struct node;
    impl ::cynic::schema::Field for node {
        type Type = Option<super::Film>;
        const NAME: &'static str = "node";
    }
    impl ::cynic::schema::HasField<node> for super::PlanetFilmsEdge {
        type Type = Option<super::Film>;
    }
    pub struct cursor;
    impl ::cynic::schema::Field for cursor {
        type Type = super::String;
        const NAME: &'static str = "cursor";
    }
    impl ::cynic::schema::HasField<cursor> for super::PlanetFilmsEdge {
        type Type = super::String;
    }
}
pub struct PlanetResidentsConnection;
pub mod planet_residents_connection_fields {
    pub struct pageInfo;
    impl ::cynic::schema::Field for pageInfo {
        type Type = super::PageInfo;
        const NAME: &'static str = "pageInfo";
    }
    impl ::cynic::schema::HasField<pageInfo> for super::PlanetResidentsConnection {
        type Type = super::PageInfo;
    }
    pub struct edges;
    impl ::cynic::schema::Field for edges {
        type Type = Option<Vec<Option<super::PlanetResidentsEdge>>>;
        const NAME: &'static str = "edges";
    }
    impl ::cynic::schema::HasField<edges> for super::PlanetResidentsConnection {
        type Type = Option<Vec<Option<super::PlanetResidentsEdge>>>;
    }
    pub struct totalCount;
    impl ::cynic::schema::Field for totalCount {
        type Type = Option<super::Int>;
        const NAME: &'static str = "totalCount";
    }
    impl ::cynic::schema::HasField<totalCount> for super::PlanetResidentsConnection {
        type Type = Option<super::Int>;
    }
    pub struct residents;
    impl ::cynic::schema::Field for residents {
        type Type = Option<Vec<Option<super::Person>>>;
        const NAME: &'static str = "residents";
    }
    impl ::cynic::schema::HasField<residents> for super::PlanetResidentsConnection {
        type Type = Option<Vec<Option<super::Person>>>;
    }
}
pub struct PlanetResidentsEdge;
pub mod planet_residents_edge_fields {
    pub struct node;
    impl ::cynic::schema::Field for node {
        type Type = Option<super::Person>;
        const NAME: &'static str = "node";
    }
    impl ::cynic::schema::HasField<node> for super::PlanetResidentsEdge {
        type Type = Option<super::Person>;
    }
    pub struct cursor;
    impl ::cynic::schema::Field for cursor {
        type Type = super::String;
        const NAME: &'static str = "cursor";
    }
    impl ::cynic::schema::HasField<cursor> for super::PlanetResidentsEdge {
        type Type = super::String;
    }
}
pub struct PlanetsConnection;
pub mod planets_connection_fields {
    pub struct pageInfo;
    impl ::cynic::schema::Field for pageInfo {
        type Type = super::PageInfo;
        const NAME: &'static str = "pageInfo";
    }
    impl ::cynic::schema::HasField<pageInfo> for super::PlanetsConnection {
        type Type = super::PageInfo;
    }
    pub struct edges;
    impl ::cynic::schema::Field for edges {
        type Type = Option<Vec<Option<super::PlanetsEdge>>>;
        const NAME: &'static str = "edges";
    }
    impl ::cynic::schema::HasField<edges> for super::PlanetsConnection {
        type Type = Option<Vec<Option<super::PlanetsEdge>>>;
    }
    pub struct totalCount;
    impl ::cynic::schema::Field for totalCount {
        type Type = Option<super::Int>;
        const NAME: &'static str = "totalCount";
    }
    impl ::cynic::schema::HasField<totalCount> for super::PlanetsConnection {
        type Type = Option<super::Int>;
    }
    pub struct planets;
    impl ::cynic::schema::Field for planets {
        type Type = Option<Vec<Option<super::Planet>>>;
        const NAME: &'static str = "planets";
    }
    impl ::cynic::schema::HasField<planets> for super::PlanetsConnection {
        type Type = Option<Vec<Option<super::Planet>>>;
    }
}
pub struct PlanetsEdge;
pub mod planets_edge_fields {
    pub struct node;
    impl ::cynic::schema::Field for node {
        type Type = Option<super::Planet>;
        const NAME: &'static str = "node";
    }
    impl ::cynic::schema::HasField<node> for super::PlanetsEdge {
        type Type = Option<super::Planet>;
    }
    pub struct cursor;
    impl ::cynic::schema::Field for cursor {
        type Type = super::String;
        const NAME: &'static str = "cursor";
    }
    impl ::cynic::schema::HasField<cursor> for super::PlanetsEdge {
        type Type = super::String;
    }
}
pub struct Root;
pub mod root_fields {
    pub struct allFilms;
    impl ::cynic::schema::Field for allFilms {
        type Type = Option<super::FilmsConnection>;
        const NAME: &'static str = "allFilms";
    }
    impl ::cynic::schema::HasField<allFilms> for super::Root {
        type Type = Option<super::FilmsConnection>;
    }
    pub mod all_films_arguments {
        pub struct after;
        impl ::cynic::schema::HasArgument<after> for super::allFilms {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "after";
        }
        pub struct first;
        impl ::cynic::schema::HasArgument<first> for super::allFilms {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "first";
        }
        pub struct before;
        impl ::cynic::schema::HasArgument<before> for super::allFilms {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "before";
        }
        pub struct last;
        impl ::cynic::schema::HasArgument<last> for super::allFilms {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "last";
        }
    }
    pub struct film;
    impl ::cynic::schema::Field for film {
        type Type = Option<super::Film>;
        const NAME: &'static str = "film";
    }
    impl ::cynic::schema::HasField<film> for super::Root {
        type Type = Option<super::Film>;
    }
    pub mod film_arguments {
        pub struct id;
        impl ::cynic::schema::HasArgument<id> for super::film {
            type ArgumentType = Option<super::super::ID>;
            const NAME: &'static str = "id";
        }
        pub struct filmID;
        impl ::cynic::schema::HasArgument<filmID> for super::film {
            type ArgumentType = Option<super::super::ID>;
            const NAME: &'static str = "filmID";
        }
    }
    pub struct allPeople;
    impl ::cynic::schema::Field for allPeople {
        type Type = Option<super::PeopleConnection>;
        const NAME: &'static str = "allPeople";
    }
    impl ::cynic::schema::HasField<allPeople> for super::Root {
        type Type = Option<super::PeopleConnection>;
    }
    pub mod all_people_arguments {
        pub struct after;
        impl ::cynic::schema::HasArgument<after> for super::allPeople {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "after";
        }
        pub struct first;
        impl ::cynic::schema::HasArgument<first> for super::allPeople {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "first";
        }
        pub struct before;
        impl ::cynic::schema::HasArgument<before> for super::allPeople {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "before";
        }
        pub struct last;
        impl ::cynic::schema::HasArgument<last> for super::allPeople {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "last";
        }
    }
    pub struct person;
    impl ::cynic::schema::Field for person {
        type Type = Option<super::Person>;
        const NAME: &'static str = "person";
    }
    impl ::cynic::schema::HasField<person> for super::Root {
        type Type = Option<super::Person>;
    }
    pub mod person_arguments {
        pub struct id;
        impl ::cynic::schema::HasArgument<id> for super::person {
            type ArgumentType = Option<super::super::ID>;
            const NAME: &'static str = "id";
        }
        pub struct personID;
        impl ::cynic::schema::HasArgument<personID> for super::person {
            type ArgumentType = Option<super::super::ID>;
            const NAME: &'static str = "personID";
        }
    }
    pub struct allPlanets;
    impl ::cynic::schema::Field for allPlanets {
        type Type = Option<super::PlanetsConnection>;
        const NAME: &'static str = "allPlanets";
    }
    impl ::cynic::schema::HasField<allPlanets> for super::Root {
        type Type = Option<super::PlanetsConnection>;
    }
    pub mod all_planets_arguments {
        pub struct after;
        impl ::cynic::schema::HasArgument<after> for super::allPlanets {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "after";
        }
        pub struct first;
        impl ::cynic::schema::HasArgument<first> for super::allPlanets {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "first";
        }
        pub struct before;
        impl ::cynic::schema::HasArgument<before> for super::allPlanets {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "before";
        }
        pub struct last;
        impl ::cynic::schema::HasArgument<last> for super::allPlanets {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "last";
        }
    }
    pub struct planet;
    impl ::cynic::schema::Field for planet {
        type Type = Option<super::Planet>;
        const NAME: &'static str = "planet";
    }
    impl ::cynic::schema::HasField<planet> for super::Root {
        type Type = Option<super::Planet>;
    }
    pub mod planet_arguments {
        pub struct id;
        impl ::cynic::schema::HasArgument<id> for super::planet {
            type ArgumentType = Option<super::super::ID>;
            const NAME: &'static str = "id";
        }
        pub struct planetID;
        impl ::cynic::schema::HasArgument<planetID> for super::planet {
            type ArgumentType = Option<super::super::ID>;
            const NAME: &'static str = "planetID";
        }
    }
    pub struct allSpecies;
    impl ::cynic::schema::Field for allSpecies {
        type Type = Option<super::SpeciesConnection>;
        const NAME: &'static str = "allSpecies";
    }
    impl ::cynic::schema::HasField<allSpecies> for super::Root {
        type Type = Option<super::SpeciesConnection>;
    }
    pub mod all_species_arguments {
        pub struct after;
        impl ::cynic::schema::HasArgument<after> for super::allSpecies {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "after";
        }
        pub struct first;
        impl ::cynic::schema::HasArgument<first> for super::allSpecies {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "first";
        }
        pub struct before;
        impl ::cynic::schema::HasArgument<before> for super::allSpecies {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "before";
        }
        pub struct last;
        impl ::cynic::schema::HasArgument<last> for super::allSpecies {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "last";
        }
    }
    pub struct species;
    impl ::cynic::schema::Field for species {
        type Type = Option<super::Species>;
        const NAME: &'static str = "species";
    }
    impl ::cynic::schema::HasField<species> for super::Root {
        type Type = Option<super::Species>;
    }
    pub mod species_arguments {
        pub struct id;
        impl ::cynic::schema::HasArgument<id> for super::species {
            type ArgumentType = Option<super::super::ID>;
            const NAME: &'static str = "id";
        }
        pub struct speciesID;
        impl ::cynic::schema::HasArgument<speciesID> for super::species {
            type ArgumentType = Option<super::super::ID>;
            const NAME: &'static str = "speciesID";
        }
    }
    pub struct allStarships;
    impl ::cynic::schema::Field for allStarships {
        type Type = Option<super::StarshipsConnection>;
        const NAME: &'static str = "allStarships";
    }
    impl ::cynic::schema::HasField<allStarships> for super::Root {
        type Type = Option<super::StarshipsConnection>;
    }
    pub mod all_starships_arguments {
        pub struct after;
        impl ::cynic::schema::HasArgument<after> for super::allStarships {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "after";
        }
        pub struct first;
        impl ::cynic::schema::HasArgument<first> for super::allStarships {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "first";
        }
        pub struct before;
        impl ::cynic::schema::HasArgument<before> for super::allStarships {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "before";
        }
        pub struct last;
        impl ::cynic::schema::HasArgument<last> for super::allStarships {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "last";
        }
    }
    pub struct starship;
    impl ::cynic::schema::Field for starship {
        type Type = Option<super::Starship>;
        const NAME: &'static str = "starship";
    }
    impl ::cynic::schema::HasField<starship> for super::Root {
        type Type = Option<super::Starship>;
    }
    pub mod starship_arguments {
        pub struct id;
        impl ::cynic::schema::HasArgument<id> for super::starship {
            type ArgumentType = Option<super::super::ID>;
            const NAME: &'static str = "id";
        }
        pub struct starshipID;
        impl ::cynic::schema::HasArgument<starshipID> for super::starship {
            type ArgumentType = Option<super::super::ID>;
            const NAME: &'static str = "starshipID";
        }
    }
    pub struct allVehicles;
    impl ::cynic::schema::Field for allVehicles {
        type Type = Option<super::VehiclesConnection>;
        const NAME: &'static str = "allVehicles";
    }
    impl ::cynic::schema::HasField<allVehicles> for super::Root {
        type Type = Option<super::VehiclesConnection>;
    }
    pub mod all_vehicles_arguments {
        pub struct after;
        impl ::cynic::schema::HasArgument<after> for super::allVehicles {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "after";
        }
        pub struct first;
        impl ::cynic::schema::HasArgument<first> for super::allVehicles {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "first";
        }
        pub struct before;
        impl ::cynic::schema::HasArgument<before> for super::allVehicles {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "before";
        }
        pub struct last;
        impl ::cynic::schema::HasArgument<last> for super::allVehicles {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "last";
        }
    }
    pub struct vehicle;
    impl ::cynic::schema::Field for vehicle {
        type Type = Option<super::Vehicle>;
        const NAME: &'static str = "vehicle";
    }
    impl ::cynic::schema::HasField<vehicle> for super::Root {
        type Type = Option<super::Vehicle>;
    }
    pub mod vehicle_arguments {
        pub struct id;
        impl ::cynic::schema::HasArgument<id> for super::vehicle {
            type ArgumentType = Option<super::super::ID>;
            const NAME: &'static str = "id";
        }
        pub struct vehicleID;
        impl ::cynic::schema::HasArgument<vehicleID> for super::vehicle {
            type ArgumentType = Option<super::super::ID>;
            const NAME: &'static str = "vehicleID";
        }
    }
    pub struct node;
    impl ::cynic::schema::Field for node {
        type Type = Option<super::Node>;
        const NAME: &'static str = "node";
    }
    impl ::cynic::schema::HasField<node> for super::Root {
        type Type = Option<super::Node>;
    }
    pub mod node_arguments {
        pub struct id;
        impl ::cynic::schema::HasArgument<id> for super::node {
            type ArgumentType = super::super::ID;
            const NAME: &'static str = "id";
        }
    }
}
pub struct Species;
pub mod species_fields {
    pub struct name;
    impl ::cynic::schema::Field for name {
        type Type = Option<super::String>;
        const NAME: &'static str = "name";
    }
    impl ::cynic::schema::HasField<name> for super::Species {
        type Type = Option<super::String>;
    }
    pub struct classification;
    impl ::cynic::schema::Field for classification {
        type Type = Option<super::String>;
        const NAME: &'static str = "classification";
    }
    impl ::cynic::schema::HasField<classification> for super::Species {
        type Type = Option<super::String>;
    }
    pub struct designation;
    impl ::cynic::schema::Field for designation {
        type Type = Option<super::String>;
        const NAME: &'static str = "designation";
    }
    impl ::cynic::schema::HasField<designation> for super::Species {
        type Type = Option<super::String>;
    }
    pub struct averageHeight;
    impl ::cynic::schema::Field for averageHeight {
        type Type = Option<super::Float>;
        const NAME: &'static str = "averageHeight";
    }
    impl ::cynic::schema::HasField<averageHeight> for super::Species {
        type Type = Option<super::Float>;
    }
    pub struct averageLifespan;
    impl ::cynic::schema::Field for averageLifespan {
        type Type = Option<super::Int>;
        const NAME: &'static str = "averageLifespan";
    }
    impl ::cynic::schema::HasField<averageLifespan> for super::Species {
        type Type = Option<super::Int>;
    }
    pub struct eyeColors;
    impl ::cynic::schema::Field for eyeColors {
        type Type = Option<Vec<Option<super::String>>>;
        const NAME: &'static str = "eyeColors";
    }
    impl ::cynic::schema::HasField<eyeColors> for super::Species {
        type Type = Option<Vec<Option<super::String>>>;
    }
    pub struct hairColors;
    impl ::cynic::schema::Field for hairColors {
        type Type = Option<Vec<Option<super::String>>>;
        const NAME: &'static str = "hairColors";
    }
    impl ::cynic::schema::HasField<hairColors> for super::Species {
        type Type = Option<Vec<Option<super::String>>>;
    }
    pub struct skinColors;
    impl ::cynic::schema::Field for skinColors {
        type Type = Option<Vec<Option<super::String>>>;
        const NAME: &'static str = "skinColors";
    }
    impl ::cynic::schema::HasField<skinColors> for super::Species {
        type Type = Option<Vec<Option<super::String>>>;
    }
    pub struct language;
    impl ::cynic::schema::Field for language {
        type Type = Option<super::String>;
        const NAME: &'static str = "language";
    }
    impl ::cynic::schema::HasField<language> for super::Species {
        type Type = Option<super::String>;
    }
    pub struct homeworld;
    impl ::cynic::schema::Field for homeworld {
        type Type = Option<super::Planet>;
        const NAME: &'static str = "homeworld";
    }
    impl ::cynic::schema::HasField<homeworld> for super::Species {
        type Type = Option<super::Planet>;
    }
    pub struct personConnection;
    impl ::cynic::schema::Field for personConnection {
        type Type = Option<super::SpeciesPeopleConnection>;
        const NAME: &'static str = "personConnection";
    }
    impl ::cynic::schema::HasField<personConnection> for super::Species {
        type Type = Option<super::SpeciesPeopleConnection>;
    }
    pub mod person_connection_arguments {
        pub struct after;
        impl ::cynic::schema::HasArgument<after> for super::personConnection {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "after";
        }
        pub struct first;
        impl ::cynic::schema::HasArgument<first> for super::personConnection {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "first";
        }
        pub struct before;
        impl ::cynic::schema::HasArgument<before> for super::personConnection {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "before";
        }
        pub struct last;
        impl ::cynic::schema::HasArgument<last> for super::personConnection {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "last";
        }
    }
    pub struct filmConnection;
    impl ::cynic::schema::Field for filmConnection {
        type Type = Option<super::SpeciesFilmsConnection>;
        const NAME: &'static str = "filmConnection";
    }
    impl ::cynic::schema::HasField<filmConnection> for super::Species {
        type Type = Option<super::SpeciesFilmsConnection>;
    }
    pub mod film_connection_arguments {
        pub struct after;
        impl ::cynic::schema::HasArgument<after> for super::filmConnection {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "after";
        }
        pub struct first;
        impl ::cynic::schema::HasArgument<first> for super::filmConnection {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "first";
        }
        pub struct before;
        impl ::cynic::schema::HasArgument<before> for super::filmConnection {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "before";
        }
        pub struct last;
        impl ::cynic::schema::HasArgument<last> for super::filmConnection {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "last";
        }
    }
    pub struct created;
    impl ::cynic::schema::Field for created {
        type Type = Option<super::String>;
        const NAME: &'static str = "created";
    }
    impl ::cynic::schema::HasField<created> for super::Species {
        type Type = Option<super::String>;
    }
    pub struct edited;
    impl ::cynic::schema::Field for edited {
        type Type = Option<super::String>;
        const NAME: &'static str = "edited";
    }
    impl ::cynic::schema::HasField<edited> for super::Species {
        type Type = Option<super::String>;
    }
    pub struct id;
    impl ::cynic::schema::Field for id {
        type Type = super::ID;
        const NAME: &'static str = "id";
    }
    impl ::cynic::schema::HasField<id> for super::Species {
        type Type = super::ID;
    }
}
pub struct SpeciesConnection;
pub mod species_connection_fields {
    pub struct pageInfo;
    impl ::cynic::schema::Field for pageInfo {
        type Type = super::PageInfo;
        const NAME: &'static str = "pageInfo";
    }
    impl ::cynic::schema::HasField<pageInfo> for super::SpeciesConnection {
        type Type = super::PageInfo;
    }
    pub struct edges;
    impl ::cynic::schema::Field for edges {
        type Type = Option<Vec<Option<super::SpeciesEdge>>>;
        const NAME: &'static str = "edges";
    }
    impl ::cynic::schema::HasField<edges> for super::SpeciesConnection {
        type Type = Option<Vec<Option<super::SpeciesEdge>>>;
    }
    pub struct totalCount;
    impl ::cynic::schema::Field for totalCount {
        type Type = Option<super::Int>;
        const NAME: &'static str = "totalCount";
    }
    impl ::cynic::schema::HasField<totalCount> for super::SpeciesConnection {
        type Type = Option<super::Int>;
    }
    pub struct species;
    impl ::cynic::schema::Field for species {
        type Type = Option<Vec<Option<super::Species>>>;
        const NAME: &'static str = "species";
    }
    impl ::cynic::schema::HasField<species> for super::SpeciesConnection {
        type Type = Option<Vec<Option<super::Species>>>;
    }
}
pub struct SpeciesEdge;
pub mod species_edge_fields {
    pub struct node;
    impl ::cynic::schema::Field for node {
        type Type = Option<super::Species>;
        const NAME: &'static str = "node";
    }
    impl ::cynic::schema::HasField<node> for super::SpeciesEdge {
        type Type = Option<super::Species>;
    }
    pub struct cursor;
    impl ::cynic::schema::Field for cursor {
        type Type = super::String;
        const NAME: &'static str = "cursor";
    }
    impl ::cynic::schema::HasField<cursor> for super::SpeciesEdge {
        type Type = super::String;
    }
}
pub struct SpeciesFilmsConnection;
pub mod species_films_connection_fields {
    pub struct pageInfo;
    impl ::cynic::schema::Field for pageInfo {
        type Type = super::PageInfo;
        const NAME: &'static str = "pageInfo";
    }
    impl ::cynic::schema::HasField<pageInfo> for super::SpeciesFilmsConnection {
        type Type = super::PageInfo;
    }
    pub struct edges;
    impl ::cynic::schema::Field for edges {
        type Type = Option<Vec<Option<super::SpeciesFilmsEdge>>>;
        const NAME: &'static str = "edges";
    }
    impl ::cynic::schema::HasField<edges> for super::SpeciesFilmsConnection {
        type Type = Option<Vec<Option<super::SpeciesFilmsEdge>>>;
    }
    pub struct totalCount;
    impl ::cynic::schema::Field for totalCount {
        type Type = Option<super::Int>;
        const NAME: &'static str = "totalCount";
    }
    impl ::cynic::schema::HasField<totalCount> for super::SpeciesFilmsConnection {
        type Type = Option<super::Int>;
    }
    pub struct films;
    impl ::cynic::schema::Field for films {
        type Type = Option<Vec<Option<super::Film>>>;
        const NAME: &'static str = "films";
    }
    impl ::cynic::schema::HasField<films> for super::SpeciesFilmsConnection {
        type Type = Option<Vec<Option<super::Film>>>;
    }
}
pub struct SpeciesFilmsEdge;
pub mod species_films_edge_fields {
    pub struct node;
    impl ::cynic::schema::Field for node {
        type Type = Option<super::Film>;
        const NAME: &'static str = "node";
    }
    impl ::cynic::schema::HasField<node> for super::SpeciesFilmsEdge {
        type Type = Option<super::Film>;
    }
    pub struct cursor;
    impl ::cynic::schema::Field for cursor {
        type Type = super::String;
        const NAME: &'static str = "cursor";
    }
    impl ::cynic::schema::HasField<cursor> for super::SpeciesFilmsEdge {
        type Type = super::String;
    }
}
pub struct SpeciesPeopleConnection;
pub mod species_people_connection_fields {
    pub struct pageInfo;
    impl ::cynic::schema::Field for pageInfo {
        type Type = super::PageInfo;
        const NAME: &'static str = "pageInfo";
    }
    impl ::cynic::schema::HasField<pageInfo> for super::SpeciesPeopleConnection {
        type Type = super::PageInfo;
    }
    pub struct edges;
    impl ::cynic::schema::Field for edges {
        type Type = Option<Vec<Option<super::SpeciesPeopleEdge>>>;
        const NAME: &'static str = "edges";
    }
    impl ::cynic::schema::HasField<edges> for super::SpeciesPeopleConnection {
        type Type = Option<Vec<Option<super::SpeciesPeopleEdge>>>;
    }
    pub struct totalCount;
    impl ::cynic::schema::Field for totalCount {
        type Type = Option<super::Int>;
        const NAME: &'static str = "totalCount";
    }
    impl ::cynic::schema::HasField<totalCount> for super::SpeciesPeopleConnection {
        type Type = Option<super::Int>;
    }
    pub struct people;
    impl ::cynic::schema::Field for people {
        type Type = Option<Vec<Option<super::Person>>>;
        const NAME: &'static str = "people";
    }
    impl ::cynic::schema::HasField<people> for super::SpeciesPeopleConnection {
        type Type = Option<Vec<Option<super::Person>>>;
    }
}
pub struct SpeciesPeopleEdge;
pub mod species_people_edge_fields {
    pub struct node;
    impl ::cynic::schema::Field for node {
        type Type = Option<super::Person>;
        const NAME: &'static str = "node";
    }
    impl ::cynic::schema::HasField<node> for super::SpeciesPeopleEdge {
        type Type = Option<super::Person>;
    }
    pub struct cursor;
    impl ::cynic::schema::Field for cursor {
        type Type = super::String;
        const NAME: &'static str = "cursor";
    }
    impl ::cynic::schema::HasField<cursor> for super::SpeciesPeopleEdge {
        type Type = super::String;
    }
}
pub struct Starship;
pub mod starship_fields {
    pub struct name;
    impl ::cynic::schema::Field for name {
        type Type = Option<super::String>;
        const NAME: &'static str = "name";
    }
    impl ::cynic::schema::HasField<name> for super::Starship {
        type Type = Option<super::String>;
    }
    pub struct model;
    impl ::cynic::schema::Field for model {
        type Type = Option<super::String>;
        const NAME: &'static str = "model";
    }
    impl ::cynic::schema::HasField<model> for super::Starship {
        type Type = Option<super::String>;
    }
    pub struct starshipClass;
    impl ::cynic::schema::Field for starshipClass {
        type Type = Option<super::String>;
        const NAME: &'static str = "starshipClass";
    }
    impl ::cynic::schema::HasField<starshipClass> for super::Starship {
        type Type = Option<super::String>;
    }
    pub struct manufacturers;
    impl ::cynic::schema::Field for manufacturers {
        type Type = Option<Vec<Option<super::String>>>;
        const NAME: &'static str = "manufacturers";
    }
    impl ::cynic::schema::HasField<manufacturers> for super::Starship {
        type Type = Option<Vec<Option<super::String>>>;
    }
    pub struct costInCredits;
    impl ::cynic::schema::Field for costInCredits {
        type Type = Option<super::Float>;
        const NAME: &'static str = "costInCredits";
    }
    impl ::cynic::schema::HasField<costInCredits> for super::Starship {
        type Type = Option<super::Float>;
    }
    pub struct length;
    impl ::cynic::schema::Field for length {
        type Type = Option<super::Float>;
        const NAME: &'static str = "length";
    }
    impl ::cynic::schema::HasField<length> for super::Starship {
        type Type = Option<super::Float>;
    }
    pub struct crew;
    impl ::cynic::schema::Field for crew {
        type Type = Option<super::String>;
        const NAME: &'static str = "crew";
    }
    impl ::cynic::schema::HasField<crew> for super::Starship {
        type Type = Option<super::String>;
    }
    pub struct passengers;
    impl ::cynic::schema::Field for passengers {
        type Type = Option<super::String>;
        const NAME: &'static str = "passengers";
    }
    impl ::cynic::schema::HasField<passengers> for super::Starship {
        type Type = Option<super::String>;
    }
    pub struct maxAtmospheringSpeed;
    impl ::cynic::schema::Field for maxAtmospheringSpeed {
        type Type = Option<super::Int>;
        const NAME: &'static str = "maxAtmospheringSpeed";
    }
    impl ::cynic::schema::HasField<maxAtmospheringSpeed> for super::Starship {
        type Type = Option<super::Int>;
    }
    pub struct hyperdriveRating;
    impl ::cynic::schema::Field for hyperdriveRating {
        type Type = Option<super::Float>;
        const NAME: &'static str = "hyperdriveRating";
    }
    impl ::cynic::schema::HasField<hyperdriveRating> for super::Starship {
        type Type = Option<super::Float>;
    }
    pub struct MGLT;
    impl ::cynic::schema::Field for MGLT {
        type Type = Option<super::Int>;
        const NAME: &'static str = "MGLT";
    }
    impl ::cynic::schema::HasField<MGLT> for super::Starship {
        type Type = Option<super::Int>;
    }
    pub struct cargoCapacity;
    impl ::cynic::schema::Field for cargoCapacity {
        type Type = Option<super::Float>;
        const NAME: &'static str = "cargoCapacity";
    }
    impl ::cynic::schema::HasField<cargoCapacity> for super::Starship {
        type Type = Option<super::Float>;
    }
    pub struct consumables;
    impl ::cynic::schema::Field for consumables {
        type Type = Option<super::String>;
        const NAME: &'static str = "consumables";
    }
    impl ::cynic::schema::HasField<consumables> for super::Starship {
        type Type = Option<super::String>;
    }
    pub struct pilotConnection;
    impl ::cynic::schema::Field for pilotConnection {
        type Type = Option<super::StarshipPilotsConnection>;
        const NAME: &'static str = "pilotConnection";
    }
    impl ::cynic::schema::HasField<pilotConnection> for super::Starship {
        type Type = Option<super::StarshipPilotsConnection>;
    }
    pub mod pilot_connection_arguments {
        pub struct after;
        impl ::cynic::schema::HasArgument<after> for super::pilotConnection {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "after";
        }
        pub struct first;
        impl ::cynic::schema::HasArgument<first> for super::pilotConnection {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "first";
        }
        pub struct before;
        impl ::cynic::schema::HasArgument<before> for super::pilotConnection {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "before";
        }
        pub struct last;
        impl ::cynic::schema::HasArgument<last> for super::pilotConnection {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "last";
        }
    }
    pub struct filmConnection;
    impl ::cynic::schema::Field for filmConnection {
        type Type = Option<super::StarshipFilmsConnection>;
        const NAME: &'static str = "filmConnection";
    }
    impl ::cynic::schema::HasField<filmConnection> for super::Starship {
        type Type = Option<super::StarshipFilmsConnection>;
    }
    pub mod film_connection_arguments {
        pub struct after;
        impl ::cynic::schema::HasArgument<after> for super::filmConnection {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "after";
        }
        pub struct first;
        impl ::cynic::schema::HasArgument<first> for super::filmConnection {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "first";
        }
        pub struct before;
        impl ::cynic::schema::HasArgument<before> for super::filmConnection {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "before";
        }
        pub struct last;
        impl ::cynic::schema::HasArgument<last> for super::filmConnection {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "last";
        }
    }
    pub struct created;
    impl ::cynic::schema::Field for created {
        type Type = Option<super::String>;
        const NAME: &'static str = "created";
    }
    impl ::cynic::schema::HasField<created> for super::Starship {
        type Type = Option<super::String>;
    }
    pub struct edited;
    impl ::cynic::schema::Field for edited {
        type Type = Option<super::String>;
        const NAME: &'static str = "edited";
    }
    impl ::cynic::schema::HasField<edited> for super::Starship {
        type Type = Option<super::String>;
    }
    pub struct id;
    impl ::cynic::schema::Field for id {
        type Type = super::ID;
        const NAME: &'static str = "id";
    }
    impl ::cynic::schema::HasField<id> for super::Starship {
        type Type = super::ID;
    }
}
pub struct StarshipFilmsConnection;
pub mod starship_films_connection_fields {
    pub struct pageInfo;
    impl ::cynic::schema::Field for pageInfo {
        type Type = super::PageInfo;
        const NAME: &'static str = "pageInfo";
    }
    impl ::cynic::schema::HasField<pageInfo> for super::StarshipFilmsConnection {
        type Type = super::PageInfo;
    }
    pub struct edges;
    impl ::cynic::schema::Field for edges {
        type Type = Option<Vec<Option<super::StarshipFilmsEdge>>>;
        const NAME: &'static str = "edges";
    }
    impl ::cynic::schema::HasField<edges> for super::StarshipFilmsConnection {
        type Type = Option<Vec<Option<super::StarshipFilmsEdge>>>;
    }
    pub struct totalCount;
    impl ::cynic::schema::Field for totalCount {
        type Type = Option<super::Int>;
        const NAME: &'static str = "totalCount";
    }
    impl ::cynic::schema::HasField<totalCount> for super::StarshipFilmsConnection {
        type Type = Option<super::Int>;
    }
    pub struct films;
    impl ::cynic::schema::Field for films {
        type Type = Option<Vec<Option<super::Film>>>;
        const NAME: &'static str = "films";
    }
    impl ::cynic::schema::HasField<films> for super::StarshipFilmsConnection {
        type Type = Option<Vec<Option<super::Film>>>;
    }
}
pub struct StarshipFilmsEdge;
pub mod starship_films_edge_fields {
    pub struct node;
    impl ::cynic::schema::Field for node {
        type Type = Option<super::Film>;
        const NAME: &'static str = "node";
    }
    impl ::cynic::schema::HasField<node> for super::StarshipFilmsEdge {
        type Type = Option<super::Film>;
    }
    pub struct cursor;
    impl ::cynic::schema::Field for cursor {
        type Type = super::String;
        const NAME: &'static str = "cursor";
    }
    impl ::cynic::schema::HasField<cursor> for super::StarshipFilmsEdge {
        type Type = super::String;
    }
}
pub struct StarshipPilotsConnection;
pub mod starship_pilots_connection_fields {
    pub struct pageInfo;
    impl ::cynic::schema::Field for pageInfo {
        type Type = super::PageInfo;
        const NAME: &'static str = "pageInfo";
    }
    impl ::cynic::schema::HasField<pageInfo> for super::StarshipPilotsConnection {
        type Type = super::PageInfo;
    }
    pub struct edges;
    impl ::cynic::schema::Field for edges {
        type Type = Option<Vec<Option<super::StarshipPilotsEdge>>>;
        const NAME: &'static str = "edges";
    }
    impl ::cynic::schema::HasField<edges> for super::StarshipPilotsConnection {
        type Type = Option<Vec<Option<super::StarshipPilotsEdge>>>;
    }
    pub struct totalCount;
    impl ::cynic::schema::Field for totalCount {
        type Type = Option<super::Int>;
        const NAME: &'static str = "totalCount";
    }
    impl ::cynic::schema::HasField<totalCount> for super::StarshipPilotsConnection {
        type Type = Option<super::Int>;
    }
    pub struct pilots;
    impl ::cynic::schema::Field for pilots {
        type Type = Option<Vec<Option<super::Person>>>;
        const NAME: &'static str = "pilots";
    }
    impl ::cynic::schema::HasField<pilots> for super::StarshipPilotsConnection {
        type Type = Option<Vec<Option<super::Person>>>;
    }
}
pub struct StarshipPilotsEdge;
pub mod starship_pilots_edge_fields {
    pub struct node;
    impl ::cynic::schema::Field for node {
        type Type = Option<super::Person>;
        const NAME: &'static str = "node";
    }
    impl ::cynic::schema::HasField<node> for super::StarshipPilotsEdge {
        type Type = Option<super::Person>;
    }
    pub struct cursor;
    impl ::cynic::schema::Field for cursor {
        type Type = super::String;
        const NAME: &'static str = "cursor";
    }
    impl ::cynic::schema::HasField<cursor> for super::StarshipPilotsEdge {
        type Type = super::String;
    }
}
pub struct StarshipsConnection;
pub mod starships_connection_fields {
    pub struct pageInfo;
    impl ::cynic::schema::Field for pageInfo {
        type Type = super::PageInfo;
        const NAME: &'static str = "pageInfo";
    }
    impl ::cynic::schema::HasField<pageInfo> for super::StarshipsConnection {
        type Type = super::PageInfo;
    }
    pub struct edges;
    impl ::cynic::schema::Field for edges {
        type Type = Option<Vec<Option<super::StarshipsEdge>>>;
        const NAME: &'static str = "edges";
    }
    impl ::cynic::schema::HasField<edges> for super::StarshipsConnection {
        type Type = Option<Vec<Option<super::StarshipsEdge>>>;
    }
    pub struct totalCount;
    impl ::cynic::schema::Field for totalCount {
        type Type = Option<super::Int>;
        const NAME: &'static str = "totalCount";
    }
    impl ::cynic::schema::HasField<totalCount> for super::StarshipsConnection {
        type Type = Option<super::Int>;
    }
    pub struct starships;
    impl ::cynic::schema::Field for starships {
        type Type = Option<Vec<Option<super::Starship>>>;
        const NAME: &'static str = "starships";
    }
    impl ::cynic::schema::HasField<starships> for super::StarshipsConnection {
        type Type = Option<Vec<Option<super::Starship>>>;
    }
}
pub struct StarshipsEdge;
pub mod starships_edge_fields {
    pub struct node;
    impl ::cynic::schema::Field for node {
        type Type = Option<super::Starship>;
        const NAME: &'static str = "node";
    }
    impl ::cynic::schema::HasField<node> for super::StarshipsEdge {
        type Type = Option<super::Starship>;
    }
    pub struct cursor;
    impl ::cynic::schema::Field for cursor {
        type Type = super::String;
        const NAME: &'static str = "cursor";
    }
    impl ::cynic::schema::HasField<cursor> for super::StarshipsEdge {
        type Type = super::String;
    }
}
pub struct Vehicle;
pub mod vehicle_fields {
    pub struct name;
    impl ::cynic::schema::Field for name {
        type Type = Option<super::String>;
        const NAME: &'static str = "name";
    }
    impl ::cynic::schema::HasField<name> for super::Vehicle {
        type Type = Option<super::String>;
    }
    pub struct model;
    impl ::cynic::schema::Field for model {
        type Type = Option<super::String>;
        const NAME: &'static str = "model";
    }
    impl ::cynic::schema::HasField<model> for super::Vehicle {
        type Type = Option<super::String>;
    }
    pub struct vehicleClass;
    impl ::cynic::schema::Field for vehicleClass {
        type Type = Option<super::String>;
        const NAME: &'static str = "vehicleClass";
    }
    impl ::cynic::schema::HasField<vehicleClass> for super::Vehicle {
        type Type = Option<super::String>;
    }
    pub struct manufacturers;
    impl ::cynic::schema::Field for manufacturers {
        type Type = Option<Vec<Option<super::String>>>;
        const NAME: &'static str = "manufacturers";
    }
    impl ::cynic::schema::HasField<manufacturers> for super::Vehicle {
        type Type = Option<Vec<Option<super::String>>>;
    }
    pub struct costInCredits;
    impl ::cynic::schema::Field for costInCredits {
        type Type = Option<super::Float>;
        const NAME: &'static str = "costInCredits";
    }
    impl ::cynic::schema::HasField<costInCredits> for super::Vehicle {
        type Type = Option<super::Float>;
    }
    pub struct length;
    impl ::cynic::schema::Field for length {
        type Type = Option<super::Float>;
        const NAME: &'static str = "length";
    }
    impl ::cynic::schema::HasField<length> for super::Vehicle {
        type Type = Option<super::Float>;
    }
    pub struct crew;
    impl ::cynic::schema::Field for crew {
        type Type = Option<super::String>;
        const NAME: &'static str = "crew";
    }
    impl ::cynic::schema::HasField<crew> for super::Vehicle {
        type Type = Option<super::String>;
    }
    pub struct passengers;
    impl ::cynic::schema::Field for passengers {
        type Type = Option<super::String>;
        const NAME: &'static str = "passengers";
    }
    impl ::cynic::schema::HasField<passengers> for super::Vehicle {
        type Type = Option<super::String>;
    }
    pub struct maxAtmospheringSpeed;
    impl ::cynic::schema::Field for maxAtmospheringSpeed {
        type Type = Option<super::Int>;
        const NAME: &'static str = "maxAtmospheringSpeed";
    }
    impl ::cynic::schema::HasField<maxAtmospheringSpeed> for super::Vehicle {
        type Type = Option<super::Int>;
    }
    pub struct cargoCapacity;
    impl ::cynic::schema::Field for cargoCapacity {
        type Type = Option<super::Float>;
        const NAME: &'static str = "cargoCapacity";
    }
    impl ::cynic::schema::HasField<cargoCapacity> for super::Vehicle {
        type Type = Option<super::Float>;
    }
    pub struct consumables;
    impl ::cynic::schema::Field for consumables {
        type Type = Option<super::String>;
        const NAME: &'static str = "consumables";
    }
    impl ::cynic::schema::HasField<consumables> for super::Vehicle {
        type Type = Option<super::String>;
    }
    pub struct pilotConnection;
    impl ::cynic::schema::Field for pilotConnection {
        type Type = Option<super::VehiclePilotsConnection>;
        const NAME: &'static str = "pilotConnection";
    }
    impl ::cynic::schema::HasField<pilotConnection> for super::Vehicle {
        type Type = Option<super::VehiclePilotsConnection>;
    }
    pub mod pilot_connection_arguments {
        pub struct after;
        impl ::cynic::schema::HasArgument<after> for super::pilotConnection {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "after";
        }
        pub struct first;
        impl ::cynic::schema::HasArgument<first> for super::pilotConnection {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "first";
        }
        pub struct before;
        impl ::cynic::schema::HasArgument<before> for super::pilotConnection {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "before";
        }
        pub struct last;
        impl ::cynic::schema::HasArgument<last> for super::pilotConnection {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "last";
        }
    }
    pub struct filmConnection;
    impl ::cynic::schema::Field for filmConnection {
        type Type = Option<super::VehicleFilmsConnection>;
        const NAME: &'static str = "filmConnection";
    }
    impl ::cynic::schema::HasField<filmConnection> for super::Vehicle {
        type Type = Option<super::VehicleFilmsConnection>;
    }
    pub mod film_connection_arguments {
        pub struct after;
        impl ::cynic::schema::HasArgument<after> for super::filmConnection {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "after";
        }
        pub struct first;
        impl ::cynic::schema::HasArgument<first> for super::filmConnection {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "first";
        }
        pub struct before;
        impl ::cynic::schema::HasArgument<before> for super::filmConnection {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "before";
        }
        pub struct last;
        impl ::cynic::schema::HasArgument<last> for super::filmConnection {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "last";
        }
    }
    pub struct created;
    impl ::cynic::schema::Field for created {
        type Type = Option<super::String>;
        const NAME: &'static str = "created";
    }
    impl ::cynic::schema::HasField<created> for super::Vehicle {
        type Type = Option<super::String>;
    }
    pub struct edited;
    impl ::cynic::schema::Field for edited {
        type Type = Option<super::String>;
        const NAME: &'static str = "edited";
    }
    impl ::cynic::schema::HasField<edited> for super::Vehicle {
        type Type = Option<super::String>;
    }
    pub struct id;
    impl ::cynic::schema::Field for id {
        type Type = super::ID;
        const NAME: &'static str = "id";
    }
    impl ::cynic::schema::HasField<id> for super::Vehicle {
        type Type = super::ID;
    }
}
pub struct VehicleFilmsConnection;
pub mod vehicle_films_connection_fields {
    pub struct pageInfo;
    impl ::cynic::schema::Field for pageInfo {
        type Type = super::PageInfo;
        const NAME: &'static str = "pageInfo";
    }
    impl ::cynic::schema::HasField<pageInfo> for super::VehicleFilmsConnection {
        type Type = super::PageInfo;
    }
    pub struct edges;
    impl ::cynic::schema::Field for edges {
        type Type = Option<Vec<Option<super::VehicleFilmsEdge>>>;
        const NAME: &'static str = "edges";
    }
    impl ::cynic::schema::HasField<edges> for super::VehicleFilmsConnection {
        type Type = Option<Vec<Option<super::VehicleFilmsEdge>>>;
    }
    pub struct totalCount;
    impl ::cynic::schema::Field for totalCount {
        type Type = Option<super::Int>;
        const NAME: &'static str = "totalCount";
    }
    impl ::cynic::schema::HasField<totalCount> for super::VehicleFilmsConnection {
        type Type = Option<super::Int>;
    }
    pub struct films;
    impl ::cynic::schema::Field for films {
        type Type = Option<Vec<Option<super::Film>>>;
        const NAME: &'static str = "films";
    }
    impl ::cynic::schema::HasField<films> for super::VehicleFilmsConnection {
        type Type = Option<Vec<Option<super::Film>>>;
    }
}
pub struct VehicleFilmsEdge;
pub mod vehicle_films_edge_fields {
    pub struct node;
    impl ::cynic::schema::Field for node {
        type Type = Option<super::Film>;
        const NAME: &'static str = "node";
    }
    impl ::cynic::schema::HasField<node> for super::VehicleFilmsEdge {
        type Type = Option<super::Film>;
    }
    pub struct cursor;
    impl ::cynic::schema::Field for cursor {
        type Type = super::String;
        const NAME: &'static str = "cursor";
    }
    impl ::cynic::schema::HasField<cursor> for super::VehicleFilmsEdge {
        type Type = super::String;
    }
}
pub struct VehiclePilotsConnection;
pub mod vehicle_pilots_connection_fields {
    pub struct pageInfo;
    impl ::cynic::schema::Field for pageInfo {
        type Type = super::PageInfo;
        const NAME: &'static str = "pageInfo";
    }
    impl ::cynic::schema::HasField<pageInfo> for super::VehiclePilotsConnection {
        type Type = super::PageInfo;
    }
    pub struct edges;
    impl ::cynic::schema::Field for edges {
        type Type = Option<Vec<Option<super::VehiclePilotsEdge>>>;
        const NAME: &'static str = "edges";
    }
    impl ::cynic::schema::HasField<edges> for super::VehiclePilotsConnection {
        type Type = Option<Vec<Option<super::VehiclePilotsEdge>>>;
    }
    pub struct totalCount;
    impl ::cynic::schema::Field for totalCount {
        type Type = Option<super::Int>;
        const NAME: &'static str = "totalCount";
    }
    impl ::cynic::schema::HasField<totalCount> for super::VehiclePilotsConnection {
        type Type = Option<super::Int>;
    }
    pub struct pilots;
    impl ::cynic::schema::Field for pilots {
        type Type = Option<Vec<Option<super::Person>>>;
        const NAME: &'static str = "pilots";
    }
    impl ::cynic::schema::HasField<pilots> for super::VehiclePilotsConnection {
        type Type = Option<Vec<Option<super::Person>>>;
    }
}
pub struct VehiclePilotsEdge;
pub mod vehicle_pilots_edge_fields {
    pub struct node;
    impl ::cynic::schema::Field for node {
        type Type = Option<super::Person>;
        const NAME: &'static str = "node";
    }
    impl ::cynic::schema::HasField<node> for super::VehiclePilotsEdge {
        type Type = Option<super::Person>;
    }
    pub struct cursor;
    impl ::cynic::schema::Field for cursor {
        type Type = super::String;
        const NAME: &'static str = "cursor";
    }
    impl ::cynic::schema::HasField<cursor> for super::VehiclePilotsEdge {
        type Type = super::String;
    }
}
pub struct VehiclesConnection;
pub mod vehicles_connection_fields {
    pub struct pageInfo;
    impl ::cynic::schema::Field for pageInfo {
        type Type = super::PageInfo;
        const NAME: &'static str = "pageInfo";
    }
    impl ::cynic::schema::HasField<pageInfo> for super::VehiclesConnection {
        type Type = super::PageInfo;
    }
    pub struct edges;
    impl ::cynic::schema::Field for edges {
        type Type = Option<Vec<Option<super::VehiclesEdge>>>;
        const NAME: &'static str = "edges";
    }
    impl ::cynic::schema::HasField<edges> for super::VehiclesConnection {
        type Type = Option<Vec<Option<super::VehiclesEdge>>>;
    }
    pub struct totalCount;
    impl ::cynic::schema::Field for totalCount {
        type Type = Option<super::Int>;
        const NAME: &'static str = "totalCount";
    }
    impl ::cynic::schema::HasField<totalCount> for super::VehiclesConnection {
        type Type = Option<super::Int>;
    }
    pub struct vehicles;
    impl ::cynic::schema::Field for vehicles {
        type Type = Option<Vec<Option<super::Vehicle>>>;
        const NAME: &'static str = "vehicles";
    }
    impl ::cynic::schema::HasField<vehicles> for super::VehiclesConnection {
        type Type = Option<Vec<Option<super::Vehicle>>>;
    }
}
pub struct VehiclesEdge;
pub mod vehicles_edge_fields {
    pub struct node;
    impl ::cynic::schema::Field for node {
        type Type = Option<super::Vehicle>;
        const NAME: &'static str = "node";
    }
    impl ::cynic::schema::HasField<node> for super::VehiclesEdge {
        type Type = Option<super::Vehicle>;
    }
    pub struct cursor;
    impl ::cynic::schema::Field for cursor {
        type Type = super::String;
        const NAME: &'static str = "cursor";
    }
    impl ::cynic::schema::HasField<cursor> for super::VehiclesEdge {
        type Type = super::String;
    }
}
impl ::cynic::schema::HasSubtype<Film> for Node {}
impl ::cynic::schema::HasSubtype<Node> for Node {}
impl ::cynic::schema::HasSubtype<Person> for Node {}
impl ::cynic::schema::HasSubtype<Planet> for Node {}
impl ::cynic::schema::HasSubtype<Species> for Node {}
impl ::cynic::schema::HasSubtype<Starship> for Node {}
impl ::cynic::schema::HasSubtype<Vehicle> for Node {}
impl ::cynic::schema::NamedType for Film {
    const NAME: &'static str = "Film";
}
impl ::cynic::schema::NamedType for FilmCharactersConnection {
    const NAME: &'static str = "FilmCharactersConnection";
}
impl ::cynic::schema::NamedType for FilmCharactersEdge {
    const NAME: &'static str = "FilmCharactersEdge";
}
impl ::cynic::schema::NamedType for FilmPlanetsConnection {
    const NAME: &'static str = "FilmPlanetsConnection";
}
impl ::cynic::schema::NamedType for FilmPlanetsEdge {
    const NAME: &'static str = "FilmPlanetsEdge";
}
impl ::cynic::schema::NamedType for FilmSpeciesConnection {
    const NAME: &'static str = "FilmSpeciesConnection";
}
impl ::cynic::schema::NamedType for FilmSpeciesEdge {
    const NAME: &'static str = "FilmSpeciesEdge";
}
impl ::cynic::schema::NamedType for FilmStarshipsConnection {
    const NAME: &'static str = "FilmStarshipsConnection";
}
impl ::cynic::schema::NamedType for FilmStarshipsEdge {
    const NAME: &'static str = "FilmStarshipsEdge";
}
impl ::cynic::schema::NamedType for FilmVehiclesConnection {
    const NAME: &'static str = "FilmVehiclesConnection";
}
impl ::cynic::schema::NamedType for FilmVehiclesEdge {
    const NAME: &'static str = "FilmVehiclesEdge";
}
impl ::cynic::schema::NamedType for FilmsConnection {
    const NAME: &'static str = "FilmsConnection";
}
impl ::cynic::schema::NamedType for FilmsEdge {
    const NAME: &'static str = "FilmsEdge";
}
impl ::cynic::schema::NamedType for Node {
    const NAME: &'static str = "Node";
}
impl ::cynic::schema::NamedType for PageInfo {
    const NAME: &'static str = "PageInfo";
}
impl ::cynic::schema::NamedType for PeopleConnection {
    const NAME: &'static str = "PeopleConnection";
}
impl ::cynic::schema::NamedType for PeopleEdge {
    const NAME: &'static str = "PeopleEdge";
}
impl ::cynic::schema::NamedType for Person {
    const NAME: &'static str = "Person";
}
impl ::cynic::schema::NamedType for PersonFilmsConnection {
    const NAME: &'static str = "PersonFilmsConnection";
}
impl ::cynic::schema::NamedType for PersonFilmsEdge {
    const NAME: &'static str = "PersonFilmsEdge";
}
impl ::cynic::schema::NamedType for PersonStarshipsConnection {
    const NAME: &'static str = "PersonStarshipsConnection";
}
impl ::cynic::schema::NamedType for PersonStarshipsEdge {
    const NAME: &'static str = "PersonStarshipsEdge";
}
impl ::cynic::schema::NamedType for PersonVehiclesConnection {
    const NAME: &'static str = "PersonVehiclesConnection";
}
impl ::cynic::schema::NamedType for PersonVehiclesEdge {
    const NAME: &'static str = "PersonVehiclesEdge";
}
impl ::cynic::schema::NamedType for Planet {
    const NAME: &'static str = "Planet";
}
impl ::cynic::schema::NamedType for PlanetFilmsConnection {
    const NAME: &'static str = "PlanetFilmsConnection";
}
impl ::cynic::schema::NamedType for PlanetFilmsEdge {
    const NAME: &'static str = "PlanetFilmsEdge";
}
impl ::cynic::schema::NamedType for PlanetResidentsConnection {
    const NAME: &'static str = "PlanetResidentsConnection";
}
impl ::cynic::schema::NamedType for PlanetResidentsEdge {
    const NAME: &'static str = "PlanetResidentsEdge";
}
impl ::cynic::schema::NamedType for PlanetsConnection {
    const NAME: &'static str = "PlanetsConnection";
}
impl ::cynic::schema::NamedType for PlanetsEdge {
    const NAME: &'static str = "PlanetsEdge";
}
impl ::cynic::schema::NamedType for Root {
    const NAME: &'static str = "Root";
}
impl ::cynic::schema::NamedType for Species {
    const NAME: &'static str = "Species";
}
impl ::cynic::schema::NamedType for SpeciesConnection {
    const NAME: &'static str = "SpeciesConnection";
}
impl ::cynic::schema::NamedType for SpeciesEdge {
    const NAME: &'static str = "SpeciesEdge";
}
impl ::cynic::schema::NamedType for SpeciesFilmsConnection {
    const NAME: &'static str = "SpeciesFilmsConnection";
}
impl ::cynic::schema::NamedType for SpeciesFilmsEdge {
    const NAME: &'static str = "SpeciesFilmsEdge";
}
impl ::cynic::schema::NamedType for SpeciesPeopleConnection {
    const NAME: &'static str = "SpeciesPeopleConnection";
}
impl ::cynic::schema::NamedType for SpeciesPeopleEdge {
    const NAME: &'static str = "SpeciesPeopleEdge";
}
impl ::cynic::schema::NamedType for Starship {
    const NAME: &'static str = "Starship";
}
impl ::cynic::schema::NamedType for StarshipFilmsConnection {
    const NAME: &'static str = "StarshipFilmsConnection";
}
impl ::cynic::schema::NamedType for StarshipFilmsEdge {
    const NAME: &'static str = "StarshipFilmsEdge";
}
impl ::cynic::schema::NamedType for StarshipPilotsConnection {
    const NAME: &'static str = "StarshipPilotsConnection";
}
impl ::cynic::schema::NamedType for StarshipPilotsEdge {
    const NAME: &'static str = "StarshipPilotsEdge";
}
impl ::cynic::schema::NamedType for StarshipsConnection {
    const NAME: &'static str = "StarshipsConnection";
}
impl ::cynic::schema::NamedType for StarshipsEdge {
    const NAME: &'static str = "StarshipsEdge";
}
impl ::cynic::schema::NamedType for Vehicle {
    const NAME: &'static str = "Vehicle";
}
impl ::cynic::schema::NamedType for VehicleFilmsConnection {
    const NAME: &'static str = "VehicleFilmsConnection";
}
impl ::cynic::schema::NamedType for VehicleFilmsEdge {
    const NAME: &'static str = "VehicleFilmsEdge";
}
impl ::cynic::schema::NamedType for VehiclePilotsConnection {
    const NAME: &'static str = "VehiclePilotsConnection";
}
impl ::cynic::schema::NamedType for VehiclePilotsEdge {
    const NAME: &'static str = "VehiclePilotsEdge";
}
impl ::cynic::schema::NamedType for VehiclesConnection {
    const NAME: &'static str = "VehiclesConnection";
}
impl ::cynic::schema::NamedType for VehiclesEdge {
    const NAME: &'static str = "VehiclesEdge";
}
pub type Boolean = bool;
pub type String = std::string::String;
pub type Float = f64;
pub type Int = i32;
pub type ID = ::cynic::Id;
pub mod variable {
    use cynic::variables::VariableType;
    #[doc = r" Used to determine the type of a given variable that"]
    #[doc = r" appears in an argument struct."]
    pub trait Variable {
        const TYPE: VariableType;
    }
    impl<T> Variable for &T
    where
        T: Variable,
    {
        const TYPE: VariableType = T::TYPE;
    }
    impl<T> Variable for Option<T>
    where
        T: Variable,
    {
        const TYPE: VariableType = VariableType::Nullable(&T::TYPE);
    }
    impl<T> Variable for Vec<T>
    where
        T: Variable,
    {
        const TYPE: VariableType = VariableType::List(&T::TYPE);
    }
    impl<T> Variable for Box<T>
    where
        T: Variable,
    {
        const TYPE: VariableType = T::TYPE;
    }
    impl<T> Variable for std::rc::Rc<T>
    where
        T: Variable,
    {
        const TYPE: VariableType = T::TYPE;
    }
    impl<T> Variable for std::sync::Arc<T>
    where
        T: Variable,
    {
        const TYPE: VariableType = T::TYPE;
    }
    impl Variable for bool {
        const TYPE: VariableType = VariableType::Named("Boolean");
    }
    impl Variable for String {
        const TYPE: VariableType = VariableType::Named("String");
    }
    impl Variable for f64 {
        const TYPE: VariableType = VariableType::Named("Float");
    }
    impl Variable for i32 {
        const TYPE: VariableType = VariableType::Named("Int");
    }
    impl Variable for ::cynic::Id {
        const TYPE: VariableType = VariableType::Named("ID");
    }
}

