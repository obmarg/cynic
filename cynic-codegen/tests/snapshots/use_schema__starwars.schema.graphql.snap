---
source: cynic-codegen/tests/use-schema.rs
expression: "format_code(format!(\"{}\", tokens))"
---
impl cynic::schema::QueryRoot for Root {}
pub struct Film;
pub struct FilmCharactersConnection;
pub struct FilmCharactersEdge;
pub struct FilmPlanetsConnection;
pub struct FilmPlanetsEdge;
pub struct FilmSpeciesConnection;
pub struct FilmSpeciesEdge;
pub struct FilmStarshipsConnection;
pub struct FilmStarshipsEdge;
pub struct FilmVehiclesConnection;
pub struct FilmVehiclesEdge;
pub struct FilmsConnection;
pub struct FilmsEdge;
pub struct Node;
pub struct PageInfo;
pub struct PeopleConnection;
pub struct PeopleEdge;
pub struct Person;
pub struct PersonFilmsConnection;
pub struct PersonFilmsEdge;
pub struct PersonStarshipsConnection;
pub struct PersonStarshipsEdge;
pub struct PersonVehiclesConnection;
pub struct PersonVehiclesEdge;
pub struct Planet;
pub struct PlanetFilmsConnection;
pub struct PlanetFilmsEdge;
pub struct PlanetResidentsConnection;
pub struct PlanetResidentsEdge;
pub struct PlanetsConnection;
pub struct PlanetsEdge;
pub struct Root;
pub struct Species;
pub struct SpeciesConnection;
pub struct SpeciesEdge;
pub struct SpeciesFilmsConnection;
pub struct SpeciesFilmsEdge;
pub struct SpeciesPeopleConnection;
pub struct SpeciesPeopleEdge;
pub struct Starship;
pub struct StarshipFilmsConnection;
pub struct StarshipFilmsEdge;
pub struct StarshipPilotsConnection;
pub struct StarshipPilotsEdge;
pub struct StarshipsConnection;
pub struct StarshipsEdge;
pub struct Vehicle;
pub struct VehicleFilmsConnection;
pub struct VehicleFilmsEdge;
pub struct VehiclePilotsConnection;
pub struct VehiclePilotsEdge;
pub struct VehiclesConnection;
pub struct VehiclesEdge;
impl cynic::schema::HasSubtype<Film> for Node {}
impl cynic::schema::HasSubtype<Node> for Node {}
impl cynic::schema::HasSubtype<Person> for Node {}
impl cynic::schema::HasSubtype<Planet> for Node {}
impl cynic::schema::HasSubtype<Species> for Node {}
impl cynic::schema::HasSubtype<Starship> for Node {}
impl cynic::schema::HasSubtype<Vehicle> for Node {}
impl cynic::schema::NamedType for Film {
    const NAME: &'static str = "Film";
}
impl cynic::schema::NamedType for FilmCharactersConnection {
    const NAME: &'static str = "FilmCharactersConnection";
}
impl cynic::schema::NamedType for FilmCharactersEdge {
    const NAME: &'static str = "FilmCharactersEdge";
}
impl cynic::schema::NamedType for FilmPlanetsConnection {
    const NAME: &'static str = "FilmPlanetsConnection";
}
impl cynic::schema::NamedType for FilmPlanetsEdge {
    const NAME: &'static str = "FilmPlanetsEdge";
}
impl cynic::schema::NamedType for FilmSpeciesConnection {
    const NAME: &'static str = "FilmSpeciesConnection";
}
impl cynic::schema::NamedType for FilmSpeciesEdge {
    const NAME: &'static str = "FilmSpeciesEdge";
}
impl cynic::schema::NamedType for FilmStarshipsConnection {
    const NAME: &'static str = "FilmStarshipsConnection";
}
impl cynic::schema::NamedType for FilmStarshipsEdge {
    const NAME: &'static str = "FilmStarshipsEdge";
}
impl cynic::schema::NamedType for FilmVehiclesConnection {
    const NAME: &'static str = "FilmVehiclesConnection";
}
impl cynic::schema::NamedType for FilmVehiclesEdge {
    const NAME: &'static str = "FilmVehiclesEdge";
}
impl cynic::schema::NamedType for FilmsConnection {
    const NAME: &'static str = "FilmsConnection";
}
impl cynic::schema::NamedType for FilmsEdge {
    const NAME: &'static str = "FilmsEdge";
}
impl cynic::schema::NamedType for Node {
    const NAME: &'static str = "Node";
}
impl cynic::schema::NamedType for PageInfo {
    const NAME: &'static str = "PageInfo";
}
impl cynic::schema::NamedType for PeopleConnection {
    const NAME: &'static str = "PeopleConnection";
}
impl cynic::schema::NamedType for PeopleEdge {
    const NAME: &'static str = "PeopleEdge";
}
impl cynic::schema::NamedType for Person {
    const NAME: &'static str = "Person";
}
impl cynic::schema::NamedType for PersonFilmsConnection {
    const NAME: &'static str = "PersonFilmsConnection";
}
impl cynic::schema::NamedType for PersonFilmsEdge {
    const NAME: &'static str = "PersonFilmsEdge";
}
impl cynic::schema::NamedType for PersonStarshipsConnection {
    const NAME: &'static str = "PersonStarshipsConnection";
}
impl cynic::schema::NamedType for PersonStarshipsEdge {
    const NAME: &'static str = "PersonStarshipsEdge";
}
impl cynic::schema::NamedType for PersonVehiclesConnection {
    const NAME: &'static str = "PersonVehiclesConnection";
}
impl cynic::schema::NamedType for PersonVehiclesEdge {
    const NAME: &'static str = "PersonVehiclesEdge";
}
impl cynic::schema::NamedType for Planet {
    const NAME: &'static str = "Planet";
}
impl cynic::schema::NamedType for PlanetFilmsConnection {
    const NAME: &'static str = "PlanetFilmsConnection";
}
impl cynic::schema::NamedType for PlanetFilmsEdge {
    const NAME: &'static str = "PlanetFilmsEdge";
}
impl cynic::schema::NamedType for PlanetResidentsConnection {
    const NAME: &'static str = "PlanetResidentsConnection";
}
impl cynic::schema::NamedType for PlanetResidentsEdge {
    const NAME: &'static str = "PlanetResidentsEdge";
}
impl cynic::schema::NamedType for PlanetsConnection {
    const NAME: &'static str = "PlanetsConnection";
}
impl cynic::schema::NamedType for PlanetsEdge {
    const NAME: &'static str = "PlanetsEdge";
}
impl cynic::schema::NamedType for Root {
    const NAME: &'static str = "Root";
}
impl cynic::schema::NamedType for Species {
    const NAME: &'static str = "Species";
}
impl cynic::schema::NamedType for SpeciesConnection {
    const NAME: &'static str = "SpeciesConnection";
}
impl cynic::schema::NamedType for SpeciesEdge {
    const NAME: &'static str = "SpeciesEdge";
}
impl cynic::schema::NamedType for SpeciesFilmsConnection {
    const NAME: &'static str = "SpeciesFilmsConnection";
}
impl cynic::schema::NamedType for SpeciesFilmsEdge {
    const NAME: &'static str = "SpeciesFilmsEdge";
}
impl cynic::schema::NamedType for SpeciesPeopleConnection {
    const NAME: &'static str = "SpeciesPeopleConnection";
}
impl cynic::schema::NamedType for SpeciesPeopleEdge {
    const NAME: &'static str = "SpeciesPeopleEdge";
}
impl cynic::schema::NamedType for Starship {
    const NAME: &'static str = "Starship";
}
impl cynic::schema::NamedType for StarshipFilmsConnection {
    const NAME: &'static str = "StarshipFilmsConnection";
}
impl cynic::schema::NamedType for StarshipFilmsEdge {
    const NAME: &'static str = "StarshipFilmsEdge";
}
impl cynic::schema::NamedType for StarshipPilotsConnection {
    const NAME: &'static str = "StarshipPilotsConnection";
}
impl cynic::schema::NamedType for StarshipPilotsEdge {
    const NAME: &'static str = "StarshipPilotsEdge";
}
impl cynic::schema::NamedType for StarshipsConnection {
    const NAME: &'static str = "StarshipsConnection";
}
impl cynic::schema::NamedType for StarshipsEdge {
    const NAME: &'static str = "StarshipsEdge";
}
impl cynic::schema::NamedType for Vehicle {
    const NAME: &'static str = "Vehicle";
}
impl cynic::schema::NamedType for VehicleFilmsConnection {
    const NAME: &'static str = "VehicleFilmsConnection";
}
impl cynic::schema::NamedType for VehicleFilmsEdge {
    const NAME: &'static str = "VehicleFilmsEdge";
}
impl cynic::schema::NamedType for VehiclePilotsConnection {
    const NAME: &'static str = "VehiclePilotsConnection";
}
impl cynic::schema::NamedType for VehiclePilotsEdge {
    const NAME: &'static str = "VehiclePilotsEdge";
}
impl cynic::schema::NamedType for VehiclesConnection {
    const NAME: &'static str = "VehiclesConnection";
}
impl cynic::schema::NamedType for VehiclesEdge {
    const NAME: &'static str = "VehiclesEdge";
}
#[allow(non_snake_case, non_camel_case_types)]
pub mod __fields {
    pub mod Film {
        pub struct title;
        impl cynic::schema::HasField<title> for super::super::Film {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "title";
        }
        pub struct episodeID;
        impl cynic::schema::HasField<episodeID> for super::super::Film {
            type Type = Option<super::super::Int>;
            const NAME: &'static str = "episodeID";
        }
        pub struct openingCrawl;
        impl cynic::schema::HasField<openingCrawl> for super::super::Film {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "openingCrawl";
        }
        pub struct director;
        impl cynic::schema::HasField<director> for super::super::Film {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "director";
        }
        pub struct producers;
        impl cynic::schema::HasField<producers> for super::super::Film {
            type Type = Option<Vec<Option<super::super::String>>>;
            const NAME: &'static str = "producers";
        }
        pub struct releaseDate;
        impl cynic::schema::HasField<releaseDate> for super::super::Film {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "releaseDate";
        }
        pub struct speciesConnection;
        impl cynic::schema::HasField<speciesConnection> for super::super::Film {
            type Type = Option<super::super::FilmSpeciesConnection>;
            const NAME: &'static str = "speciesConnection";
        }
        pub mod _species_connection_arguments {
            pub struct after;
            impl cynic::schema::HasArgument<after> for super::speciesConnection {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "after";
            }
            pub struct first;
            impl cynic::schema::HasArgument<first> for super::speciesConnection {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "first";
            }
            pub struct before;
            impl cynic::schema::HasArgument<before> for super::speciesConnection {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "before";
            }
            pub struct last;
            impl cynic::schema::HasArgument<last> for super::speciesConnection {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "last";
            }
        }
        pub struct starshipConnection;
        impl cynic::schema::HasField<starshipConnection> for super::super::Film {
            type Type = Option<super::super::FilmStarshipsConnection>;
            const NAME: &'static str = "starshipConnection";
        }
        pub mod _starship_connection_arguments {
            pub struct after;
            impl cynic::schema::HasArgument<after> for super::starshipConnection {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "after";
            }
            pub struct first;
            impl cynic::schema::HasArgument<first> for super::starshipConnection {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "first";
            }
            pub struct before;
            impl cynic::schema::HasArgument<before> for super::starshipConnection {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "before";
            }
            pub struct last;
            impl cynic::schema::HasArgument<last> for super::starshipConnection {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "last";
            }
        }
        pub struct vehicleConnection;
        impl cynic::schema::HasField<vehicleConnection> for super::super::Film {
            type Type = Option<super::super::FilmVehiclesConnection>;
            const NAME: &'static str = "vehicleConnection";
        }
        pub mod _vehicle_connection_arguments {
            pub struct after;
            impl cynic::schema::HasArgument<after> for super::vehicleConnection {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "after";
            }
            pub struct first;
            impl cynic::schema::HasArgument<first> for super::vehicleConnection {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "first";
            }
            pub struct before;
            impl cynic::schema::HasArgument<before> for super::vehicleConnection {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "before";
            }
            pub struct last;
            impl cynic::schema::HasArgument<last> for super::vehicleConnection {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "last";
            }
        }
        pub struct characterConnection;
        impl cynic::schema::HasField<characterConnection> for super::super::Film {
            type Type = Option<super::super::FilmCharactersConnection>;
            const NAME: &'static str = "characterConnection";
        }
        pub mod _character_connection_arguments {
            pub struct after;
            impl cynic::schema::HasArgument<after> for super::characterConnection {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "after";
            }
            pub struct first;
            impl cynic::schema::HasArgument<first> for super::characterConnection {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "first";
            }
            pub struct before;
            impl cynic::schema::HasArgument<before> for super::characterConnection {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "before";
            }
            pub struct last;
            impl cynic::schema::HasArgument<last> for super::characterConnection {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "last";
            }
        }
        pub struct planetConnection;
        impl cynic::schema::HasField<planetConnection> for super::super::Film {
            type Type = Option<super::super::FilmPlanetsConnection>;
            const NAME: &'static str = "planetConnection";
        }
        pub mod _planet_connection_arguments {
            pub struct after;
            impl cynic::schema::HasArgument<after> for super::planetConnection {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "after";
            }
            pub struct first;
            impl cynic::schema::HasArgument<first> for super::planetConnection {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "first";
            }
            pub struct before;
            impl cynic::schema::HasArgument<before> for super::planetConnection {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "before";
            }
            pub struct last;
            impl cynic::schema::HasArgument<last> for super::planetConnection {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "last";
            }
        }
        pub struct created;
        impl cynic::schema::HasField<created> for super::super::Film {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "created";
        }
        pub struct edited;
        impl cynic::schema::HasField<edited> for super::super::Film {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "edited";
        }
        pub struct id;
        impl cynic::schema::HasField<id> for super::super::Film {
            type Type = super::super::ID;
            const NAME: &'static str = "id";
        }
        pub struct __typename;
        impl cynic::schema::HasField<__typename> for super::super::Film {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
    }
    pub mod FilmCharactersConnection {
        pub struct pageInfo;
        impl cynic::schema::HasField<pageInfo> for super::super::FilmCharactersConnection {
            type Type = super::super::PageInfo;
            const NAME: &'static str = "pageInfo";
        }
        pub struct edges;
        impl cynic::schema::HasField<edges> for super::super::FilmCharactersConnection {
            type Type = Option<Vec<Option<super::super::FilmCharactersEdge>>>;
            const NAME: &'static str = "edges";
        }
        pub struct totalCount;
        impl cynic::schema::HasField<totalCount> for super::super::FilmCharactersConnection {
            type Type = Option<super::super::Int>;
            const NAME: &'static str = "totalCount";
        }
        pub struct characters;
        impl cynic::schema::HasField<characters> for super::super::FilmCharactersConnection {
            type Type = Option<Vec<Option<super::super::Person>>>;
            const NAME: &'static str = "characters";
        }
        pub struct __typename;
        impl cynic::schema::HasField<__typename> for super::super::FilmCharactersConnection {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
    }
    pub mod FilmCharactersEdge {
        pub struct node;
        impl cynic::schema::HasField<node> for super::super::FilmCharactersEdge {
            type Type = Option<super::super::Person>;
            const NAME: &'static str = "node";
        }
        pub struct cursor;
        impl cynic::schema::HasField<cursor> for super::super::FilmCharactersEdge {
            type Type = super::super::String;
            const NAME: &'static str = "cursor";
        }
        pub struct __typename;
        impl cynic::schema::HasField<__typename> for super::super::FilmCharactersEdge {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
    }
    pub mod FilmPlanetsConnection {
        pub struct pageInfo;
        impl cynic::schema::HasField<pageInfo> for super::super::FilmPlanetsConnection {
            type Type = super::super::PageInfo;
            const NAME: &'static str = "pageInfo";
        }
        pub struct edges;
        impl cynic::schema::HasField<edges> for super::super::FilmPlanetsConnection {
            type Type = Option<Vec<Option<super::super::FilmPlanetsEdge>>>;
            const NAME: &'static str = "edges";
        }
        pub struct totalCount;
        impl cynic::schema::HasField<totalCount> for super::super::FilmPlanetsConnection {
            type Type = Option<super::super::Int>;
            const NAME: &'static str = "totalCount";
        }
        pub struct planets;
        impl cynic::schema::HasField<planets> for super::super::FilmPlanetsConnection {
            type Type = Option<Vec<Option<super::super::Planet>>>;
            const NAME: &'static str = "planets";
        }
        pub struct __typename;
        impl cynic::schema::HasField<__typename> for super::super::FilmPlanetsConnection {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
    }
    pub mod FilmPlanetsEdge {
        pub struct node;
        impl cynic::schema::HasField<node> for super::super::FilmPlanetsEdge {
            type Type = Option<super::super::Planet>;
            const NAME: &'static str = "node";
        }
        pub struct cursor;
        impl cynic::schema::HasField<cursor> for super::super::FilmPlanetsEdge {
            type Type = super::super::String;
            const NAME: &'static str = "cursor";
        }
        pub struct __typename;
        impl cynic::schema::HasField<__typename> for super::super::FilmPlanetsEdge {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
    }
    pub mod FilmSpeciesConnection {
        pub struct pageInfo;
        impl cynic::schema::HasField<pageInfo> for super::super::FilmSpeciesConnection {
            type Type = super::super::PageInfo;
            const NAME: &'static str = "pageInfo";
        }
        pub struct edges;
        impl cynic::schema::HasField<edges> for super::super::FilmSpeciesConnection {
            type Type = Option<Vec<Option<super::super::FilmSpeciesEdge>>>;
            const NAME: &'static str = "edges";
        }
        pub struct totalCount;
        impl cynic::schema::HasField<totalCount> for super::super::FilmSpeciesConnection {
            type Type = Option<super::super::Int>;
            const NAME: &'static str = "totalCount";
        }
        pub struct species;
        impl cynic::schema::HasField<species> for super::super::FilmSpeciesConnection {
            type Type = Option<Vec<Option<super::super::Species>>>;
            const NAME: &'static str = "species";
        }
        pub struct __typename;
        impl cynic::schema::HasField<__typename> for super::super::FilmSpeciesConnection {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
    }
    pub mod FilmSpeciesEdge {
        pub struct node;
        impl cynic::schema::HasField<node> for super::super::FilmSpeciesEdge {
            type Type = Option<super::super::Species>;
            const NAME: &'static str = "node";
        }
        pub struct cursor;
        impl cynic::schema::HasField<cursor> for super::super::FilmSpeciesEdge {
            type Type = super::super::String;
            const NAME: &'static str = "cursor";
        }
        pub struct __typename;
        impl cynic::schema::HasField<__typename> for super::super::FilmSpeciesEdge {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
    }
    pub mod FilmStarshipsConnection {
        pub struct pageInfo;
        impl cynic::schema::HasField<pageInfo> for super::super::FilmStarshipsConnection {
            type Type = super::super::PageInfo;
            const NAME: &'static str = "pageInfo";
        }
        pub struct edges;
        impl cynic::schema::HasField<edges> for super::super::FilmStarshipsConnection {
            type Type = Option<Vec<Option<super::super::FilmStarshipsEdge>>>;
            const NAME: &'static str = "edges";
        }
        pub struct totalCount;
        impl cynic::schema::HasField<totalCount> for super::super::FilmStarshipsConnection {
            type Type = Option<super::super::Int>;
            const NAME: &'static str = "totalCount";
        }
        pub struct starships;
        impl cynic::schema::HasField<starships> for super::super::FilmStarshipsConnection {
            type Type = Option<Vec<Option<super::super::Starship>>>;
            const NAME: &'static str = "starships";
        }
        pub struct __typename;
        impl cynic::schema::HasField<__typename> for super::super::FilmStarshipsConnection {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
    }
    pub mod FilmStarshipsEdge {
        pub struct node;
        impl cynic::schema::HasField<node> for super::super::FilmStarshipsEdge {
            type Type = Option<super::super::Starship>;
            const NAME: &'static str = "node";
        }
        pub struct cursor;
        impl cynic::schema::HasField<cursor> for super::super::FilmStarshipsEdge {
            type Type = super::super::String;
            const NAME: &'static str = "cursor";
        }
        pub struct __typename;
        impl cynic::schema::HasField<__typename> for super::super::FilmStarshipsEdge {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
    }
    pub mod FilmVehiclesConnection {
        pub struct pageInfo;
        impl cynic::schema::HasField<pageInfo> for super::super::FilmVehiclesConnection {
            type Type = super::super::PageInfo;
            const NAME: &'static str = "pageInfo";
        }
        pub struct edges;
        impl cynic::schema::HasField<edges> for super::super::FilmVehiclesConnection {
            type Type = Option<Vec<Option<super::super::FilmVehiclesEdge>>>;
            const NAME: &'static str = "edges";
        }
        pub struct totalCount;
        impl cynic::schema::HasField<totalCount> for super::super::FilmVehiclesConnection {
            type Type = Option<super::super::Int>;
            const NAME: &'static str = "totalCount";
        }
        pub struct vehicles;
        impl cynic::schema::HasField<vehicles> for super::super::FilmVehiclesConnection {
            type Type = Option<Vec<Option<super::super::Vehicle>>>;
            const NAME: &'static str = "vehicles";
        }
        pub struct __typename;
        impl cynic::schema::HasField<__typename> for super::super::FilmVehiclesConnection {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
    }
    pub mod FilmVehiclesEdge {
        pub struct node;
        impl cynic::schema::HasField<node> for super::super::FilmVehiclesEdge {
            type Type = Option<super::super::Vehicle>;
            const NAME: &'static str = "node";
        }
        pub struct cursor;
        impl cynic::schema::HasField<cursor> for super::super::FilmVehiclesEdge {
            type Type = super::super::String;
            const NAME: &'static str = "cursor";
        }
        pub struct __typename;
        impl cynic::schema::HasField<__typename> for super::super::FilmVehiclesEdge {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
    }
    pub mod FilmsConnection {
        pub struct pageInfo;
        impl cynic::schema::HasField<pageInfo> for super::super::FilmsConnection {
            type Type = super::super::PageInfo;
            const NAME: &'static str = "pageInfo";
        }
        pub struct edges;
        impl cynic::schema::HasField<edges> for super::super::FilmsConnection {
            type Type = Option<Vec<Option<super::super::FilmsEdge>>>;
            const NAME: &'static str = "edges";
        }
        pub struct totalCount;
        impl cynic::schema::HasField<totalCount> for super::super::FilmsConnection {
            type Type = Option<super::super::Int>;
            const NAME: &'static str = "totalCount";
        }
        pub struct films;
        impl cynic::schema::HasField<films> for super::super::FilmsConnection {
            type Type = Option<Vec<Option<super::super::Film>>>;
            const NAME: &'static str = "films";
        }
        pub struct __typename;
        impl cynic::schema::HasField<__typename> for super::super::FilmsConnection {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
    }
    pub mod FilmsEdge {
        pub struct node;
        impl cynic::schema::HasField<node> for super::super::FilmsEdge {
            type Type = Option<super::super::Film>;
            const NAME: &'static str = "node";
        }
        pub struct cursor;
        impl cynic::schema::HasField<cursor> for super::super::FilmsEdge {
            type Type = super::super::String;
            const NAME: &'static str = "cursor";
        }
        pub struct __typename;
        impl cynic::schema::HasField<__typename> for super::super::FilmsEdge {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
    }
    pub mod Node {
        pub struct id;
        impl cynic::schema::HasField<id> for super::super::Node {
            type Type = super::super::ID;
            const NAME: &'static str = "id";
        }
        pub struct __typename;
        impl cynic::schema::HasField<__typename> for super::super::Node {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
    }
    pub mod PageInfo {
        pub struct hasNextPage;
        impl cynic::schema::HasField<hasNextPage> for super::super::PageInfo {
            type Type = super::super::Boolean;
            const NAME: &'static str = "hasNextPage";
        }
        pub struct hasPreviousPage;
        impl cynic::schema::HasField<hasPreviousPage> for super::super::PageInfo {
            type Type = super::super::Boolean;
            const NAME: &'static str = "hasPreviousPage";
        }
        pub struct startCursor;
        impl cynic::schema::HasField<startCursor> for super::super::PageInfo {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "startCursor";
        }
        pub struct endCursor;
        impl cynic::schema::HasField<endCursor> for super::super::PageInfo {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "endCursor";
        }
        pub struct __typename;
        impl cynic::schema::HasField<__typename> for super::super::PageInfo {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
    }
    pub mod PeopleConnection {
        pub struct pageInfo;
        impl cynic::schema::HasField<pageInfo> for super::super::PeopleConnection {
            type Type = super::super::PageInfo;
            const NAME: &'static str = "pageInfo";
        }
        pub struct edges;
        impl cynic::schema::HasField<edges> for super::super::PeopleConnection {
            type Type = Option<Vec<Option<super::super::PeopleEdge>>>;
            const NAME: &'static str = "edges";
        }
        pub struct totalCount;
        impl cynic::schema::HasField<totalCount> for super::super::PeopleConnection {
            type Type = Option<super::super::Int>;
            const NAME: &'static str = "totalCount";
        }
        pub struct people;
        impl cynic::schema::HasField<people> for super::super::PeopleConnection {
            type Type = Option<Vec<Option<super::super::Person>>>;
            const NAME: &'static str = "people";
        }
        pub struct __typename;
        impl cynic::schema::HasField<__typename> for super::super::PeopleConnection {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
    }
    pub mod PeopleEdge {
        pub struct node;
        impl cynic::schema::HasField<node> for super::super::PeopleEdge {
            type Type = Option<super::super::Person>;
            const NAME: &'static str = "node";
        }
        pub struct cursor;
        impl cynic::schema::HasField<cursor> for super::super::PeopleEdge {
            type Type = super::super::String;
            const NAME: &'static str = "cursor";
        }
        pub struct __typename;
        impl cynic::schema::HasField<__typename> for super::super::PeopleEdge {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
    }
    pub mod Person {
        pub struct name;
        impl cynic::schema::HasField<name> for super::super::Person {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name";
        }
        pub struct birthYear;
        impl cynic::schema::HasField<birthYear> for super::super::Person {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "birthYear";
        }
        pub struct eyeColor;
        impl cynic::schema::HasField<eyeColor> for super::super::Person {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "eyeColor";
        }
        pub struct gender;
        impl cynic::schema::HasField<gender> for super::super::Person {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "gender";
        }
        pub struct hairColor;
        impl cynic::schema::HasField<hairColor> for super::super::Person {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "hairColor";
        }
        pub struct height;
        impl cynic::schema::HasField<height> for super::super::Person {
            type Type = Option<super::super::Int>;
            const NAME: &'static str = "height";
        }
        pub struct mass;
        impl cynic::schema::HasField<mass> for super::super::Person {
            type Type = Option<super::super::Float>;
            const NAME: &'static str = "mass";
        }
        pub struct skinColor;
        impl cynic::schema::HasField<skinColor> for super::super::Person {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "skinColor";
        }
        pub struct homeworld;
        impl cynic::schema::HasField<homeworld> for super::super::Person {
            type Type = Option<super::super::Planet>;
            const NAME: &'static str = "homeworld";
        }
        pub struct filmConnection;
        impl cynic::schema::HasField<filmConnection> for super::super::Person {
            type Type = Option<super::super::PersonFilmsConnection>;
            const NAME: &'static str = "filmConnection";
        }
        pub mod _film_connection_arguments {
            pub struct after;
            impl cynic::schema::HasArgument<after> for super::filmConnection {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "after";
            }
            pub struct first;
            impl cynic::schema::HasArgument<first> for super::filmConnection {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "first";
            }
            pub struct before;
            impl cynic::schema::HasArgument<before> for super::filmConnection {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "before";
            }
            pub struct last;
            impl cynic::schema::HasArgument<last> for super::filmConnection {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "last";
            }
        }
        pub struct species;
        impl cynic::schema::HasField<species> for super::super::Person {
            type Type = Option<super::super::Species>;
            const NAME: &'static str = "species";
        }
        pub struct starshipConnection;
        impl cynic::schema::HasField<starshipConnection> for super::super::Person {
            type Type = Option<super::super::PersonStarshipsConnection>;
            const NAME: &'static str = "starshipConnection";
        }
        pub mod _starship_connection_arguments {
            pub struct after;
            impl cynic::schema::HasArgument<after> for super::starshipConnection {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "after";
            }
            pub struct first;
            impl cynic::schema::HasArgument<first> for super::starshipConnection {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "first";
            }
            pub struct before;
            impl cynic::schema::HasArgument<before> for super::starshipConnection {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "before";
            }
            pub struct last;
            impl cynic::schema::HasArgument<last> for super::starshipConnection {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "last";
            }
        }
        pub struct vehicleConnection;
        impl cynic::schema::HasField<vehicleConnection> for super::super::Person {
            type Type = Option<super::super::PersonVehiclesConnection>;
            const NAME: &'static str = "vehicleConnection";
        }
        pub mod _vehicle_connection_arguments {
            pub struct after;
            impl cynic::schema::HasArgument<after> for super::vehicleConnection {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "after";
            }
            pub struct first;
            impl cynic::schema::HasArgument<first> for super::vehicleConnection {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "first";
            }
            pub struct before;
            impl cynic::schema::HasArgument<before> for super::vehicleConnection {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "before";
            }
            pub struct last;
            impl cynic::schema::HasArgument<last> for super::vehicleConnection {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "last";
            }
        }
        pub struct created;
        impl cynic::schema::HasField<created> for super::super::Person {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "created";
        }
        pub struct edited;
        impl cynic::schema::HasField<edited> for super::super::Person {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "edited";
        }
        pub struct id;
        impl cynic::schema::HasField<id> for super::super::Person {
            type Type = super::super::ID;
            const NAME: &'static str = "id";
        }
        pub struct __typename;
        impl cynic::schema::HasField<__typename> for super::super::Person {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
    }
    pub mod PersonFilmsConnection {
        pub struct pageInfo;
        impl cynic::schema::HasField<pageInfo> for super::super::PersonFilmsConnection {
            type Type = super::super::PageInfo;
            const NAME: &'static str = "pageInfo";
        }
        pub struct edges;
        impl cynic::schema::HasField<edges> for super::super::PersonFilmsConnection {
            type Type = Option<Vec<Option<super::super::PersonFilmsEdge>>>;
            const NAME: &'static str = "edges";
        }
        pub struct totalCount;
        impl cynic::schema::HasField<totalCount> for super::super::PersonFilmsConnection {
            type Type = Option<super::super::Int>;
            const NAME: &'static str = "totalCount";
        }
        pub struct films;
        impl cynic::schema::HasField<films> for super::super::PersonFilmsConnection {
            type Type = Option<Vec<Option<super::super::Film>>>;
            const NAME: &'static str = "films";
        }
        pub struct __typename;
        impl cynic::schema::HasField<__typename> for super::super::PersonFilmsConnection {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
    }
    pub mod PersonFilmsEdge {
        pub struct node;
        impl cynic::schema::HasField<node> for super::super::PersonFilmsEdge {
            type Type = Option<super::super::Film>;
            const NAME: &'static str = "node";
        }
        pub struct cursor;
        impl cynic::schema::HasField<cursor> for super::super::PersonFilmsEdge {
            type Type = super::super::String;
            const NAME: &'static str = "cursor";
        }
        pub struct __typename;
        impl cynic::schema::HasField<__typename> for super::super::PersonFilmsEdge {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
    }
    pub mod PersonStarshipsConnection {
        pub struct pageInfo;
        impl cynic::schema::HasField<pageInfo> for super::super::PersonStarshipsConnection {
            type Type = super::super::PageInfo;
            const NAME: &'static str = "pageInfo";
        }
        pub struct edges;
        impl cynic::schema::HasField<edges> for super::super::PersonStarshipsConnection {
            type Type = Option<Vec<Option<super::super::PersonStarshipsEdge>>>;
            const NAME: &'static str = "edges";
        }
        pub struct totalCount;
        impl cynic::schema::HasField<totalCount> for super::super::PersonStarshipsConnection {
            type Type = Option<super::super::Int>;
            const NAME: &'static str = "totalCount";
        }
        pub struct starships;
        impl cynic::schema::HasField<starships> for super::super::PersonStarshipsConnection {
            type Type = Option<Vec<Option<super::super::Starship>>>;
            const NAME: &'static str = "starships";
        }
        pub struct __typename;
        impl cynic::schema::HasField<__typename> for super::super::PersonStarshipsConnection {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
    }
    pub mod PersonStarshipsEdge {
        pub struct node;
        impl cynic::schema::HasField<node> for super::super::PersonStarshipsEdge {
            type Type = Option<super::super::Starship>;
            const NAME: &'static str = "node";
        }
        pub struct cursor;
        impl cynic::schema::HasField<cursor> for super::super::PersonStarshipsEdge {
            type Type = super::super::String;
            const NAME: &'static str = "cursor";
        }
        pub struct __typename;
        impl cynic::schema::HasField<__typename> for super::super::PersonStarshipsEdge {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
    }
    pub mod PersonVehiclesConnection {
        pub struct pageInfo;
        impl cynic::schema::HasField<pageInfo> for super::super::PersonVehiclesConnection {
            type Type = super::super::PageInfo;
            const NAME: &'static str = "pageInfo";
        }
        pub struct edges;
        impl cynic::schema::HasField<edges> for super::super::PersonVehiclesConnection {
            type Type = Option<Vec<Option<super::super::PersonVehiclesEdge>>>;
            const NAME: &'static str = "edges";
        }
        pub struct totalCount;
        impl cynic::schema::HasField<totalCount> for super::super::PersonVehiclesConnection {
            type Type = Option<super::super::Int>;
            const NAME: &'static str = "totalCount";
        }
        pub struct vehicles;
        impl cynic::schema::HasField<vehicles> for super::super::PersonVehiclesConnection {
            type Type = Option<Vec<Option<super::super::Vehicle>>>;
            const NAME: &'static str = "vehicles";
        }
        pub struct __typename;
        impl cynic::schema::HasField<__typename> for super::super::PersonVehiclesConnection {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
    }
    pub mod PersonVehiclesEdge {
        pub struct node;
        impl cynic::schema::HasField<node> for super::super::PersonVehiclesEdge {
            type Type = Option<super::super::Vehicle>;
            const NAME: &'static str = "node";
        }
        pub struct cursor;
        impl cynic::schema::HasField<cursor> for super::super::PersonVehiclesEdge {
            type Type = super::super::String;
            const NAME: &'static str = "cursor";
        }
        pub struct __typename;
        impl cynic::schema::HasField<__typename> for super::super::PersonVehiclesEdge {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
    }
    pub mod Planet {
        pub struct name;
        impl cynic::schema::HasField<name> for super::super::Planet {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name";
        }
        pub struct diameter;
        impl cynic::schema::HasField<diameter> for super::super::Planet {
            type Type = Option<super::super::Int>;
            const NAME: &'static str = "diameter";
        }
        pub struct rotationPeriod;
        impl cynic::schema::HasField<rotationPeriod> for super::super::Planet {
            type Type = Option<super::super::Int>;
            const NAME: &'static str = "rotationPeriod";
        }
        pub struct orbitalPeriod;
        impl cynic::schema::HasField<orbitalPeriod> for super::super::Planet {
            type Type = Option<super::super::Int>;
            const NAME: &'static str = "orbitalPeriod";
        }
        pub struct gravity;
        impl cynic::schema::HasField<gravity> for super::super::Planet {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "gravity";
        }
        pub struct population;
        impl cynic::schema::HasField<population> for super::super::Planet {
            type Type = Option<super::super::Float>;
            const NAME: &'static str = "population";
        }
        pub struct climates;
        impl cynic::schema::HasField<climates> for super::super::Planet {
            type Type = Option<Vec<Option<super::super::String>>>;
            const NAME: &'static str = "climates";
        }
        pub struct terrains;
        impl cynic::schema::HasField<terrains> for super::super::Planet {
            type Type = Option<Vec<Option<super::super::String>>>;
            const NAME: &'static str = "terrains";
        }
        pub struct surfaceWater;
        impl cynic::schema::HasField<surfaceWater> for super::super::Planet {
            type Type = Option<super::super::Float>;
            const NAME: &'static str = "surfaceWater";
        }
        pub struct residentConnection;
        impl cynic::schema::HasField<residentConnection> for super::super::Planet {
            type Type = Option<super::super::PlanetResidentsConnection>;
            const NAME: &'static str = "residentConnection";
        }
        pub mod _resident_connection_arguments {
            pub struct after;
            impl cynic::schema::HasArgument<after> for super::residentConnection {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "after";
            }
            pub struct first;
            impl cynic::schema::HasArgument<first> for super::residentConnection {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "first";
            }
            pub struct before;
            impl cynic::schema::HasArgument<before> for super::residentConnection {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "before";
            }
            pub struct last;
            impl cynic::schema::HasArgument<last> for super::residentConnection {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "last";
            }
        }
        pub struct filmConnection;
        impl cynic::schema::HasField<filmConnection> for super::super::Planet {
            type Type = Option<super::super::PlanetFilmsConnection>;
            const NAME: &'static str = "filmConnection";
        }
        pub mod _film_connection_arguments {
            pub struct after;
            impl cynic::schema::HasArgument<after> for super::filmConnection {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "after";
            }
            pub struct first;
            impl cynic::schema::HasArgument<first> for super::filmConnection {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "first";
            }
            pub struct before;
            impl cynic::schema::HasArgument<before> for super::filmConnection {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "before";
            }
            pub struct last;
            impl cynic::schema::HasArgument<last> for super::filmConnection {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "last";
            }
        }
        pub struct created;
        impl cynic::schema::HasField<created> for super::super::Planet {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "created";
        }
        pub struct edited;
        impl cynic::schema::HasField<edited> for super::super::Planet {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "edited";
        }
        pub struct id;
        impl cynic::schema::HasField<id> for super::super::Planet {
            type Type = super::super::ID;
            const NAME: &'static str = "id";
        }
        pub struct __typename;
        impl cynic::schema::HasField<__typename> for super::super::Planet {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
    }
    pub mod PlanetFilmsConnection {
        pub struct pageInfo;
        impl cynic::schema::HasField<pageInfo> for super::super::PlanetFilmsConnection {
            type Type = super::super::PageInfo;
            const NAME: &'static str = "pageInfo";
        }
        pub struct edges;
        impl cynic::schema::HasField<edges> for super::super::PlanetFilmsConnection {
            type Type = Option<Vec<Option<super::super::PlanetFilmsEdge>>>;
            const NAME: &'static str = "edges";
        }
        pub struct totalCount;
        impl cynic::schema::HasField<totalCount> for super::super::PlanetFilmsConnection {
            type Type = Option<super::super::Int>;
            const NAME: &'static str = "totalCount";
        }
        pub struct films;
        impl cynic::schema::HasField<films> for super::super::PlanetFilmsConnection {
            type Type = Option<Vec<Option<super::super::Film>>>;
            const NAME: &'static str = "films";
        }
        pub struct __typename;
        impl cynic::schema::HasField<__typename> for super::super::PlanetFilmsConnection {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
    }
    pub mod PlanetFilmsEdge {
        pub struct node;
        impl cynic::schema::HasField<node> for super::super::PlanetFilmsEdge {
            type Type = Option<super::super::Film>;
            const NAME: &'static str = "node";
        }
        pub struct cursor;
        impl cynic::schema::HasField<cursor> for super::super::PlanetFilmsEdge {
            type Type = super::super::String;
            const NAME: &'static str = "cursor";
        }
        pub struct __typename;
        impl cynic::schema::HasField<__typename> for super::super::PlanetFilmsEdge {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
    }
    pub mod PlanetResidentsConnection {
        pub struct pageInfo;
        impl cynic::schema::HasField<pageInfo> for super::super::PlanetResidentsConnection {
            type Type = super::super::PageInfo;
            const NAME: &'static str = "pageInfo";
        }
        pub struct edges;
        impl cynic::schema::HasField<edges> for super::super::PlanetResidentsConnection {
            type Type = Option<Vec<Option<super::super::PlanetResidentsEdge>>>;
            const NAME: &'static str = "edges";
        }
        pub struct totalCount;
        impl cynic::schema::HasField<totalCount> for super::super::PlanetResidentsConnection {
            type Type = Option<super::super::Int>;
            const NAME: &'static str = "totalCount";
        }
        pub struct residents;
        impl cynic::schema::HasField<residents> for super::super::PlanetResidentsConnection {
            type Type = Option<Vec<Option<super::super::Person>>>;
            const NAME: &'static str = "residents";
        }
        pub struct __typename;
        impl cynic::schema::HasField<__typename> for super::super::PlanetResidentsConnection {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
    }
    pub mod PlanetResidentsEdge {
        pub struct node;
        impl cynic::schema::HasField<node> for super::super::PlanetResidentsEdge {
            type Type = Option<super::super::Person>;
            const NAME: &'static str = "node";
        }
        pub struct cursor;
        impl cynic::schema::HasField<cursor> for super::super::PlanetResidentsEdge {
            type Type = super::super::String;
            const NAME: &'static str = "cursor";
        }
        pub struct __typename;
        impl cynic::schema::HasField<__typename> for super::super::PlanetResidentsEdge {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
    }
    pub mod PlanetsConnection {
        pub struct pageInfo;
        impl cynic::schema::HasField<pageInfo> for super::super::PlanetsConnection {
            type Type = super::super::PageInfo;
            const NAME: &'static str = "pageInfo";
        }
        pub struct edges;
        impl cynic::schema::HasField<edges> for super::super::PlanetsConnection {
            type Type = Option<Vec<Option<super::super::PlanetsEdge>>>;
            const NAME: &'static str = "edges";
        }
        pub struct totalCount;
        impl cynic::schema::HasField<totalCount> for super::super::PlanetsConnection {
            type Type = Option<super::super::Int>;
            const NAME: &'static str = "totalCount";
        }
        pub struct planets;
        impl cynic::schema::HasField<planets> for super::super::PlanetsConnection {
            type Type = Option<Vec<Option<super::super::Planet>>>;
            const NAME: &'static str = "planets";
        }
        pub struct __typename;
        impl cynic::schema::HasField<__typename> for super::super::PlanetsConnection {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
    }
    pub mod PlanetsEdge {
        pub struct node;
        impl cynic::schema::HasField<node> for super::super::PlanetsEdge {
            type Type = Option<super::super::Planet>;
            const NAME: &'static str = "node";
        }
        pub struct cursor;
        impl cynic::schema::HasField<cursor> for super::super::PlanetsEdge {
            type Type = super::super::String;
            const NAME: &'static str = "cursor";
        }
        pub struct __typename;
        impl cynic::schema::HasField<__typename> for super::super::PlanetsEdge {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
    }
    pub mod Root {
        pub struct allFilms;
        impl cynic::schema::HasField<allFilms> for super::super::Root {
            type Type = Option<super::super::FilmsConnection>;
            const NAME: &'static str = "allFilms";
        }
        pub mod _all_films_arguments {
            pub struct after;
            impl cynic::schema::HasArgument<after> for super::allFilms {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "after";
            }
            pub struct first;
            impl cynic::schema::HasArgument<first> for super::allFilms {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "first";
            }
            pub struct before;
            impl cynic::schema::HasArgument<before> for super::allFilms {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "before";
            }
            pub struct last;
            impl cynic::schema::HasArgument<last> for super::allFilms {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "last";
            }
        }
        pub struct film;
        impl cynic::schema::HasField<film> for super::super::Root {
            type Type = Option<super::super::Film>;
            const NAME: &'static str = "film";
        }
        pub mod _film_arguments {
            pub struct id;
            impl cynic::schema::HasArgument<id> for super::film {
                type ArgumentType = Option<super::super::super::ID>;
                const NAME: &'static str = "id";
            }
            pub struct filmID;
            impl cynic::schema::HasArgument<filmID> for super::film {
                type ArgumentType = Option<super::super::super::ID>;
                const NAME: &'static str = "filmID";
            }
        }
        pub struct allPeople;
        impl cynic::schema::HasField<allPeople> for super::super::Root {
            type Type = Option<super::super::PeopleConnection>;
            const NAME: &'static str = "allPeople";
        }
        pub mod _all_people_arguments {
            pub struct after;
            impl cynic::schema::HasArgument<after> for super::allPeople {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "after";
            }
            pub struct first;
            impl cynic::schema::HasArgument<first> for super::allPeople {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "first";
            }
            pub struct before;
            impl cynic::schema::HasArgument<before> for super::allPeople {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "before";
            }
            pub struct last;
            impl cynic::schema::HasArgument<last> for super::allPeople {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "last";
            }
        }
        pub struct person;
        impl cynic::schema::HasField<person> for super::super::Root {
            type Type = Option<super::super::Person>;
            const NAME: &'static str = "person";
        }
        pub mod _person_arguments {
            pub struct id;
            impl cynic::schema::HasArgument<id> for super::person {
                type ArgumentType = Option<super::super::super::ID>;
                const NAME: &'static str = "id";
            }
            pub struct personID;
            impl cynic::schema::HasArgument<personID> for super::person {
                type ArgumentType = Option<super::super::super::ID>;
                const NAME: &'static str = "personID";
            }
        }
        pub struct allPlanets;
        impl cynic::schema::HasField<allPlanets> for super::super::Root {
            type Type = Option<super::super::PlanetsConnection>;
            const NAME: &'static str = "allPlanets";
        }
        pub mod _all_planets_arguments {
            pub struct after;
            impl cynic::schema::HasArgument<after> for super::allPlanets {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "after";
            }
            pub struct first;
            impl cynic::schema::HasArgument<first> for super::allPlanets {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "first";
            }
            pub struct before;
            impl cynic::schema::HasArgument<before> for super::allPlanets {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "before";
            }
            pub struct last;
            impl cynic::schema::HasArgument<last> for super::allPlanets {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "last";
            }
        }
        pub struct planet;
        impl cynic::schema::HasField<planet> for super::super::Root {
            type Type = Option<super::super::Planet>;
            const NAME: &'static str = "planet";
        }
        pub mod _planet_arguments {
            pub struct id;
            impl cynic::schema::HasArgument<id> for super::planet {
                type ArgumentType = Option<super::super::super::ID>;
                const NAME: &'static str = "id";
            }
            pub struct planetID;
            impl cynic::schema::HasArgument<planetID> for super::planet {
                type ArgumentType = Option<super::super::super::ID>;
                const NAME: &'static str = "planetID";
            }
        }
        pub struct allSpecies;
        impl cynic::schema::HasField<allSpecies> for super::super::Root {
            type Type = Option<super::super::SpeciesConnection>;
            const NAME: &'static str = "allSpecies";
        }
        pub mod _all_species_arguments {
            pub struct after;
            impl cynic::schema::HasArgument<after> for super::allSpecies {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "after";
            }
            pub struct first;
            impl cynic::schema::HasArgument<first> for super::allSpecies {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "first";
            }
            pub struct before;
            impl cynic::schema::HasArgument<before> for super::allSpecies {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "before";
            }
            pub struct last;
            impl cynic::schema::HasArgument<last> for super::allSpecies {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "last";
            }
        }
        pub struct species;
        impl cynic::schema::HasField<species> for super::super::Root {
            type Type = Option<super::super::Species>;
            const NAME: &'static str = "species";
        }
        pub mod _species_arguments {
            pub struct id;
            impl cynic::schema::HasArgument<id> for super::species {
                type ArgumentType = Option<super::super::super::ID>;
                const NAME: &'static str = "id";
            }
            pub struct speciesID;
            impl cynic::schema::HasArgument<speciesID> for super::species {
                type ArgumentType = Option<super::super::super::ID>;
                const NAME: &'static str = "speciesID";
            }
        }
        pub struct allStarships;
        impl cynic::schema::HasField<allStarships> for super::super::Root {
            type Type = Option<super::super::StarshipsConnection>;
            const NAME: &'static str = "allStarships";
        }
        pub mod _all_starships_arguments {
            pub struct after;
            impl cynic::schema::HasArgument<after> for super::allStarships {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "after";
            }
            pub struct first;
            impl cynic::schema::HasArgument<first> for super::allStarships {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "first";
            }
            pub struct before;
            impl cynic::schema::HasArgument<before> for super::allStarships {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "before";
            }
            pub struct last;
            impl cynic::schema::HasArgument<last> for super::allStarships {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "last";
            }
        }
        pub struct starship;
        impl cynic::schema::HasField<starship> for super::super::Root {
            type Type = Option<super::super::Starship>;
            const NAME: &'static str = "starship";
        }
        pub mod _starship_arguments {
            pub struct id;
            impl cynic::schema::HasArgument<id> for super::starship {
                type ArgumentType = Option<super::super::super::ID>;
                const NAME: &'static str = "id";
            }
            pub struct starshipID;
            impl cynic::schema::HasArgument<starshipID> for super::starship {
                type ArgumentType = Option<super::super::super::ID>;
                const NAME: &'static str = "starshipID";
            }
        }
        pub struct allVehicles;
        impl cynic::schema::HasField<allVehicles> for super::super::Root {
            type Type = Option<super::super::VehiclesConnection>;
            const NAME: &'static str = "allVehicles";
        }
        pub mod _all_vehicles_arguments {
            pub struct after;
            impl cynic::schema::HasArgument<after> for super::allVehicles {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "after";
            }
            pub struct first;
            impl cynic::schema::HasArgument<first> for super::allVehicles {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "first";
            }
            pub struct before;
            impl cynic::schema::HasArgument<before> for super::allVehicles {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "before";
            }
            pub struct last;
            impl cynic::schema::HasArgument<last> for super::allVehicles {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "last";
            }
        }
        pub struct vehicle;
        impl cynic::schema::HasField<vehicle> for super::super::Root {
            type Type = Option<super::super::Vehicle>;
            const NAME: &'static str = "vehicle";
        }
        pub mod _vehicle_arguments {
            pub struct id;
            impl cynic::schema::HasArgument<id> for super::vehicle {
                type ArgumentType = Option<super::super::super::ID>;
                const NAME: &'static str = "id";
            }
            pub struct vehicleID;
            impl cynic::schema::HasArgument<vehicleID> for super::vehicle {
                type ArgumentType = Option<super::super::super::ID>;
                const NAME: &'static str = "vehicleID";
            }
        }
        pub struct node;
        impl cynic::schema::HasField<node> for super::super::Root {
            type Type = Option<super::super::Node>;
            const NAME: &'static str = "node";
        }
        pub mod _node_arguments {
            pub struct id;
            impl cynic::schema::HasArgument<id> for super::node {
                type ArgumentType = super::super::super::ID;
                const NAME: &'static str = "id";
            }
        }
        pub struct __typename;
        impl cynic::schema::HasField<__typename> for super::super::Root {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
    }
    pub mod Species {
        pub struct name;
        impl cynic::schema::HasField<name> for super::super::Species {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name";
        }
        pub struct classification;
        impl cynic::schema::HasField<classification> for super::super::Species {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "classification";
        }
        pub struct designation;
        impl cynic::schema::HasField<designation> for super::super::Species {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "designation";
        }
        pub struct averageHeight;
        impl cynic::schema::HasField<averageHeight> for super::super::Species {
            type Type = Option<super::super::Float>;
            const NAME: &'static str = "averageHeight";
        }
        pub struct averageLifespan;
        impl cynic::schema::HasField<averageLifespan> for super::super::Species {
            type Type = Option<super::super::Int>;
            const NAME: &'static str = "averageLifespan";
        }
        pub struct eyeColors;
        impl cynic::schema::HasField<eyeColors> for super::super::Species {
            type Type = Option<Vec<Option<super::super::String>>>;
            const NAME: &'static str = "eyeColors";
        }
        pub struct hairColors;
        impl cynic::schema::HasField<hairColors> for super::super::Species {
            type Type = Option<Vec<Option<super::super::String>>>;
            const NAME: &'static str = "hairColors";
        }
        pub struct skinColors;
        impl cynic::schema::HasField<skinColors> for super::super::Species {
            type Type = Option<Vec<Option<super::super::String>>>;
            const NAME: &'static str = "skinColors";
        }
        pub struct language;
        impl cynic::schema::HasField<language> for super::super::Species {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "language";
        }
        pub struct homeworld;
        impl cynic::schema::HasField<homeworld> for super::super::Species {
            type Type = Option<super::super::Planet>;
            const NAME: &'static str = "homeworld";
        }
        pub struct personConnection;
        impl cynic::schema::HasField<personConnection> for super::super::Species {
            type Type = Option<super::super::SpeciesPeopleConnection>;
            const NAME: &'static str = "personConnection";
        }
        pub mod _person_connection_arguments {
            pub struct after;
            impl cynic::schema::HasArgument<after> for super::personConnection {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "after";
            }
            pub struct first;
            impl cynic::schema::HasArgument<first> for super::personConnection {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "first";
            }
            pub struct before;
            impl cynic::schema::HasArgument<before> for super::personConnection {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "before";
            }
            pub struct last;
            impl cynic::schema::HasArgument<last> for super::personConnection {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "last";
            }
        }
        pub struct filmConnection;
        impl cynic::schema::HasField<filmConnection> for super::super::Species {
            type Type = Option<super::super::SpeciesFilmsConnection>;
            const NAME: &'static str = "filmConnection";
        }
        pub mod _film_connection_arguments {
            pub struct after;
            impl cynic::schema::HasArgument<after> for super::filmConnection {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "after";
            }
            pub struct first;
            impl cynic::schema::HasArgument<first> for super::filmConnection {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "first";
            }
            pub struct before;
            impl cynic::schema::HasArgument<before> for super::filmConnection {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "before";
            }
            pub struct last;
            impl cynic::schema::HasArgument<last> for super::filmConnection {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "last";
            }
        }
        pub struct created;
        impl cynic::schema::HasField<created> for super::super::Species {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "created";
        }
        pub struct edited;
        impl cynic::schema::HasField<edited> for super::super::Species {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "edited";
        }
        pub struct id;
        impl cynic::schema::HasField<id> for super::super::Species {
            type Type = super::super::ID;
            const NAME: &'static str = "id";
        }
        pub struct __typename;
        impl cynic::schema::HasField<__typename> for super::super::Species {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
    }
    pub mod SpeciesConnection {
        pub struct pageInfo;
        impl cynic::schema::HasField<pageInfo> for super::super::SpeciesConnection {
            type Type = super::super::PageInfo;
            const NAME: &'static str = "pageInfo";
        }
        pub struct edges;
        impl cynic::schema::HasField<edges> for super::super::SpeciesConnection {
            type Type = Option<Vec<Option<super::super::SpeciesEdge>>>;
            const NAME: &'static str = "edges";
        }
        pub struct totalCount;
        impl cynic::schema::HasField<totalCount> for super::super::SpeciesConnection {
            type Type = Option<super::super::Int>;
            const NAME: &'static str = "totalCount";
        }
        pub struct species;
        impl cynic::schema::HasField<species> for super::super::SpeciesConnection {
            type Type = Option<Vec<Option<super::super::Species>>>;
            const NAME: &'static str = "species";
        }
        pub struct __typename;
        impl cynic::schema::HasField<__typename> for super::super::SpeciesConnection {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
    }
    pub mod SpeciesEdge {
        pub struct node;
        impl cynic::schema::HasField<node> for super::super::SpeciesEdge {
            type Type = Option<super::super::Species>;
            const NAME: &'static str = "node";
        }
        pub struct cursor;
        impl cynic::schema::HasField<cursor> for super::super::SpeciesEdge {
            type Type = super::super::String;
            const NAME: &'static str = "cursor";
        }
        pub struct __typename;
        impl cynic::schema::HasField<__typename> for super::super::SpeciesEdge {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
    }
    pub mod SpeciesFilmsConnection {
        pub struct pageInfo;
        impl cynic::schema::HasField<pageInfo> for super::super::SpeciesFilmsConnection {
            type Type = super::super::PageInfo;
            const NAME: &'static str = "pageInfo";
        }
        pub struct edges;
        impl cynic::schema::HasField<edges> for super::super::SpeciesFilmsConnection {
            type Type = Option<Vec<Option<super::super::SpeciesFilmsEdge>>>;
            const NAME: &'static str = "edges";
        }
        pub struct totalCount;
        impl cynic::schema::HasField<totalCount> for super::super::SpeciesFilmsConnection {
            type Type = Option<super::super::Int>;
            const NAME: &'static str = "totalCount";
        }
        pub struct films;
        impl cynic::schema::HasField<films> for super::super::SpeciesFilmsConnection {
            type Type = Option<Vec<Option<super::super::Film>>>;
            const NAME: &'static str = "films";
        }
        pub struct __typename;
        impl cynic::schema::HasField<__typename> for super::super::SpeciesFilmsConnection {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
    }
    pub mod SpeciesFilmsEdge {
        pub struct node;
        impl cynic::schema::HasField<node> for super::super::SpeciesFilmsEdge {
            type Type = Option<super::super::Film>;
            const NAME: &'static str = "node";
        }
        pub struct cursor;
        impl cynic::schema::HasField<cursor> for super::super::SpeciesFilmsEdge {
            type Type = super::super::String;
            const NAME: &'static str = "cursor";
        }
        pub struct __typename;
        impl cynic::schema::HasField<__typename> for super::super::SpeciesFilmsEdge {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
    }
    pub mod SpeciesPeopleConnection {
        pub struct pageInfo;
        impl cynic::schema::HasField<pageInfo> for super::super::SpeciesPeopleConnection {
            type Type = super::super::PageInfo;
            const NAME: &'static str = "pageInfo";
        }
        pub struct edges;
        impl cynic::schema::HasField<edges> for super::super::SpeciesPeopleConnection {
            type Type = Option<Vec<Option<super::super::SpeciesPeopleEdge>>>;
            const NAME: &'static str = "edges";
        }
        pub struct totalCount;
        impl cynic::schema::HasField<totalCount> for super::super::SpeciesPeopleConnection {
            type Type = Option<super::super::Int>;
            const NAME: &'static str = "totalCount";
        }
        pub struct people;
        impl cynic::schema::HasField<people> for super::super::SpeciesPeopleConnection {
            type Type = Option<Vec<Option<super::super::Person>>>;
            const NAME: &'static str = "people";
        }
        pub struct __typename;
        impl cynic::schema::HasField<__typename> for super::super::SpeciesPeopleConnection {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
    }
    pub mod SpeciesPeopleEdge {
        pub struct node;
        impl cynic::schema::HasField<node> for super::super::SpeciesPeopleEdge {
            type Type = Option<super::super::Person>;
            const NAME: &'static str = "node";
        }
        pub struct cursor;
        impl cynic::schema::HasField<cursor> for super::super::SpeciesPeopleEdge {
            type Type = super::super::String;
            const NAME: &'static str = "cursor";
        }
        pub struct __typename;
        impl cynic::schema::HasField<__typename> for super::super::SpeciesPeopleEdge {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
    }
    pub mod Starship {
        pub struct name;
        impl cynic::schema::HasField<name> for super::super::Starship {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name";
        }
        pub struct model;
        impl cynic::schema::HasField<model> for super::super::Starship {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "model";
        }
        pub struct starshipClass;
        impl cynic::schema::HasField<starshipClass> for super::super::Starship {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "starshipClass";
        }
        pub struct manufacturers;
        impl cynic::schema::HasField<manufacturers> for super::super::Starship {
            type Type = Option<Vec<Option<super::super::String>>>;
            const NAME: &'static str = "manufacturers";
        }
        pub struct costInCredits;
        impl cynic::schema::HasField<costInCredits> for super::super::Starship {
            type Type = Option<super::super::Float>;
            const NAME: &'static str = "costInCredits";
        }
        pub struct length;
        impl cynic::schema::HasField<length> for super::super::Starship {
            type Type = Option<super::super::Float>;
            const NAME: &'static str = "length";
        }
        pub struct crew;
        impl cynic::schema::HasField<crew> for super::super::Starship {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "crew";
        }
        pub struct passengers;
        impl cynic::schema::HasField<passengers> for super::super::Starship {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "passengers";
        }
        pub struct maxAtmospheringSpeed;
        impl cynic::schema::HasField<maxAtmospheringSpeed> for super::super::Starship {
            type Type = Option<super::super::Int>;
            const NAME: &'static str = "maxAtmospheringSpeed";
        }
        pub struct hyperdriveRating;
        impl cynic::schema::HasField<hyperdriveRating> for super::super::Starship {
            type Type = Option<super::super::Float>;
            const NAME: &'static str = "hyperdriveRating";
        }
        pub struct MGLT;
        impl cynic::schema::HasField<MGLT> for super::super::Starship {
            type Type = Option<super::super::Int>;
            const NAME: &'static str = "MGLT";
        }
        pub struct cargoCapacity;
        impl cynic::schema::HasField<cargoCapacity> for super::super::Starship {
            type Type = Option<super::super::Float>;
            const NAME: &'static str = "cargoCapacity";
        }
        pub struct consumables;
        impl cynic::schema::HasField<consumables> for super::super::Starship {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "consumables";
        }
        pub struct pilotConnection;
        impl cynic::schema::HasField<pilotConnection> for super::super::Starship {
            type Type = Option<super::super::StarshipPilotsConnection>;
            const NAME: &'static str = "pilotConnection";
        }
        pub mod _pilot_connection_arguments {
            pub struct after;
            impl cynic::schema::HasArgument<after> for super::pilotConnection {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "after";
            }
            pub struct first;
            impl cynic::schema::HasArgument<first> for super::pilotConnection {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "first";
            }
            pub struct before;
            impl cynic::schema::HasArgument<before> for super::pilotConnection {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "before";
            }
            pub struct last;
            impl cynic::schema::HasArgument<last> for super::pilotConnection {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "last";
            }
        }
        pub struct filmConnection;
        impl cynic::schema::HasField<filmConnection> for super::super::Starship {
            type Type = Option<super::super::StarshipFilmsConnection>;
            const NAME: &'static str = "filmConnection";
        }
        pub mod _film_connection_arguments {
            pub struct after;
            impl cynic::schema::HasArgument<after> for super::filmConnection {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "after";
            }
            pub struct first;
            impl cynic::schema::HasArgument<first> for super::filmConnection {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "first";
            }
            pub struct before;
            impl cynic::schema::HasArgument<before> for super::filmConnection {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "before";
            }
            pub struct last;
            impl cynic::schema::HasArgument<last> for super::filmConnection {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "last";
            }
        }
        pub struct created;
        impl cynic::schema::HasField<created> for super::super::Starship {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "created";
        }
        pub struct edited;
        impl cynic::schema::HasField<edited> for super::super::Starship {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "edited";
        }
        pub struct id;
        impl cynic::schema::HasField<id> for super::super::Starship {
            type Type = super::super::ID;
            const NAME: &'static str = "id";
        }
        pub struct __typename;
        impl cynic::schema::HasField<__typename> for super::super::Starship {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
    }
    pub mod StarshipFilmsConnection {
        pub struct pageInfo;
        impl cynic::schema::HasField<pageInfo> for super::super::StarshipFilmsConnection {
            type Type = super::super::PageInfo;
            const NAME: &'static str = "pageInfo";
        }
        pub struct edges;
        impl cynic::schema::HasField<edges> for super::super::StarshipFilmsConnection {
            type Type = Option<Vec<Option<super::super::StarshipFilmsEdge>>>;
            const NAME: &'static str = "edges";
        }
        pub struct totalCount;
        impl cynic::schema::HasField<totalCount> for super::super::StarshipFilmsConnection {
            type Type = Option<super::super::Int>;
            const NAME: &'static str = "totalCount";
        }
        pub struct films;
        impl cynic::schema::HasField<films> for super::super::StarshipFilmsConnection {
            type Type = Option<Vec<Option<super::super::Film>>>;
            const NAME: &'static str = "films";
        }
        pub struct __typename;
        impl cynic::schema::HasField<__typename> for super::super::StarshipFilmsConnection {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
    }
    pub mod StarshipFilmsEdge {
        pub struct node;
        impl cynic::schema::HasField<node> for super::super::StarshipFilmsEdge {
            type Type = Option<super::super::Film>;
            const NAME: &'static str = "node";
        }
        pub struct cursor;
        impl cynic::schema::HasField<cursor> for super::super::StarshipFilmsEdge {
            type Type = super::super::String;
            const NAME: &'static str = "cursor";
        }
        pub struct __typename;
        impl cynic::schema::HasField<__typename> for super::super::StarshipFilmsEdge {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
    }
    pub mod StarshipPilotsConnection {
        pub struct pageInfo;
        impl cynic::schema::HasField<pageInfo> for super::super::StarshipPilotsConnection {
            type Type = super::super::PageInfo;
            const NAME: &'static str = "pageInfo";
        }
        pub struct edges;
        impl cynic::schema::HasField<edges> for super::super::StarshipPilotsConnection {
            type Type = Option<Vec<Option<super::super::StarshipPilotsEdge>>>;
            const NAME: &'static str = "edges";
        }
        pub struct totalCount;
        impl cynic::schema::HasField<totalCount> for super::super::StarshipPilotsConnection {
            type Type = Option<super::super::Int>;
            const NAME: &'static str = "totalCount";
        }
        pub struct pilots;
        impl cynic::schema::HasField<pilots> for super::super::StarshipPilotsConnection {
            type Type = Option<Vec<Option<super::super::Person>>>;
            const NAME: &'static str = "pilots";
        }
        pub struct __typename;
        impl cynic::schema::HasField<__typename> for super::super::StarshipPilotsConnection {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
    }
    pub mod StarshipPilotsEdge {
        pub struct node;
        impl cynic::schema::HasField<node> for super::super::StarshipPilotsEdge {
            type Type = Option<super::super::Person>;
            const NAME: &'static str = "node";
        }
        pub struct cursor;
        impl cynic::schema::HasField<cursor> for super::super::StarshipPilotsEdge {
            type Type = super::super::String;
            const NAME: &'static str = "cursor";
        }
        pub struct __typename;
        impl cynic::schema::HasField<__typename> for super::super::StarshipPilotsEdge {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
    }
    pub mod StarshipsConnection {
        pub struct pageInfo;
        impl cynic::schema::HasField<pageInfo> for super::super::StarshipsConnection {
            type Type = super::super::PageInfo;
            const NAME: &'static str = "pageInfo";
        }
        pub struct edges;
        impl cynic::schema::HasField<edges> for super::super::StarshipsConnection {
            type Type = Option<Vec<Option<super::super::StarshipsEdge>>>;
            const NAME: &'static str = "edges";
        }
        pub struct totalCount;
        impl cynic::schema::HasField<totalCount> for super::super::StarshipsConnection {
            type Type = Option<super::super::Int>;
            const NAME: &'static str = "totalCount";
        }
        pub struct starships;
        impl cynic::schema::HasField<starships> for super::super::StarshipsConnection {
            type Type = Option<Vec<Option<super::super::Starship>>>;
            const NAME: &'static str = "starships";
        }
        pub struct __typename;
        impl cynic::schema::HasField<__typename> for super::super::StarshipsConnection {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
    }
    pub mod StarshipsEdge {
        pub struct node;
        impl cynic::schema::HasField<node> for super::super::StarshipsEdge {
            type Type = Option<super::super::Starship>;
            const NAME: &'static str = "node";
        }
        pub struct cursor;
        impl cynic::schema::HasField<cursor> for super::super::StarshipsEdge {
            type Type = super::super::String;
            const NAME: &'static str = "cursor";
        }
        pub struct __typename;
        impl cynic::schema::HasField<__typename> for super::super::StarshipsEdge {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
    }
    pub mod Vehicle {
        pub struct name;
        impl cynic::schema::HasField<name> for super::super::Vehicle {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name";
        }
        pub struct model;
        impl cynic::schema::HasField<model> for super::super::Vehicle {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "model";
        }
        pub struct vehicleClass;
        impl cynic::schema::HasField<vehicleClass> for super::super::Vehicle {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "vehicleClass";
        }
        pub struct manufacturers;
        impl cynic::schema::HasField<manufacturers> for super::super::Vehicle {
            type Type = Option<Vec<Option<super::super::String>>>;
            const NAME: &'static str = "manufacturers";
        }
        pub struct costInCredits;
        impl cynic::schema::HasField<costInCredits> for super::super::Vehicle {
            type Type = Option<super::super::Float>;
            const NAME: &'static str = "costInCredits";
        }
        pub struct length;
        impl cynic::schema::HasField<length> for super::super::Vehicle {
            type Type = Option<super::super::Float>;
            const NAME: &'static str = "length";
        }
        pub struct crew;
        impl cynic::schema::HasField<crew> for super::super::Vehicle {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "crew";
        }
        pub struct passengers;
        impl cynic::schema::HasField<passengers> for super::super::Vehicle {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "passengers";
        }
        pub struct maxAtmospheringSpeed;
        impl cynic::schema::HasField<maxAtmospheringSpeed> for super::super::Vehicle {
            type Type = Option<super::super::Int>;
            const NAME: &'static str = "maxAtmospheringSpeed";
        }
        pub struct cargoCapacity;
        impl cynic::schema::HasField<cargoCapacity> for super::super::Vehicle {
            type Type = Option<super::super::Float>;
            const NAME: &'static str = "cargoCapacity";
        }
        pub struct consumables;
        impl cynic::schema::HasField<consumables> for super::super::Vehicle {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "consumables";
        }
        pub struct pilotConnection;
        impl cynic::schema::HasField<pilotConnection> for super::super::Vehicle {
            type Type = Option<super::super::VehiclePilotsConnection>;
            const NAME: &'static str = "pilotConnection";
        }
        pub mod _pilot_connection_arguments {
            pub struct after;
            impl cynic::schema::HasArgument<after> for super::pilotConnection {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "after";
            }
            pub struct first;
            impl cynic::schema::HasArgument<first> for super::pilotConnection {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "first";
            }
            pub struct before;
            impl cynic::schema::HasArgument<before> for super::pilotConnection {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "before";
            }
            pub struct last;
            impl cynic::schema::HasArgument<last> for super::pilotConnection {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "last";
            }
        }
        pub struct filmConnection;
        impl cynic::schema::HasField<filmConnection> for super::super::Vehicle {
            type Type = Option<super::super::VehicleFilmsConnection>;
            const NAME: &'static str = "filmConnection";
        }
        pub mod _film_connection_arguments {
            pub struct after;
            impl cynic::schema::HasArgument<after> for super::filmConnection {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "after";
            }
            pub struct first;
            impl cynic::schema::HasArgument<first> for super::filmConnection {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "first";
            }
            pub struct before;
            impl cynic::schema::HasArgument<before> for super::filmConnection {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "before";
            }
            pub struct last;
            impl cynic::schema::HasArgument<last> for super::filmConnection {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "last";
            }
        }
        pub struct created;
        impl cynic::schema::HasField<created> for super::super::Vehicle {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "created";
        }
        pub struct edited;
        impl cynic::schema::HasField<edited> for super::super::Vehicle {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "edited";
        }
        pub struct id;
        impl cynic::schema::HasField<id> for super::super::Vehicle {
            type Type = super::super::ID;
            const NAME: &'static str = "id";
        }
        pub struct __typename;
        impl cynic::schema::HasField<__typename> for super::super::Vehicle {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
    }
    pub mod VehicleFilmsConnection {
        pub struct pageInfo;
        impl cynic::schema::HasField<pageInfo> for super::super::VehicleFilmsConnection {
            type Type = super::super::PageInfo;
            const NAME: &'static str = "pageInfo";
        }
        pub struct edges;
        impl cynic::schema::HasField<edges> for super::super::VehicleFilmsConnection {
            type Type = Option<Vec<Option<super::super::VehicleFilmsEdge>>>;
            const NAME: &'static str = "edges";
        }
        pub struct totalCount;
        impl cynic::schema::HasField<totalCount> for super::super::VehicleFilmsConnection {
            type Type = Option<super::super::Int>;
            const NAME: &'static str = "totalCount";
        }
        pub struct films;
        impl cynic::schema::HasField<films> for super::super::VehicleFilmsConnection {
            type Type = Option<Vec<Option<super::super::Film>>>;
            const NAME: &'static str = "films";
        }
        pub struct __typename;
        impl cynic::schema::HasField<__typename> for super::super::VehicleFilmsConnection {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
    }
    pub mod VehicleFilmsEdge {
        pub struct node;
        impl cynic::schema::HasField<node> for super::super::VehicleFilmsEdge {
            type Type = Option<super::super::Film>;
            const NAME: &'static str = "node";
        }
        pub struct cursor;
        impl cynic::schema::HasField<cursor> for super::super::VehicleFilmsEdge {
            type Type = super::super::String;
            const NAME: &'static str = "cursor";
        }
        pub struct __typename;
        impl cynic::schema::HasField<__typename> for super::super::VehicleFilmsEdge {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
    }
    pub mod VehiclePilotsConnection {
        pub struct pageInfo;
        impl cynic::schema::HasField<pageInfo> for super::super::VehiclePilotsConnection {
            type Type = super::super::PageInfo;
            const NAME: &'static str = "pageInfo";
        }
        pub struct edges;
        impl cynic::schema::HasField<edges> for super::super::VehiclePilotsConnection {
            type Type = Option<Vec<Option<super::super::VehiclePilotsEdge>>>;
            const NAME: &'static str = "edges";
        }
        pub struct totalCount;
        impl cynic::schema::HasField<totalCount> for super::super::VehiclePilotsConnection {
            type Type = Option<super::super::Int>;
            const NAME: &'static str = "totalCount";
        }
        pub struct pilots;
        impl cynic::schema::HasField<pilots> for super::super::VehiclePilotsConnection {
            type Type = Option<Vec<Option<super::super::Person>>>;
            const NAME: &'static str = "pilots";
        }
        pub struct __typename;
        impl cynic::schema::HasField<__typename> for super::super::VehiclePilotsConnection {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
    }
    pub mod VehiclePilotsEdge {
        pub struct node;
        impl cynic::schema::HasField<node> for super::super::VehiclePilotsEdge {
            type Type = Option<super::super::Person>;
            const NAME: &'static str = "node";
        }
        pub struct cursor;
        impl cynic::schema::HasField<cursor> for super::super::VehiclePilotsEdge {
            type Type = super::super::String;
            const NAME: &'static str = "cursor";
        }
        pub struct __typename;
        impl cynic::schema::HasField<__typename> for super::super::VehiclePilotsEdge {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
    }
    pub mod VehiclesConnection {
        pub struct pageInfo;
        impl cynic::schema::HasField<pageInfo> for super::super::VehiclesConnection {
            type Type = super::super::PageInfo;
            const NAME: &'static str = "pageInfo";
        }
        pub struct edges;
        impl cynic::schema::HasField<edges> for super::super::VehiclesConnection {
            type Type = Option<Vec<Option<super::super::VehiclesEdge>>>;
            const NAME: &'static str = "edges";
        }
        pub struct totalCount;
        impl cynic::schema::HasField<totalCount> for super::super::VehiclesConnection {
            type Type = Option<super::super::Int>;
            const NAME: &'static str = "totalCount";
        }
        pub struct vehicles;
        impl cynic::schema::HasField<vehicles> for super::super::VehiclesConnection {
            type Type = Option<Vec<Option<super::super::Vehicle>>>;
            const NAME: &'static str = "vehicles";
        }
        pub struct __typename;
        impl cynic::schema::HasField<__typename> for super::super::VehiclesConnection {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
    }
    pub mod VehiclesEdge {
        pub struct node;
        impl cynic::schema::HasField<node> for super::super::VehiclesEdge {
            type Type = Option<super::super::Vehicle>;
            const NAME: &'static str = "node";
        }
        pub struct cursor;
        impl cynic::schema::HasField<cursor> for super::super::VehiclesEdge {
            type Type = super::super::String;
            const NAME: &'static str = "cursor";
        }
        pub struct __typename;
        impl cynic::schema::HasField<__typename> for super::super::VehiclesEdge {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
    }
}
pub type Boolean = bool;
pub type String = std::string::String;
pub type Float = f64;
pub type Int = i32;
pub type ID = cynic::Id;
pub mod variable {
    use cynic::variables::VariableType;
    #[doc = r" Used to determine the type of a given variable that"]
    #[doc = r" appears in an argument struct."]
    pub trait Variable {
        const TYPE: VariableType;
    }
    impl<T> Variable for &T
    where
        T: ?::core::marker::Sized + Variable,
    {
        const TYPE: VariableType = T::TYPE;
    }
    impl<T> Variable for Option<T>
    where
        T: Variable,
    {
        const TYPE: VariableType = VariableType::Nullable(&T::TYPE);
    }
    impl<T> Variable for [T]
    where
        T: Variable,
    {
        const TYPE: VariableType = VariableType::List(&T::TYPE);
    }
    impl<T> Variable for Vec<T>
    where
        T: Variable,
    {
        const TYPE: VariableType = VariableType::List(&T::TYPE);
    }
    impl<T> Variable for Box<T>
    where
        T: Variable,
    {
        const TYPE: VariableType = T::TYPE;
    }
    impl<T> Variable for std::rc::Rc<T>
    where
        T: Variable,
    {
        const TYPE: VariableType = T::TYPE;
    }
    impl<T> Variable for std::sync::Arc<T>
    where
        T: Variable,
    {
        const TYPE: VariableType = T::TYPE;
    }
    impl<T> Variable for std::borrow::Cow<'_, T>
    where
        T: ?::core::marker::Sized + Variable + ToOwned,
    {
        const TYPE: VariableType = T::TYPE;
    }
    impl Variable for bool {
        const TYPE: VariableType = VariableType::Named("Boolean");
    }
    impl Variable for str {
        const TYPE: VariableType = VariableType::Named("String");
    }
    impl Variable for String {
        const TYPE: VariableType = <str as Variable>::TYPE;
    }
    impl Variable for f64 {
        const TYPE: VariableType = VariableType::Named("Float");
    }
    impl Variable for i32 {
        const TYPE: VariableType = VariableType::Named("Int");
    }
    impl Variable for cynic::Id {
        const TYPE: VariableType = VariableType::Named("ID");
    }
}

