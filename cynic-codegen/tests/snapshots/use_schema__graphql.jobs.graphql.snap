---
source: cynic-codegen/tests/use-schema.rs
expression: "format_code(format!(\"{}\", tokens))"
---
impl ::cynic::schema::QueryRoot for Query {}
impl ::cynic::schema::MutationRoot for Mutation {}
pub struct City;
pub mod city_fields {
    pub struct id;
    impl ::cynic::schema::Field for id {
        type Type = super::ID;
        const NAME: &'static str = "id";
    }
    impl ::cynic::schema::HasField<id> for super::City {
        type Type = super::ID;
    }
    pub struct name;
    impl ::cynic::schema::Field for name {
        type Type = super::String;
        const NAME: &'static str = "name";
    }
    impl ::cynic::schema::HasField<name> for super::City {
        type Type = super::String;
    }
    pub struct slug;
    impl ::cynic::schema::Field for slug {
        type Type = super::String;
        const NAME: &'static str = "slug";
    }
    impl ::cynic::schema::HasField<slug> for super::City {
        type Type = super::String;
    }
    pub struct country;
    impl ::cynic::schema::Field for country {
        type Type = super::Country;
        const NAME: &'static str = "country";
    }
    impl ::cynic::schema::HasField<country> for super::City {
        type Type = super::Country;
    }
    pub struct r#type;
    impl ::cynic::schema::Field for r#type {
        type Type = super::String;
        const NAME: &'static str = "type";
    }
    impl ::cynic::schema::HasField<r#type> for super::City {
        type Type = super::String;
    }
    pub struct jobs;
    impl ::cynic::schema::Field for jobs {
        type Type = Option<Vec<super::Job>>;
        const NAME: &'static str = "jobs";
    }
    impl ::cynic::schema::HasField<jobs> for super::City {
        type Type = Option<Vec<super::Job>>;
    }
    pub mod jobs_arguments {
        pub struct r#where;
        impl ::cynic::schema::HasArgument<r#where> for super::jobs {
            type ArgumentType = Option<super::super::JobWhereInput>;
            const NAME: &'static str = "where";
        }
        pub struct orderBy;
        impl ::cynic::schema::HasArgument<orderBy> for super::jobs {
            type ArgumentType = Option<super::super::JobOrderByInput>;
            const NAME: &'static str = "orderBy";
        }
        pub struct skip;
        impl ::cynic::schema::HasArgument<skip> for super::jobs {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "skip";
        }
        pub struct after;
        impl ::cynic::schema::HasArgument<after> for super::jobs {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "after";
        }
        pub struct before;
        impl ::cynic::schema::HasArgument<before> for super::jobs {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "before";
        }
        pub struct first;
        impl ::cynic::schema::HasArgument<first> for super::jobs {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "first";
        }
        pub struct last;
        impl ::cynic::schema::HasArgument<last> for super::jobs {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "last";
        }
    }
    pub struct createdAt;
    impl ::cynic::schema::Field for createdAt {
        type Type = super::DateTime;
        const NAME: &'static str = "createdAt";
    }
    impl ::cynic::schema::HasField<createdAt> for super::City {
        type Type = super::DateTime;
    }
    pub struct updatedAt;
    impl ::cynic::schema::Field for updatedAt {
        type Type = super::DateTime;
        const NAME: &'static str = "updatedAt";
    }
    impl ::cynic::schema::HasField<updatedAt> for super::City {
        type Type = super::DateTime;
    }
}
pub struct CityOrderByInput {}
pub struct CityWhereInput;
impl ::cynic::schema::InputObjectMarker for CityWhereInput {}
pub mod city_where_input_fields {
    pub struct id;
    impl ::cynic::schema::Field for id {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id";
    }
    impl ::cynic::schema::HasInputField<id, Option<super::ID>> for super::CityWhereInput {}
    pub struct id_not;
    impl ::cynic::schema::Field for id_not {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_not";
    }
    impl ::cynic::schema::HasInputField<id_not, Option<super::ID>> for super::CityWhereInput {}
    pub struct id_in;
    impl ::cynic::schema::Field for id_in {
        type Type = Option<Vec<super::ID>>;
        const NAME: &'static str = "id_in";
    }
    impl ::cynic::schema::HasInputField<id_in, Option<Vec<super::ID>>> for super::CityWhereInput {}
    pub struct id_not_in;
    impl ::cynic::schema::Field for id_not_in {
        type Type = Option<Vec<super::ID>>;
        const NAME: &'static str = "id_not_in";
    }
    impl ::cynic::schema::HasInputField<id_not_in, Option<Vec<super::ID>>> for super::CityWhereInput {}
    pub struct id_lt;
    impl ::cynic::schema::Field for id_lt {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_lt";
    }
    impl ::cynic::schema::HasInputField<id_lt, Option<super::ID>> for super::CityWhereInput {}
    pub struct id_lte;
    impl ::cynic::schema::Field for id_lte {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_lte";
    }
    impl ::cynic::schema::HasInputField<id_lte, Option<super::ID>> for super::CityWhereInput {}
    pub struct id_gt;
    impl ::cynic::schema::Field for id_gt {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_gt";
    }
    impl ::cynic::schema::HasInputField<id_gt, Option<super::ID>> for super::CityWhereInput {}
    pub struct id_gte;
    impl ::cynic::schema::Field for id_gte {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_gte";
    }
    impl ::cynic::schema::HasInputField<id_gte, Option<super::ID>> for super::CityWhereInput {}
    pub struct id_contains;
    impl ::cynic::schema::Field for id_contains {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_contains";
    }
    impl ::cynic::schema::HasInputField<id_contains, Option<super::ID>> for super::CityWhereInput {}
    pub struct id_not_contains;
    impl ::cynic::schema::Field for id_not_contains {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_not_contains";
    }
    impl ::cynic::schema::HasInputField<id_not_contains, Option<super::ID>> for super::CityWhereInput {}
    pub struct id_starts_with;
    impl ::cynic::schema::Field for id_starts_with {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_starts_with";
    }
    impl ::cynic::schema::HasInputField<id_starts_with, Option<super::ID>> for super::CityWhereInput {}
    pub struct id_not_starts_with;
    impl ::cynic::schema::Field for id_not_starts_with {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_not_starts_with";
    }
    impl ::cynic::schema::HasInputField<id_not_starts_with, Option<super::ID>>
        for super::CityWhereInput
    {
    }
    pub struct id_ends_with;
    impl ::cynic::schema::Field for id_ends_with {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_ends_with";
    }
    impl ::cynic::schema::HasInputField<id_ends_with, Option<super::ID>> for super::CityWhereInput {}
    pub struct id_not_ends_with;
    impl ::cynic::schema::Field for id_not_ends_with {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_not_ends_with";
    }
    impl ::cynic::schema::HasInputField<id_not_ends_with, Option<super::ID>> for super::CityWhereInput {}
    pub struct name;
    impl ::cynic::schema::Field for name {
        type Type = Option<super::String>;
        const NAME: &'static str = "name";
    }
    impl ::cynic::schema::HasInputField<name, Option<super::String>> for super::CityWhereInput {}
    pub struct name_not;
    impl ::cynic::schema::Field for name_not {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_not";
    }
    impl ::cynic::schema::HasInputField<name_not, Option<super::String>> for super::CityWhereInput {}
    pub struct name_in;
    impl ::cynic::schema::Field for name_in {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "name_in";
    }
    impl ::cynic::schema::HasInputField<name_in, Option<Vec<super::String>>> for super::CityWhereInput {}
    pub struct name_not_in;
    impl ::cynic::schema::Field for name_not_in {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "name_not_in";
    }
    impl ::cynic::schema::HasInputField<name_not_in, Option<Vec<super::String>>>
        for super::CityWhereInput
    {
    }
    pub struct name_lt;
    impl ::cynic::schema::Field for name_lt {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_lt";
    }
    impl ::cynic::schema::HasInputField<name_lt, Option<super::String>> for super::CityWhereInput {}
    pub struct name_lte;
    impl ::cynic::schema::Field for name_lte {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_lte";
    }
    impl ::cynic::schema::HasInputField<name_lte, Option<super::String>> for super::CityWhereInput {}
    pub struct name_gt;
    impl ::cynic::schema::Field for name_gt {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_gt";
    }
    impl ::cynic::schema::HasInputField<name_gt, Option<super::String>> for super::CityWhereInput {}
    pub struct name_gte;
    impl ::cynic::schema::Field for name_gte {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_gte";
    }
    impl ::cynic::schema::HasInputField<name_gte, Option<super::String>> for super::CityWhereInput {}
    pub struct name_contains;
    impl ::cynic::schema::Field for name_contains {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_contains";
    }
    impl ::cynic::schema::HasInputField<name_contains, Option<super::String>>
        for super::CityWhereInput
    {
    }
    pub struct name_not_contains;
    impl ::cynic::schema::Field for name_not_contains {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_not_contains";
    }
    impl ::cynic::schema::HasInputField<name_not_contains, Option<super::String>>
        for super::CityWhereInput
    {
    }
    pub struct name_starts_with;
    impl ::cynic::schema::Field for name_starts_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_starts_with";
    }
    impl ::cynic::schema::HasInputField<name_starts_with, Option<super::String>>
        for super::CityWhereInput
    {
    }
    pub struct name_not_starts_with;
    impl ::cynic::schema::Field for name_not_starts_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_not_starts_with";
    }
    impl ::cynic::schema::HasInputField<name_not_starts_with, Option<super::String>>
        for super::CityWhereInput
    {
    }
    pub struct name_ends_with;
    impl ::cynic::schema::Field for name_ends_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_ends_with";
    }
    impl ::cynic::schema::HasInputField<name_ends_with, Option<super::String>>
        for super::CityWhereInput
    {
    }
    pub struct name_not_ends_with;
    impl ::cynic::schema::Field for name_not_ends_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_not_ends_with";
    }
    impl ::cynic::schema::HasInputField<name_not_ends_with, Option<super::String>>
        for super::CityWhereInput
    {
    }
    pub struct slug;
    impl ::cynic::schema::Field for slug {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug";
    }
    impl ::cynic::schema::HasInputField<slug, Option<super::String>> for super::CityWhereInput {}
    pub struct slug_not;
    impl ::cynic::schema::Field for slug_not {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_not";
    }
    impl ::cynic::schema::HasInputField<slug_not, Option<super::String>> for super::CityWhereInput {}
    pub struct slug_in;
    impl ::cynic::schema::Field for slug_in {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "slug_in";
    }
    impl ::cynic::schema::HasInputField<slug_in, Option<Vec<super::String>>> for super::CityWhereInput {}
    pub struct slug_not_in;
    impl ::cynic::schema::Field for slug_not_in {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "slug_not_in";
    }
    impl ::cynic::schema::HasInputField<slug_not_in, Option<Vec<super::String>>>
        for super::CityWhereInput
    {
    }
    pub struct slug_lt;
    impl ::cynic::schema::Field for slug_lt {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_lt";
    }
    impl ::cynic::schema::HasInputField<slug_lt, Option<super::String>> for super::CityWhereInput {}
    pub struct slug_lte;
    impl ::cynic::schema::Field for slug_lte {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_lte";
    }
    impl ::cynic::schema::HasInputField<slug_lte, Option<super::String>> for super::CityWhereInput {}
    pub struct slug_gt;
    impl ::cynic::schema::Field for slug_gt {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_gt";
    }
    impl ::cynic::schema::HasInputField<slug_gt, Option<super::String>> for super::CityWhereInput {}
    pub struct slug_gte;
    impl ::cynic::schema::Field for slug_gte {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_gte";
    }
    impl ::cynic::schema::HasInputField<slug_gte, Option<super::String>> for super::CityWhereInput {}
    pub struct slug_contains;
    impl ::cynic::schema::Field for slug_contains {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_contains";
    }
    impl ::cynic::schema::HasInputField<slug_contains, Option<super::String>>
        for super::CityWhereInput
    {
    }
    pub struct slug_not_contains;
    impl ::cynic::schema::Field for slug_not_contains {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_not_contains";
    }
    impl ::cynic::schema::HasInputField<slug_not_contains, Option<super::String>>
        for super::CityWhereInput
    {
    }
    pub struct slug_starts_with;
    impl ::cynic::schema::Field for slug_starts_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_starts_with";
    }
    impl ::cynic::schema::HasInputField<slug_starts_with, Option<super::String>>
        for super::CityWhereInput
    {
    }
    pub struct slug_not_starts_with;
    impl ::cynic::schema::Field for slug_not_starts_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_not_starts_with";
    }
    impl ::cynic::schema::HasInputField<slug_not_starts_with, Option<super::String>>
        for super::CityWhereInput
    {
    }
    pub struct slug_ends_with;
    impl ::cynic::schema::Field for slug_ends_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_ends_with";
    }
    impl ::cynic::schema::HasInputField<slug_ends_with, Option<super::String>>
        for super::CityWhereInput
    {
    }
    pub struct slug_not_ends_with;
    impl ::cynic::schema::Field for slug_not_ends_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_not_ends_with";
    }
    impl ::cynic::schema::HasInputField<slug_not_ends_with, Option<super::String>>
        for super::CityWhereInput
    {
    }
    pub struct country;
    impl ::cynic::schema::Field for country {
        type Type = Option<super::CountryWhereInput>;
        const NAME: &'static str = "country";
    }
    impl ::cynic::schema::HasInputField<country, Option<super::CountryWhereInput>>
        for super::CityWhereInput
    {
    }
    pub struct r#type;
    impl ::cynic::schema::Field for r#type {
        type Type = Option<super::String>;
        const NAME: &'static str = "type";
    }
    impl ::cynic::schema::HasInputField<r#type, Option<super::String>> for super::CityWhereInput {}
    pub struct type_not;
    impl ::cynic::schema::Field for type_not {
        type Type = Option<super::String>;
        const NAME: &'static str = "type_not";
    }
    impl ::cynic::schema::HasInputField<type_not, Option<super::String>> for super::CityWhereInput {}
    pub struct type_in;
    impl ::cynic::schema::Field for type_in {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "type_in";
    }
    impl ::cynic::schema::HasInputField<type_in, Option<Vec<super::String>>> for super::CityWhereInput {}
    pub struct type_not_in;
    impl ::cynic::schema::Field for type_not_in {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "type_not_in";
    }
    impl ::cynic::schema::HasInputField<type_not_in, Option<Vec<super::String>>>
        for super::CityWhereInput
    {
    }
    pub struct type_lt;
    impl ::cynic::schema::Field for type_lt {
        type Type = Option<super::String>;
        const NAME: &'static str = "type_lt";
    }
    impl ::cynic::schema::HasInputField<type_lt, Option<super::String>> for super::CityWhereInput {}
    pub struct type_lte;
    impl ::cynic::schema::Field for type_lte {
        type Type = Option<super::String>;
        const NAME: &'static str = "type_lte";
    }
    impl ::cynic::schema::HasInputField<type_lte, Option<super::String>> for super::CityWhereInput {}
    pub struct type_gt;
    impl ::cynic::schema::Field for type_gt {
        type Type = Option<super::String>;
        const NAME: &'static str = "type_gt";
    }
    impl ::cynic::schema::HasInputField<type_gt, Option<super::String>> for super::CityWhereInput {}
    pub struct type_gte;
    impl ::cynic::schema::Field for type_gte {
        type Type = Option<super::String>;
        const NAME: &'static str = "type_gte";
    }
    impl ::cynic::schema::HasInputField<type_gte, Option<super::String>> for super::CityWhereInput {}
    pub struct type_contains;
    impl ::cynic::schema::Field for type_contains {
        type Type = Option<super::String>;
        const NAME: &'static str = "type_contains";
    }
    impl ::cynic::schema::HasInputField<type_contains, Option<super::String>>
        for super::CityWhereInput
    {
    }
    pub struct type_not_contains;
    impl ::cynic::schema::Field for type_not_contains {
        type Type = Option<super::String>;
        const NAME: &'static str = "type_not_contains";
    }
    impl ::cynic::schema::HasInputField<type_not_contains, Option<super::String>>
        for super::CityWhereInput
    {
    }
    pub struct type_starts_with;
    impl ::cynic::schema::Field for type_starts_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "type_starts_with";
    }
    impl ::cynic::schema::HasInputField<type_starts_with, Option<super::String>>
        for super::CityWhereInput
    {
    }
    pub struct type_not_starts_with;
    impl ::cynic::schema::Field for type_not_starts_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "type_not_starts_with";
    }
    impl ::cynic::schema::HasInputField<type_not_starts_with, Option<super::String>>
        for super::CityWhereInput
    {
    }
    pub struct type_ends_with;
    impl ::cynic::schema::Field for type_ends_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "type_ends_with";
    }
    impl ::cynic::schema::HasInputField<type_ends_with, Option<super::String>>
        for super::CityWhereInput
    {
    }
    pub struct type_not_ends_with;
    impl ::cynic::schema::Field for type_not_ends_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "type_not_ends_with";
    }
    impl ::cynic::schema::HasInputField<type_not_ends_with, Option<super::String>>
        for super::CityWhereInput
    {
    }
    pub struct jobs_every;
    impl ::cynic::schema::Field for jobs_every {
        type Type = Option<super::JobWhereInput>;
        const NAME: &'static str = "jobs_every";
    }
    impl ::cynic::schema::HasInputField<jobs_every, Option<super::JobWhereInput>>
        for super::CityWhereInput
    {
    }
    pub struct jobs_some;
    impl ::cynic::schema::Field for jobs_some {
        type Type = Option<super::JobWhereInput>;
        const NAME: &'static str = "jobs_some";
    }
    impl ::cynic::schema::HasInputField<jobs_some, Option<super::JobWhereInput>>
        for super::CityWhereInput
    {
    }
    pub struct jobs_none;
    impl ::cynic::schema::Field for jobs_none {
        type Type = Option<super::JobWhereInput>;
        const NAME: &'static str = "jobs_none";
    }
    impl ::cynic::schema::HasInputField<jobs_none, Option<super::JobWhereInput>>
        for super::CityWhereInput
    {
    }
    pub struct createdAt;
    impl ::cynic::schema::Field for createdAt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt";
    }
    impl ::cynic::schema::HasInputField<createdAt, Option<super::DateTime>> for super::CityWhereInput {}
    pub struct createdAt_not;
    impl ::cynic::schema::Field for createdAt_not {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt_not";
    }
    impl ::cynic::schema::HasInputField<createdAt_not, Option<super::DateTime>>
        for super::CityWhereInput
    {
    }
    pub struct createdAt_in;
    impl ::cynic::schema::Field for createdAt_in {
        type Type = Option<Vec<super::DateTime>>;
        const NAME: &'static str = "createdAt_in";
    }
    impl ::cynic::schema::HasInputField<createdAt_in, Option<Vec<super::DateTime>>>
        for super::CityWhereInput
    {
    }
    pub struct createdAt_not_in;
    impl ::cynic::schema::Field for createdAt_not_in {
        type Type = Option<Vec<super::DateTime>>;
        const NAME: &'static str = "createdAt_not_in";
    }
    impl ::cynic::schema::HasInputField<createdAt_not_in, Option<Vec<super::DateTime>>>
        for super::CityWhereInput
    {
    }
    pub struct createdAt_lt;
    impl ::cynic::schema::Field for createdAt_lt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt_lt";
    }
    impl ::cynic::schema::HasInputField<createdAt_lt, Option<super::DateTime>>
        for super::CityWhereInput
    {
    }
    pub struct createdAt_lte;
    impl ::cynic::schema::Field for createdAt_lte {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt_lte";
    }
    impl ::cynic::schema::HasInputField<createdAt_lte, Option<super::DateTime>>
        for super::CityWhereInput
    {
    }
    pub struct createdAt_gt;
    impl ::cynic::schema::Field for createdAt_gt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt_gt";
    }
    impl ::cynic::schema::HasInputField<createdAt_gt, Option<super::DateTime>>
        for super::CityWhereInput
    {
    }
    pub struct createdAt_gte;
    impl ::cynic::schema::Field for createdAt_gte {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt_gte";
    }
    impl ::cynic::schema::HasInputField<createdAt_gte, Option<super::DateTime>>
        for super::CityWhereInput
    {
    }
    pub struct updatedAt;
    impl ::cynic::schema::Field for updatedAt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt";
    }
    impl ::cynic::schema::HasInputField<updatedAt, Option<super::DateTime>> for super::CityWhereInput {}
    pub struct updatedAt_not;
    impl ::cynic::schema::Field for updatedAt_not {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt_not";
    }
    impl ::cynic::schema::HasInputField<updatedAt_not, Option<super::DateTime>>
        for super::CityWhereInput
    {
    }
    pub struct updatedAt_in;
    impl ::cynic::schema::Field for updatedAt_in {
        type Type = Option<Vec<super::DateTime>>;
        const NAME: &'static str = "updatedAt_in";
    }
    impl ::cynic::schema::HasInputField<updatedAt_in, Option<Vec<super::DateTime>>>
        for super::CityWhereInput
    {
    }
    pub struct updatedAt_not_in;
    impl ::cynic::schema::Field for updatedAt_not_in {
        type Type = Option<Vec<super::DateTime>>;
        const NAME: &'static str = "updatedAt_not_in";
    }
    impl ::cynic::schema::HasInputField<updatedAt_not_in, Option<Vec<super::DateTime>>>
        for super::CityWhereInput
    {
    }
    pub struct updatedAt_lt;
    impl ::cynic::schema::Field for updatedAt_lt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt_lt";
    }
    impl ::cynic::schema::HasInputField<updatedAt_lt, Option<super::DateTime>>
        for super::CityWhereInput
    {
    }
    pub struct updatedAt_lte;
    impl ::cynic::schema::Field for updatedAt_lte {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt_lte";
    }
    impl ::cynic::schema::HasInputField<updatedAt_lte, Option<super::DateTime>>
        for super::CityWhereInput
    {
    }
    pub struct updatedAt_gt;
    impl ::cynic::schema::Field for updatedAt_gt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt_gt";
    }
    impl ::cynic::schema::HasInputField<updatedAt_gt, Option<super::DateTime>>
        for super::CityWhereInput
    {
    }
    pub struct updatedAt_gte;
    impl ::cynic::schema::Field for updatedAt_gte {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt_gte";
    }
    impl ::cynic::schema::HasInputField<updatedAt_gte, Option<super::DateTime>>
        for super::CityWhereInput
    {
    }
    pub struct AND;
    impl ::cynic::schema::Field for AND {
        type Type = Option<Vec<super::CityWhereInput>>;
        const NAME: &'static str = "AND";
    }
    impl ::cynic::schema::HasInputField<AND, Option<Vec<super::CityWhereInput>>>
        for super::CityWhereInput
    {
    }
    pub struct OR;
    impl ::cynic::schema::Field for OR {
        type Type = Option<Vec<super::CityWhereInput>>;
        const NAME: &'static str = "OR";
    }
    impl ::cynic::schema::HasInputField<OR, Option<Vec<super::CityWhereInput>>>
        for super::CityWhereInput
    {
    }
    pub struct NOT;
    impl ::cynic::schema::Field for NOT {
        type Type = Option<Vec<super::CityWhereInput>>;
        const NAME: &'static str = "NOT";
    }
    impl ::cynic::schema::HasInputField<NOT, Option<Vec<super::CityWhereInput>>>
        for super::CityWhereInput
    {
    }
}
pub struct Commitment;
pub mod commitment_fields {
    pub struct id;
    impl ::cynic::schema::Field for id {
        type Type = super::ID;
        const NAME: &'static str = "id";
    }
    impl ::cynic::schema::HasField<id> for super::Commitment {
        type Type = super::ID;
    }
    pub struct title;
    impl ::cynic::schema::Field for title {
        type Type = super::String;
        const NAME: &'static str = "title";
    }
    impl ::cynic::schema::HasField<title> for super::Commitment {
        type Type = super::String;
    }
    pub struct slug;
    impl ::cynic::schema::Field for slug {
        type Type = super::String;
        const NAME: &'static str = "slug";
    }
    impl ::cynic::schema::HasField<slug> for super::Commitment {
        type Type = super::String;
    }
    pub struct jobs;
    impl ::cynic::schema::Field for jobs {
        type Type = Option<Vec<super::Job>>;
        const NAME: &'static str = "jobs";
    }
    impl ::cynic::schema::HasField<jobs> for super::Commitment {
        type Type = Option<Vec<super::Job>>;
    }
    pub mod jobs_arguments {
        pub struct r#where;
        impl ::cynic::schema::HasArgument<r#where> for super::jobs {
            type ArgumentType = Option<super::super::JobWhereInput>;
            const NAME: &'static str = "where";
        }
        pub struct orderBy;
        impl ::cynic::schema::HasArgument<orderBy> for super::jobs {
            type ArgumentType = Option<super::super::JobOrderByInput>;
            const NAME: &'static str = "orderBy";
        }
        pub struct skip;
        impl ::cynic::schema::HasArgument<skip> for super::jobs {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "skip";
        }
        pub struct after;
        impl ::cynic::schema::HasArgument<after> for super::jobs {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "after";
        }
        pub struct before;
        impl ::cynic::schema::HasArgument<before> for super::jobs {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "before";
        }
        pub struct first;
        impl ::cynic::schema::HasArgument<first> for super::jobs {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "first";
        }
        pub struct last;
        impl ::cynic::schema::HasArgument<last> for super::jobs {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "last";
        }
    }
    pub struct createdAt;
    impl ::cynic::schema::Field for createdAt {
        type Type = super::DateTime;
        const NAME: &'static str = "createdAt";
    }
    impl ::cynic::schema::HasField<createdAt> for super::Commitment {
        type Type = super::DateTime;
    }
    pub struct updatedAt;
    impl ::cynic::schema::Field for updatedAt {
        type Type = super::DateTime;
        const NAME: &'static str = "updatedAt";
    }
    impl ::cynic::schema::HasField<updatedAt> for super::Commitment {
        type Type = super::DateTime;
    }
}
pub struct CommitmentWhereInput;
impl ::cynic::schema::InputObjectMarker for CommitmentWhereInput {}
pub mod commitment_where_input_fields {
    pub struct id;
    impl ::cynic::schema::Field for id {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id";
    }
    impl ::cynic::schema::HasInputField<id, Option<super::ID>> for super::CommitmentWhereInput {}
    pub struct id_not;
    impl ::cynic::schema::Field for id_not {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_not";
    }
    impl ::cynic::schema::HasInputField<id_not, Option<super::ID>> for super::CommitmentWhereInput {}
    pub struct id_in;
    impl ::cynic::schema::Field for id_in {
        type Type = Option<Vec<super::ID>>;
        const NAME: &'static str = "id_in";
    }
    impl ::cynic::schema::HasInputField<id_in, Option<Vec<super::ID>>> for super::CommitmentWhereInput {}
    pub struct id_not_in;
    impl ::cynic::schema::Field for id_not_in {
        type Type = Option<Vec<super::ID>>;
        const NAME: &'static str = "id_not_in";
    }
    impl ::cynic::schema::HasInputField<id_not_in, Option<Vec<super::ID>>>
        for super::CommitmentWhereInput
    {
    }
    pub struct id_lt;
    impl ::cynic::schema::Field for id_lt {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_lt";
    }
    impl ::cynic::schema::HasInputField<id_lt, Option<super::ID>> for super::CommitmentWhereInput {}
    pub struct id_lte;
    impl ::cynic::schema::Field for id_lte {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_lte";
    }
    impl ::cynic::schema::HasInputField<id_lte, Option<super::ID>> for super::CommitmentWhereInput {}
    pub struct id_gt;
    impl ::cynic::schema::Field for id_gt {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_gt";
    }
    impl ::cynic::schema::HasInputField<id_gt, Option<super::ID>> for super::CommitmentWhereInput {}
    pub struct id_gte;
    impl ::cynic::schema::Field for id_gte {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_gte";
    }
    impl ::cynic::schema::HasInputField<id_gte, Option<super::ID>> for super::CommitmentWhereInput {}
    pub struct id_contains;
    impl ::cynic::schema::Field for id_contains {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_contains";
    }
    impl ::cynic::schema::HasInputField<id_contains, Option<super::ID>>
        for super::CommitmentWhereInput
    {
    }
    pub struct id_not_contains;
    impl ::cynic::schema::Field for id_not_contains {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_not_contains";
    }
    impl ::cynic::schema::HasInputField<id_not_contains, Option<super::ID>>
        for super::CommitmentWhereInput
    {
    }
    pub struct id_starts_with;
    impl ::cynic::schema::Field for id_starts_with {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_starts_with";
    }
    impl ::cynic::schema::HasInputField<id_starts_with, Option<super::ID>>
        for super::CommitmentWhereInput
    {
    }
    pub struct id_not_starts_with;
    impl ::cynic::schema::Field for id_not_starts_with {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_not_starts_with";
    }
    impl ::cynic::schema::HasInputField<id_not_starts_with, Option<super::ID>>
        for super::CommitmentWhereInput
    {
    }
    pub struct id_ends_with;
    impl ::cynic::schema::Field for id_ends_with {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_ends_with";
    }
    impl ::cynic::schema::HasInputField<id_ends_with, Option<super::ID>>
        for super::CommitmentWhereInput
    {
    }
    pub struct id_not_ends_with;
    impl ::cynic::schema::Field for id_not_ends_with {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_not_ends_with";
    }
    impl ::cynic::schema::HasInputField<id_not_ends_with, Option<super::ID>>
        for super::CommitmentWhereInput
    {
    }
    pub struct title;
    impl ::cynic::schema::Field for title {
        type Type = Option<super::String>;
        const NAME: &'static str = "title";
    }
    impl ::cynic::schema::HasInputField<title, Option<super::String>> for super::CommitmentWhereInput {}
    pub struct title_not;
    impl ::cynic::schema::Field for title_not {
        type Type = Option<super::String>;
        const NAME: &'static str = "title_not";
    }
    impl ::cynic::schema::HasInputField<title_not, Option<super::String>>
        for super::CommitmentWhereInput
    {
    }
    pub struct title_in;
    impl ::cynic::schema::Field for title_in {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "title_in";
    }
    impl ::cynic::schema::HasInputField<title_in, Option<Vec<super::String>>>
        for super::CommitmentWhereInput
    {
    }
    pub struct title_not_in;
    impl ::cynic::schema::Field for title_not_in {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "title_not_in";
    }
    impl ::cynic::schema::HasInputField<title_not_in, Option<Vec<super::String>>>
        for super::CommitmentWhereInput
    {
    }
    pub struct title_lt;
    impl ::cynic::schema::Field for title_lt {
        type Type = Option<super::String>;
        const NAME: &'static str = "title_lt";
    }
    impl ::cynic::schema::HasInputField<title_lt, Option<super::String>>
        for super::CommitmentWhereInput
    {
    }
    pub struct title_lte;
    impl ::cynic::schema::Field for title_lte {
        type Type = Option<super::String>;
        const NAME: &'static str = "title_lte";
    }
    impl ::cynic::schema::HasInputField<title_lte, Option<super::String>>
        for super::CommitmentWhereInput
    {
    }
    pub struct title_gt;
    impl ::cynic::schema::Field for title_gt {
        type Type = Option<super::String>;
        const NAME: &'static str = "title_gt";
    }
    impl ::cynic::schema::HasInputField<title_gt, Option<super::String>>
        for super::CommitmentWhereInput
    {
    }
    pub struct title_gte;
    impl ::cynic::schema::Field for title_gte {
        type Type = Option<super::String>;
        const NAME: &'static str = "title_gte";
    }
    impl ::cynic::schema::HasInputField<title_gte, Option<super::String>>
        for super::CommitmentWhereInput
    {
    }
    pub struct title_contains;
    impl ::cynic::schema::Field for title_contains {
        type Type = Option<super::String>;
        const NAME: &'static str = "title_contains";
    }
    impl ::cynic::schema::HasInputField<title_contains, Option<super::String>>
        for super::CommitmentWhereInput
    {
    }
    pub struct title_not_contains;
    impl ::cynic::schema::Field for title_not_contains {
        type Type = Option<super::String>;
        const NAME: &'static str = "title_not_contains";
    }
    impl ::cynic::schema::HasInputField<title_not_contains, Option<super::String>>
        for super::CommitmentWhereInput
    {
    }
    pub struct title_starts_with;
    impl ::cynic::schema::Field for title_starts_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "title_starts_with";
    }
    impl ::cynic::schema::HasInputField<title_starts_with, Option<super::String>>
        for super::CommitmentWhereInput
    {
    }
    pub struct title_not_starts_with;
    impl ::cynic::schema::Field for title_not_starts_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "title_not_starts_with";
    }
    impl ::cynic::schema::HasInputField<title_not_starts_with, Option<super::String>>
        for super::CommitmentWhereInput
    {
    }
    pub struct title_ends_with;
    impl ::cynic::schema::Field for title_ends_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "title_ends_with";
    }
    impl ::cynic::schema::HasInputField<title_ends_with, Option<super::String>>
        for super::CommitmentWhereInput
    {
    }
    pub struct title_not_ends_with;
    impl ::cynic::schema::Field for title_not_ends_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "title_not_ends_with";
    }
    impl ::cynic::schema::HasInputField<title_not_ends_with, Option<super::String>>
        for super::CommitmentWhereInput
    {
    }
    pub struct slug;
    impl ::cynic::schema::Field for slug {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug";
    }
    impl ::cynic::schema::HasInputField<slug, Option<super::String>> for super::CommitmentWhereInput {}
    pub struct slug_not;
    impl ::cynic::schema::Field for slug_not {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_not";
    }
    impl ::cynic::schema::HasInputField<slug_not, Option<super::String>>
        for super::CommitmentWhereInput
    {
    }
    pub struct slug_in;
    impl ::cynic::schema::Field for slug_in {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "slug_in";
    }
    impl ::cynic::schema::HasInputField<slug_in, Option<Vec<super::String>>>
        for super::CommitmentWhereInput
    {
    }
    pub struct slug_not_in;
    impl ::cynic::schema::Field for slug_not_in {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "slug_not_in";
    }
    impl ::cynic::schema::HasInputField<slug_not_in, Option<Vec<super::String>>>
        for super::CommitmentWhereInput
    {
    }
    pub struct slug_lt;
    impl ::cynic::schema::Field for slug_lt {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_lt";
    }
    impl ::cynic::schema::HasInputField<slug_lt, Option<super::String>>
        for super::CommitmentWhereInput
    {
    }
    pub struct slug_lte;
    impl ::cynic::schema::Field for slug_lte {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_lte";
    }
    impl ::cynic::schema::HasInputField<slug_lte, Option<super::String>>
        for super::CommitmentWhereInput
    {
    }
    pub struct slug_gt;
    impl ::cynic::schema::Field for slug_gt {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_gt";
    }
    impl ::cynic::schema::HasInputField<slug_gt, Option<super::String>>
        for super::CommitmentWhereInput
    {
    }
    pub struct slug_gte;
    impl ::cynic::schema::Field for slug_gte {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_gte";
    }
    impl ::cynic::schema::HasInputField<slug_gte, Option<super::String>>
        for super::CommitmentWhereInput
    {
    }
    pub struct slug_contains;
    impl ::cynic::schema::Field for slug_contains {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_contains";
    }
    impl ::cynic::schema::HasInputField<slug_contains, Option<super::String>>
        for super::CommitmentWhereInput
    {
    }
    pub struct slug_not_contains;
    impl ::cynic::schema::Field for slug_not_contains {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_not_contains";
    }
    impl ::cynic::schema::HasInputField<slug_not_contains, Option<super::String>>
        for super::CommitmentWhereInput
    {
    }
    pub struct slug_starts_with;
    impl ::cynic::schema::Field for slug_starts_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_starts_with";
    }
    impl ::cynic::schema::HasInputField<slug_starts_with, Option<super::String>>
        for super::CommitmentWhereInput
    {
    }
    pub struct slug_not_starts_with;
    impl ::cynic::schema::Field for slug_not_starts_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_not_starts_with";
    }
    impl ::cynic::schema::HasInputField<slug_not_starts_with, Option<super::String>>
        for super::CommitmentWhereInput
    {
    }
    pub struct slug_ends_with;
    impl ::cynic::schema::Field for slug_ends_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_ends_with";
    }
    impl ::cynic::schema::HasInputField<slug_ends_with, Option<super::String>>
        for super::CommitmentWhereInput
    {
    }
    pub struct slug_not_ends_with;
    impl ::cynic::schema::Field for slug_not_ends_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_not_ends_with";
    }
    impl ::cynic::schema::HasInputField<slug_not_ends_with, Option<super::String>>
        for super::CommitmentWhereInput
    {
    }
    pub struct jobs_every;
    impl ::cynic::schema::Field for jobs_every {
        type Type = Option<super::JobWhereInput>;
        const NAME: &'static str = "jobs_every";
    }
    impl ::cynic::schema::HasInputField<jobs_every, Option<super::JobWhereInput>>
        for super::CommitmentWhereInput
    {
    }
    pub struct jobs_some;
    impl ::cynic::schema::Field for jobs_some {
        type Type = Option<super::JobWhereInput>;
        const NAME: &'static str = "jobs_some";
    }
    impl ::cynic::schema::HasInputField<jobs_some, Option<super::JobWhereInput>>
        for super::CommitmentWhereInput
    {
    }
    pub struct jobs_none;
    impl ::cynic::schema::Field for jobs_none {
        type Type = Option<super::JobWhereInput>;
        const NAME: &'static str = "jobs_none";
    }
    impl ::cynic::schema::HasInputField<jobs_none, Option<super::JobWhereInput>>
        for super::CommitmentWhereInput
    {
    }
    pub struct createdAt;
    impl ::cynic::schema::Field for createdAt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt";
    }
    impl ::cynic::schema::HasInputField<createdAt, Option<super::DateTime>>
        for super::CommitmentWhereInput
    {
    }
    pub struct createdAt_not;
    impl ::cynic::schema::Field for createdAt_not {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt_not";
    }
    impl ::cynic::schema::HasInputField<createdAt_not, Option<super::DateTime>>
        for super::CommitmentWhereInput
    {
    }
    pub struct createdAt_in;
    impl ::cynic::schema::Field for createdAt_in {
        type Type = Option<Vec<super::DateTime>>;
        const NAME: &'static str = "createdAt_in";
    }
    impl ::cynic::schema::HasInputField<createdAt_in, Option<Vec<super::DateTime>>>
        for super::CommitmentWhereInput
    {
    }
    pub struct createdAt_not_in;
    impl ::cynic::schema::Field for createdAt_not_in {
        type Type = Option<Vec<super::DateTime>>;
        const NAME: &'static str = "createdAt_not_in";
    }
    impl ::cynic::schema::HasInputField<createdAt_not_in, Option<Vec<super::DateTime>>>
        for super::CommitmentWhereInput
    {
    }
    pub struct createdAt_lt;
    impl ::cynic::schema::Field for createdAt_lt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt_lt";
    }
    impl ::cynic::schema::HasInputField<createdAt_lt, Option<super::DateTime>>
        for super::CommitmentWhereInput
    {
    }
    pub struct createdAt_lte;
    impl ::cynic::schema::Field for createdAt_lte {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt_lte";
    }
    impl ::cynic::schema::HasInputField<createdAt_lte, Option<super::DateTime>>
        for super::CommitmentWhereInput
    {
    }
    pub struct createdAt_gt;
    impl ::cynic::schema::Field for createdAt_gt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt_gt";
    }
    impl ::cynic::schema::HasInputField<createdAt_gt, Option<super::DateTime>>
        for super::CommitmentWhereInput
    {
    }
    pub struct createdAt_gte;
    impl ::cynic::schema::Field for createdAt_gte {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt_gte";
    }
    impl ::cynic::schema::HasInputField<createdAt_gte, Option<super::DateTime>>
        for super::CommitmentWhereInput
    {
    }
    pub struct updatedAt;
    impl ::cynic::schema::Field for updatedAt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt";
    }
    impl ::cynic::schema::HasInputField<updatedAt, Option<super::DateTime>>
        for super::CommitmentWhereInput
    {
    }
    pub struct updatedAt_not;
    impl ::cynic::schema::Field for updatedAt_not {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt_not";
    }
    impl ::cynic::schema::HasInputField<updatedAt_not, Option<super::DateTime>>
        for super::CommitmentWhereInput
    {
    }
    pub struct updatedAt_in;
    impl ::cynic::schema::Field for updatedAt_in {
        type Type = Option<Vec<super::DateTime>>;
        const NAME: &'static str = "updatedAt_in";
    }
    impl ::cynic::schema::HasInputField<updatedAt_in, Option<Vec<super::DateTime>>>
        for super::CommitmentWhereInput
    {
    }
    pub struct updatedAt_not_in;
    impl ::cynic::schema::Field for updatedAt_not_in {
        type Type = Option<Vec<super::DateTime>>;
        const NAME: &'static str = "updatedAt_not_in";
    }
    impl ::cynic::schema::HasInputField<updatedAt_not_in, Option<Vec<super::DateTime>>>
        for super::CommitmentWhereInput
    {
    }
    pub struct updatedAt_lt;
    impl ::cynic::schema::Field for updatedAt_lt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt_lt";
    }
    impl ::cynic::schema::HasInputField<updatedAt_lt, Option<super::DateTime>>
        for super::CommitmentWhereInput
    {
    }
    pub struct updatedAt_lte;
    impl ::cynic::schema::Field for updatedAt_lte {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt_lte";
    }
    impl ::cynic::schema::HasInputField<updatedAt_lte, Option<super::DateTime>>
        for super::CommitmentWhereInput
    {
    }
    pub struct updatedAt_gt;
    impl ::cynic::schema::Field for updatedAt_gt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt_gt";
    }
    impl ::cynic::schema::HasInputField<updatedAt_gt, Option<super::DateTime>>
        for super::CommitmentWhereInput
    {
    }
    pub struct updatedAt_gte;
    impl ::cynic::schema::Field for updatedAt_gte {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt_gte";
    }
    impl ::cynic::schema::HasInputField<updatedAt_gte, Option<super::DateTime>>
        for super::CommitmentWhereInput
    {
    }
    pub struct AND;
    impl ::cynic::schema::Field for AND {
        type Type = Option<Vec<super::CommitmentWhereInput>>;
        const NAME: &'static str = "AND";
    }
    impl ::cynic::schema::HasInputField<AND, Option<Vec<super::CommitmentWhereInput>>>
        for super::CommitmentWhereInput
    {
    }
    pub struct OR;
    impl ::cynic::schema::Field for OR {
        type Type = Option<Vec<super::CommitmentWhereInput>>;
        const NAME: &'static str = "OR";
    }
    impl ::cynic::schema::HasInputField<OR, Option<Vec<super::CommitmentWhereInput>>>
        for super::CommitmentWhereInput
    {
    }
    pub struct NOT;
    impl ::cynic::schema::Field for NOT {
        type Type = Option<Vec<super::CommitmentWhereInput>>;
        const NAME: &'static str = "NOT";
    }
    impl ::cynic::schema::HasInputField<NOT, Option<Vec<super::CommitmentWhereInput>>>
        for super::CommitmentWhereInput
    {
    }
}
pub struct Company;
pub mod company_fields {
    pub struct id;
    impl ::cynic::schema::Field for id {
        type Type = super::ID;
        const NAME: &'static str = "id";
    }
    impl ::cynic::schema::HasField<id> for super::Company {
        type Type = super::ID;
    }
    pub struct name;
    impl ::cynic::schema::Field for name {
        type Type = super::String;
        const NAME: &'static str = "name";
    }
    impl ::cynic::schema::HasField<name> for super::Company {
        type Type = super::String;
    }
    pub struct slug;
    impl ::cynic::schema::Field for slug {
        type Type = super::String;
        const NAME: &'static str = "slug";
    }
    impl ::cynic::schema::HasField<slug> for super::Company {
        type Type = super::String;
    }
    pub struct websiteUrl;
    impl ::cynic::schema::Field for websiteUrl {
        type Type = super::String;
        const NAME: &'static str = "websiteUrl";
    }
    impl ::cynic::schema::HasField<websiteUrl> for super::Company {
        type Type = super::String;
    }
    pub struct logoUrl;
    impl ::cynic::schema::Field for logoUrl {
        type Type = Option<super::String>;
        const NAME: &'static str = "logoUrl";
    }
    impl ::cynic::schema::HasField<logoUrl> for super::Company {
        type Type = Option<super::String>;
    }
    pub struct jobs;
    impl ::cynic::schema::Field for jobs {
        type Type = Option<Vec<super::Job>>;
        const NAME: &'static str = "jobs";
    }
    impl ::cynic::schema::HasField<jobs> for super::Company {
        type Type = Option<Vec<super::Job>>;
    }
    pub mod jobs_arguments {
        pub struct r#where;
        impl ::cynic::schema::HasArgument<r#where> for super::jobs {
            type ArgumentType = Option<super::super::JobWhereInput>;
            const NAME: &'static str = "where";
        }
        pub struct orderBy;
        impl ::cynic::schema::HasArgument<orderBy> for super::jobs {
            type ArgumentType = Option<super::super::JobOrderByInput>;
            const NAME: &'static str = "orderBy";
        }
        pub struct skip;
        impl ::cynic::schema::HasArgument<skip> for super::jobs {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "skip";
        }
        pub struct after;
        impl ::cynic::schema::HasArgument<after> for super::jobs {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "after";
        }
        pub struct before;
        impl ::cynic::schema::HasArgument<before> for super::jobs {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "before";
        }
        pub struct first;
        impl ::cynic::schema::HasArgument<first> for super::jobs {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "first";
        }
        pub struct last;
        impl ::cynic::schema::HasArgument<last> for super::jobs {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "last";
        }
    }
    pub struct twitter;
    impl ::cynic::schema::Field for twitter {
        type Type = Option<super::String>;
        const NAME: &'static str = "twitter";
    }
    impl ::cynic::schema::HasField<twitter> for super::Company {
        type Type = Option<super::String>;
    }
    pub struct emailed;
    impl ::cynic::schema::Field for emailed {
        type Type = Option<super::Boolean>;
        const NAME: &'static str = "emailed";
    }
    impl ::cynic::schema::HasField<emailed> for super::Company {
        type Type = Option<super::Boolean>;
    }
    pub struct createdAt;
    impl ::cynic::schema::Field for createdAt {
        type Type = super::DateTime;
        const NAME: &'static str = "createdAt";
    }
    impl ::cynic::schema::HasField<createdAt> for super::Company {
        type Type = super::DateTime;
    }
    pub struct updatedAt;
    impl ::cynic::schema::Field for updatedAt {
        type Type = super::DateTime;
        const NAME: &'static str = "updatedAt";
    }
    impl ::cynic::schema::HasField<updatedAt> for super::Company {
        type Type = super::DateTime;
    }
}
pub struct CompanyWhereInput;
impl ::cynic::schema::InputObjectMarker for CompanyWhereInput {}
pub mod company_where_input_fields {
    pub struct id;
    impl ::cynic::schema::Field for id {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id";
    }
    impl ::cynic::schema::HasInputField<id, Option<super::ID>> for super::CompanyWhereInput {}
    pub struct id_not;
    impl ::cynic::schema::Field for id_not {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_not";
    }
    impl ::cynic::schema::HasInputField<id_not, Option<super::ID>> for super::CompanyWhereInput {}
    pub struct id_in;
    impl ::cynic::schema::Field for id_in {
        type Type = Option<Vec<super::ID>>;
        const NAME: &'static str = "id_in";
    }
    impl ::cynic::schema::HasInputField<id_in, Option<Vec<super::ID>>> for super::CompanyWhereInput {}
    pub struct id_not_in;
    impl ::cynic::schema::Field for id_not_in {
        type Type = Option<Vec<super::ID>>;
        const NAME: &'static str = "id_not_in";
    }
    impl ::cynic::schema::HasInputField<id_not_in, Option<Vec<super::ID>>>
        for super::CompanyWhereInput
    {
    }
    pub struct id_lt;
    impl ::cynic::schema::Field for id_lt {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_lt";
    }
    impl ::cynic::schema::HasInputField<id_lt, Option<super::ID>> for super::CompanyWhereInput {}
    pub struct id_lte;
    impl ::cynic::schema::Field for id_lte {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_lte";
    }
    impl ::cynic::schema::HasInputField<id_lte, Option<super::ID>> for super::CompanyWhereInput {}
    pub struct id_gt;
    impl ::cynic::schema::Field for id_gt {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_gt";
    }
    impl ::cynic::schema::HasInputField<id_gt, Option<super::ID>> for super::CompanyWhereInput {}
    pub struct id_gte;
    impl ::cynic::schema::Field for id_gte {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_gte";
    }
    impl ::cynic::schema::HasInputField<id_gte, Option<super::ID>> for super::CompanyWhereInput {}
    pub struct id_contains;
    impl ::cynic::schema::Field for id_contains {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_contains";
    }
    impl ::cynic::schema::HasInputField<id_contains, Option<super::ID>> for super::CompanyWhereInput {}
    pub struct id_not_contains;
    impl ::cynic::schema::Field for id_not_contains {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_not_contains";
    }
    impl ::cynic::schema::HasInputField<id_not_contains, Option<super::ID>>
        for super::CompanyWhereInput
    {
    }
    pub struct id_starts_with;
    impl ::cynic::schema::Field for id_starts_with {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_starts_with";
    }
    impl ::cynic::schema::HasInputField<id_starts_with, Option<super::ID>>
        for super::CompanyWhereInput
    {
    }
    pub struct id_not_starts_with;
    impl ::cynic::schema::Field for id_not_starts_with {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_not_starts_with";
    }
    impl ::cynic::schema::HasInputField<id_not_starts_with, Option<super::ID>>
        for super::CompanyWhereInput
    {
    }
    pub struct id_ends_with;
    impl ::cynic::schema::Field for id_ends_with {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_ends_with";
    }
    impl ::cynic::schema::HasInputField<id_ends_with, Option<super::ID>> for super::CompanyWhereInput {}
    pub struct id_not_ends_with;
    impl ::cynic::schema::Field for id_not_ends_with {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_not_ends_with";
    }
    impl ::cynic::schema::HasInputField<id_not_ends_with, Option<super::ID>>
        for super::CompanyWhereInput
    {
    }
    pub struct name;
    impl ::cynic::schema::Field for name {
        type Type = Option<super::String>;
        const NAME: &'static str = "name";
    }
    impl ::cynic::schema::HasInputField<name, Option<super::String>> for super::CompanyWhereInput {}
    pub struct name_not;
    impl ::cynic::schema::Field for name_not {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_not";
    }
    impl ::cynic::schema::HasInputField<name_not, Option<super::String>> for super::CompanyWhereInput {}
    pub struct name_in;
    impl ::cynic::schema::Field for name_in {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "name_in";
    }
    impl ::cynic::schema::HasInputField<name_in, Option<Vec<super::String>>>
        for super::CompanyWhereInput
    {
    }
    pub struct name_not_in;
    impl ::cynic::schema::Field for name_not_in {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "name_not_in";
    }
    impl ::cynic::schema::HasInputField<name_not_in, Option<Vec<super::String>>>
        for super::CompanyWhereInput
    {
    }
    pub struct name_lt;
    impl ::cynic::schema::Field for name_lt {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_lt";
    }
    impl ::cynic::schema::HasInputField<name_lt, Option<super::String>> for super::CompanyWhereInput {}
    pub struct name_lte;
    impl ::cynic::schema::Field for name_lte {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_lte";
    }
    impl ::cynic::schema::HasInputField<name_lte, Option<super::String>> for super::CompanyWhereInput {}
    pub struct name_gt;
    impl ::cynic::schema::Field for name_gt {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_gt";
    }
    impl ::cynic::schema::HasInputField<name_gt, Option<super::String>> for super::CompanyWhereInput {}
    pub struct name_gte;
    impl ::cynic::schema::Field for name_gte {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_gte";
    }
    impl ::cynic::schema::HasInputField<name_gte, Option<super::String>> for super::CompanyWhereInput {}
    pub struct name_contains;
    impl ::cynic::schema::Field for name_contains {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_contains";
    }
    impl ::cynic::schema::HasInputField<name_contains, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct name_not_contains;
    impl ::cynic::schema::Field for name_not_contains {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_not_contains";
    }
    impl ::cynic::schema::HasInputField<name_not_contains, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct name_starts_with;
    impl ::cynic::schema::Field for name_starts_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_starts_with";
    }
    impl ::cynic::schema::HasInputField<name_starts_with, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct name_not_starts_with;
    impl ::cynic::schema::Field for name_not_starts_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_not_starts_with";
    }
    impl ::cynic::schema::HasInputField<name_not_starts_with, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct name_ends_with;
    impl ::cynic::schema::Field for name_ends_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_ends_with";
    }
    impl ::cynic::schema::HasInputField<name_ends_with, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct name_not_ends_with;
    impl ::cynic::schema::Field for name_not_ends_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_not_ends_with";
    }
    impl ::cynic::schema::HasInputField<name_not_ends_with, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct slug;
    impl ::cynic::schema::Field for slug {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug";
    }
    impl ::cynic::schema::HasInputField<slug, Option<super::String>> for super::CompanyWhereInput {}
    pub struct slug_not;
    impl ::cynic::schema::Field for slug_not {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_not";
    }
    impl ::cynic::schema::HasInputField<slug_not, Option<super::String>> for super::CompanyWhereInput {}
    pub struct slug_in;
    impl ::cynic::schema::Field for slug_in {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "slug_in";
    }
    impl ::cynic::schema::HasInputField<slug_in, Option<Vec<super::String>>>
        for super::CompanyWhereInput
    {
    }
    pub struct slug_not_in;
    impl ::cynic::schema::Field for slug_not_in {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "slug_not_in";
    }
    impl ::cynic::schema::HasInputField<slug_not_in, Option<Vec<super::String>>>
        for super::CompanyWhereInput
    {
    }
    pub struct slug_lt;
    impl ::cynic::schema::Field for slug_lt {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_lt";
    }
    impl ::cynic::schema::HasInputField<slug_lt, Option<super::String>> for super::CompanyWhereInput {}
    pub struct slug_lte;
    impl ::cynic::schema::Field for slug_lte {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_lte";
    }
    impl ::cynic::schema::HasInputField<slug_lte, Option<super::String>> for super::CompanyWhereInput {}
    pub struct slug_gt;
    impl ::cynic::schema::Field for slug_gt {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_gt";
    }
    impl ::cynic::schema::HasInputField<slug_gt, Option<super::String>> for super::CompanyWhereInput {}
    pub struct slug_gte;
    impl ::cynic::schema::Field for slug_gte {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_gte";
    }
    impl ::cynic::schema::HasInputField<slug_gte, Option<super::String>> for super::CompanyWhereInput {}
    pub struct slug_contains;
    impl ::cynic::schema::Field for slug_contains {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_contains";
    }
    impl ::cynic::schema::HasInputField<slug_contains, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct slug_not_contains;
    impl ::cynic::schema::Field for slug_not_contains {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_not_contains";
    }
    impl ::cynic::schema::HasInputField<slug_not_contains, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct slug_starts_with;
    impl ::cynic::schema::Field for slug_starts_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_starts_with";
    }
    impl ::cynic::schema::HasInputField<slug_starts_with, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct slug_not_starts_with;
    impl ::cynic::schema::Field for slug_not_starts_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_not_starts_with";
    }
    impl ::cynic::schema::HasInputField<slug_not_starts_with, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct slug_ends_with;
    impl ::cynic::schema::Field for slug_ends_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_ends_with";
    }
    impl ::cynic::schema::HasInputField<slug_ends_with, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct slug_not_ends_with;
    impl ::cynic::schema::Field for slug_not_ends_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_not_ends_with";
    }
    impl ::cynic::schema::HasInputField<slug_not_ends_with, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct websiteUrl;
    impl ::cynic::schema::Field for websiteUrl {
        type Type = Option<super::String>;
        const NAME: &'static str = "websiteUrl";
    }
    impl ::cynic::schema::HasInputField<websiteUrl, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct websiteUrl_not;
    impl ::cynic::schema::Field for websiteUrl_not {
        type Type = Option<super::String>;
        const NAME: &'static str = "websiteUrl_not";
    }
    impl ::cynic::schema::HasInputField<websiteUrl_not, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct websiteUrl_in;
    impl ::cynic::schema::Field for websiteUrl_in {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "websiteUrl_in";
    }
    impl ::cynic::schema::HasInputField<websiteUrl_in, Option<Vec<super::String>>>
        for super::CompanyWhereInput
    {
    }
    pub struct websiteUrl_not_in;
    impl ::cynic::schema::Field for websiteUrl_not_in {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "websiteUrl_not_in";
    }
    impl ::cynic::schema::HasInputField<websiteUrl_not_in, Option<Vec<super::String>>>
        for super::CompanyWhereInput
    {
    }
    pub struct websiteUrl_lt;
    impl ::cynic::schema::Field for websiteUrl_lt {
        type Type = Option<super::String>;
        const NAME: &'static str = "websiteUrl_lt";
    }
    impl ::cynic::schema::HasInputField<websiteUrl_lt, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct websiteUrl_lte;
    impl ::cynic::schema::Field for websiteUrl_lte {
        type Type = Option<super::String>;
        const NAME: &'static str = "websiteUrl_lte";
    }
    impl ::cynic::schema::HasInputField<websiteUrl_lte, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct websiteUrl_gt;
    impl ::cynic::schema::Field for websiteUrl_gt {
        type Type = Option<super::String>;
        const NAME: &'static str = "websiteUrl_gt";
    }
    impl ::cynic::schema::HasInputField<websiteUrl_gt, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct websiteUrl_gte;
    impl ::cynic::schema::Field for websiteUrl_gte {
        type Type = Option<super::String>;
        const NAME: &'static str = "websiteUrl_gte";
    }
    impl ::cynic::schema::HasInputField<websiteUrl_gte, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct websiteUrl_contains;
    impl ::cynic::schema::Field for websiteUrl_contains {
        type Type = Option<super::String>;
        const NAME: &'static str = "websiteUrl_contains";
    }
    impl ::cynic::schema::HasInputField<websiteUrl_contains, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct websiteUrl_not_contains;
    impl ::cynic::schema::Field for websiteUrl_not_contains {
        type Type = Option<super::String>;
        const NAME: &'static str = "websiteUrl_not_contains";
    }
    impl ::cynic::schema::HasInputField<websiteUrl_not_contains, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct websiteUrl_starts_with;
    impl ::cynic::schema::Field for websiteUrl_starts_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "websiteUrl_starts_with";
    }
    impl ::cynic::schema::HasInputField<websiteUrl_starts_with, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct websiteUrl_not_starts_with;
    impl ::cynic::schema::Field for websiteUrl_not_starts_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "websiteUrl_not_starts_with";
    }
    impl ::cynic::schema::HasInputField<websiteUrl_not_starts_with, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct websiteUrl_ends_with;
    impl ::cynic::schema::Field for websiteUrl_ends_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "websiteUrl_ends_with";
    }
    impl ::cynic::schema::HasInputField<websiteUrl_ends_with, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct websiteUrl_not_ends_with;
    impl ::cynic::schema::Field for websiteUrl_not_ends_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "websiteUrl_not_ends_with";
    }
    impl ::cynic::schema::HasInputField<websiteUrl_not_ends_with, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct logoUrl;
    impl ::cynic::schema::Field for logoUrl {
        type Type = Option<super::String>;
        const NAME: &'static str = "logoUrl";
    }
    impl ::cynic::schema::HasInputField<logoUrl, Option<super::String>> for super::CompanyWhereInput {}
    pub struct logoUrl_not;
    impl ::cynic::schema::Field for logoUrl_not {
        type Type = Option<super::String>;
        const NAME: &'static str = "logoUrl_not";
    }
    impl ::cynic::schema::HasInputField<logoUrl_not, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct logoUrl_in;
    impl ::cynic::schema::Field for logoUrl_in {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "logoUrl_in";
    }
    impl ::cynic::schema::HasInputField<logoUrl_in, Option<Vec<super::String>>>
        for super::CompanyWhereInput
    {
    }
    pub struct logoUrl_not_in;
    impl ::cynic::schema::Field for logoUrl_not_in {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "logoUrl_not_in";
    }
    impl ::cynic::schema::HasInputField<logoUrl_not_in, Option<Vec<super::String>>>
        for super::CompanyWhereInput
    {
    }
    pub struct logoUrl_lt;
    impl ::cynic::schema::Field for logoUrl_lt {
        type Type = Option<super::String>;
        const NAME: &'static str = "logoUrl_lt";
    }
    impl ::cynic::schema::HasInputField<logoUrl_lt, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct logoUrl_lte;
    impl ::cynic::schema::Field for logoUrl_lte {
        type Type = Option<super::String>;
        const NAME: &'static str = "logoUrl_lte";
    }
    impl ::cynic::schema::HasInputField<logoUrl_lte, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct logoUrl_gt;
    impl ::cynic::schema::Field for logoUrl_gt {
        type Type = Option<super::String>;
        const NAME: &'static str = "logoUrl_gt";
    }
    impl ::cynic::schema::HasInputField<logoUrl_gt, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct logoUrl_gte;
    impl ::cynic::schema::Field for logoUrl_gte {
        type Type = Option<super::String>;
        const NAME: &'static str = "logoUrl_gte";
    }
    impl ::cynic::schema::HasInputField<logoUrl_gte, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct logoUrl_contains;
    impl ::cynic::schema::Field for logoUrl_contains {
        type Type = Option<super::String>;
        const NAME: &'static str = "logoUrl_contains";
    }
    impl ::cynic::schema::HasInputField<logoUrl_contains, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct logoUrl_not_contains;
    impl ::cynic::schema::Field for logoUrl_not_contains {
        type Type = Option<super::String>;
        const NAME: &'static str = "logoUrl_not_contains";
    }
    impl ::cynic::schema::HasInputField<logoUrl_not_contains, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct logoUrl_starts_with;
    impl ::cynic::schema::Field for logoUrl_starts_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "logoUrl_starts_with";
    }
    impl ::cynic::schema::HasInputField<logoUrl_starts_with, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct logoUrl_not_starts_with;
    impl ::cynic::schema::Field for logoUrl_not_starts_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "logoUrl_not_starts_with";
    }
    impl ::cynic::schema::HasInputField<logoUrl_not_starts_with, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct logoUrl_ends_with;
    impl ::cynic::schema::Field for logoUrl_ends_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "logoUrl_ends_with";
    }
    impl ::cynic::schema::HasInputField<logoUrl_ends_with, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct logoUrl_not_ends_with;
    impl ::cynic::schema::Field for logoUrl_not_ends_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "logoUrl_not_ends_with";
    }
    impl ::cynic::schema::HasInputField<logoUrl_not_ends_with, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct jobs_every;
    impl ::cynic::schema::Field for jobs_every {
        type Type = Option<super::JobWhereInput>;
        const NAME: &'static str = "jobs_every";
    }
    impl ::cynic::schema::HasInputField<jobs_every, Option<super::JobWhereInput>>
        for super::CompanyWhereInput
    {
    }
    pub struct jobs_some;
    impl ::cynic::schema::Field for jobs_some {
        type Type = Option<super::JobWhereInput>;
        const NAME: &'static str = "jobs_some";
    }
    impl ::cynic::schema::HasInputField<jobs_some, Option<super::JobWhereInput>>
        for super::CompanyWhereInput
    {
    }
    pub struct jobs_none;
    impl ::cynic::schema::Field for jobs_none {
        type Type = Option<super::JobWhereInput>;
        const NAME: &'static str = "jobs_none";
    }
    impl ::cynic::schema::HasInputField<jobs_none, Option<super::JobWhereInput>>
        for super::CompanyWhereInput
    {
    }
    pub struct twitter;
    impl ::cynic::schema::Field for twitter {
        type Type = Option<super::String>;
        const NAME: &'static str = "twitter";
    }
    impl ::cynic::schema::HasInputField<twitter, Option<super::String>> for super::CompanyWhereInput {}
    pub struct twitter_not;
    impl ::cynic::schema::Field for twitter_not {
        type Type = Option<super::String>;
        const NAME: &'static str = "twitter_not";
    }
    impl ::cynic::schema::HasInputField<twitter_not, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct twitter_in;
    impl ::cynic::schema::Field for twitter_in {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "twitter_in";
    }
    impl ::cynic::schema::HasInputField<twitter_in, Option<Vec<super::String>>>
        for super::CompanyWhereInput
    {
    }
    pub struct twitter_not_in;
    impl ::cynic::schema::Field for twitter_not_in {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "twitter_not_in";
    }
    impl ::cynic::schema::HasInputField<twitter_not_in, Option<Vec<super::String>>>
        for super::CompanyWhereInput
    {
    }
    pub struct twitter_lt;
    impl ::cynic::schema::Field for twitter_lt {
        type Type = Option<super::String>;
        const NAME: &'static str = "twitter_lt";
    }
    impl ::cynic::schema::HasInputField<twitter_lt, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct twitter_lte;
    impl ::cynic::schema::Field for twitter_lte {
        type Type = Option<super::String>;
        const NAME: &'static str = "twitter_lte";
    }
    impl ::cynic::schema::HasInputField<twitter_lte, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct twitter_gt;
    impl ::cynic::schema::Field for twitter_gt {
        type Type = Option<super::String>;
        const NAME: &'static str = "twitter_gt";
    }
    impl ::cynic::schema::HasInputField<twitter_gt, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct twitter_gte;
    impl ::cynic::schema::Field for twitter_gte {
        type Type = Option<super::String>;
        const NAME: &'static str = "twitter_gte";
    }
    impl ::cynic::schema::HasInputField<twitter_gte, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct twitter_contains;
    impl ::cynic::schema::Field for twitter_contains {
        type Type = Option<super::String>;
        const NAME: &'static str = "twitter_contains";
    }
    impl ::cynic::schema::HasInputField<twitter_contains, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct twitter_not_contains;
    impl ::cynic::schema::Field for twitter_not_contains {
        type Type = Option<super::String>;
        const NAME: &'static str = "twitter_not_contains";
    }
    impl ::cynic::schema::HasInputField<twitter_not_contains, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct twitter_starts_with;
    impl ::cynic::schema::Field for twitter_starts_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "twitter_starts_with";
    }
    impl ::cynic::schema::HasInputField<twitter_starts_with, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct twitter_not_starts_with;
    impl ::cynic::schema::Field for twitter_not_starts_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "twitter_not_starts_with";
    }
    impl ::cynic::schema::HasInputField<twitter_not_starts_with, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct twitter_ends_with;
    impl ::cynic::schema::Field for twitter_ends_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "twitter_ends_with";
    }
    impl ::cynic::schema::HasInputField<twitter_ends_with, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct twitter_not_ends_with;
    impl ::cynic::schema::Field for twitter_not_ends_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "twitter_not_ends_with";
    }
    impl ::cynic::schema::HasInputField<twitter_not_ends_with, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct emailed;
    impl ::cynic::schema::Field for emailed {
        type Type = Option<super::Boolean>;
        const NAME: &'static str = "emailed";
    }
    impl ::cynic::schema::HasInputField<emailed, Option<super::Boolean>> for super::CompanyWhereInput {}
    pub struct emailed_not;
    impl ::cynic::schema::Field for emailed_not {
        type Type = Option<super::Boolean>;
        const NAME: &'static str = "emailed_not";
    }
    impl ::cynic::schema::HasInputField<emailed_not, Option<super::Boolean>>
        for super::CompanyWhereInput
    {
    }
    pub struct createdAt;
    impl ::cynic::schema::Field for createdAt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt";
    }
    impl ::cynic::schema::HasInputField<createdAt, Option<super::DateTime>>
        for super::CompanyWhereInput
    {
    }
    pub struct createdAt_not;
    impl ::cynic::schema::Field for createdAt_not {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt_not";
    }
    impl ::cynic::schema::HasInputField<createdAt_not, Option<super::DateTime>>
        for super::CompanyWhereInput
    {
    }
    pub struct createdAt_in;
    impl ::cynic::schema::Field for createdAt_in {
        type Type = Option<Vec<super::DateTime>>;
        const NAME: &'static str = "createdAt_in";
    }
    impl ::cynic::schema::HasInputField<createdAt_in, Option<Vec<super::DateTime>>>
        for super::CompanyWhereInput
    {
    }
    pub struct createdAt_not_in;
    impl ::cynic::schema::Field for createdAt_not_in {
        type Type = Option<Vec<super::DateTime>>;
        const NAME: &'static str = "createdAt_not_in";
    }
    impl ::cynic::schema::HasInputField<createdAt_not_in, Option<Vec<super::DateTime>>>
        for super::CompanyWhereInput
    {
    }
    pub struct createdAt_lt;
    impl ::cynic::schema::Field for createdAt_lt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt_lt";
    }
    impl ::cynic::schema::HasInputField<createdAt_lt, Option<super::DateTime>>
        for super::CompanyWhereInput
    {
    }
    pub struct createdAt_lte;
    impl ::cynic::schema::Field for createdAt_lte {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt_lte";
    }
    impl ::cynic::schema::HasInputField<createdAt_lte, Option<super::DateTime>>
        for super::CompanyWhereInput
    {
    }
    pub struct createdAt_gt;
    impl ::cynic::schema::Field for createdAt_gt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt_gt";
    }
    impl ::cynic::schema::HasInputField<createdAt_gt, Option<super::DateTime>>
        for super::CompanyWhereInput
    {
    }
    pub struct createdAt_gte;
    impl ::cynic::schema::Field for createdAt_gte {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt_gte";
    }
    impl ::cynic::schema::HasInputField<createdAt_gte, Option<super::DateTime>>
        for super::CompanyWhereInput
    {
    }
    pub struct updatedAt;
    impl ::cynic::schema::Field for updatedAt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt";
    }
    impl ::cynic::schema::HasInputField<updatedAt, Option<super::DateTime>>
        for super::CompanyWhereInput
    {
    }
    pub struct updatedAt_not;
    impl ::cynic::schema::Field for updatedAt_not {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt_not";
    }
    impl ::cynic::schema::HasInputField<updatedAt_not, Option<super::DateTime>>
        for super::CompanyWhereInput
    {
    }
    pub struct updatedAt_in;
    impl ::cynic::schema::Field for updatedAt_in {
        type Type = Option<Vec<super::DateTime>>;
        const NAME: &'static str = "updatedAt_in";
    }
    impl ::cynic::schema::HasInputField<updatedAt_in, Option<Vec<super::DateTime>>>
        for super::CompanyWhereInput
    {
    }
    pub struct updatedAt_not_in;
    impl ::cynic::schema::Field for updatedAt_not_in {
        type Type = Option<Vec<super::DateTime>>;
        const NAME: &'static str = "updatedAt_not_in";
    }
    impl ::cynic::schema::HasInputField<updatedAt_not_in, Option<Vec<super::DateTime>>>
        for super::CompanyWhereInput
    {
    }
    pub struct updatedAt_lt;
    impl ::cynic::schema::Field for updatedAt_lt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt_lt";
    }
    impl ::cynic::schema::HasInputField<updatedAt_lt, Option<super::DateTime>>
        for super::CompanyWhereInput
    {
    }
    pub struct updatedAt_lte;
    impl ::cynic::schema::Field for updatedAt_lte {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt_lte";
    }
    impl ::cynic::schema::HasInputField<updatedAt_lte, Option<super::DateTime>>
        for super::CompanyWhereInput
    {
    }
    pub struct updatedAt_gt;
    impl ::cynic::schema::Field for updatedAt_gt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt_gt";
    }
    impl ::cynic::schema::HasInputField<updatedAt_gt, Option<super::DateTime>>
        for super::CompanyWhereInput
    {
    }
    pub struct updatedAt_gte;
    impl ::cynic::schema::Field for updatedAt_gte {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt_gte";
    }
    impl ::cynic::schema::HasInputField<updatedAt_gte, Option<super::DateTime>>
        for super::CompanyWhereInput
    {
    }
    pub struct AND;
    impl ::cynic::schema::Field for AND {
        type Type = Option<Vec<super::CompanyWhereInput>>;
        const NAME: &'static str = "AND";
    }
    impl ::cynic::schema::HasInputField<AND, Option<Vec<super::CompanyWhereInput>>>
        for super::CompanyWhereInput
    {
    }
    pub struct OR;
    impl ::cynic::schema::Field for OR {
        type Type = Option<Vec<super::CompanyWhereInput>>;
        const NAME: &'static str = "OR";
    }
    impl ::cynic::schema::HasInputField<OR, Option<Vec<super::CompanyWhereInput>>>
        for super::CompanyWhereInput
    {
    }
    pub struct NOT;
    impl ::cynic::schema::Field for NOT {
        type Type = Option<Vec<super::CompanyWhereInput>>;
        const NAME: &'static str = "NOT";
    }
    impl ::cynic::schema::HasInputField<NOT, Option<Vec<super::CompanyWhereInput>>>
        for super::CompanyWhereInput
    {
    }
}
pub struct Country;
pub mod country_fields {
    pub struct id;
    impl ::cynic::schema::Field for id {
        type Type = super::ID;
        const NAME: &'static str = "id";
    }
    impl ::cynic::schema::HasField<id> for super::Country {
        type Type = super::ID;
    }
    pub struct name;
    impl ::cynic::schema::Field for name {
        type Type = super::String;
        const NAME: &'static str = "name";
    }
    impl ::cynic::schema::HasField<name> for super::Country {
        type Type = super::String;
    }
    pub struct slug;
    impl ::cynic::schema::Field for slug {
        type Type = super::String;
        const NAME: &'static str = "slug";
    }
    impl ::cynic::schema::HasField<slug> for super::Country {
        type Type = super::String;
    }
    pub struct r#type;
    impl ::cynic::schema::Field for r#type {
        type Type = super::String;
        const NAME: &'static str = "type";
    }
    impl ::cynic::schema::HasField<r#type> for super::Country {
        type Type = super::String;
    }
    pub struct isoCode;
    impl ::cynic::schema::Field for isoCode {
        type Type = Option<super::String>;
        const NAME: &'static str = "isoCode";
    }
    impl ::cynic::schema::HasField<isoCode> for super::Country {
        type Type = Option<super::String>;
    }
    pub struct cities;
    impl ::cynic::schema::Field for cities {
        type Type = Option<Vec<super::City>>;
        const NAME: &'static str = "cities";
    }
    impl ::cynic::schema::HasField<cities> for super::Country {
        type Type = Option<Vec<super::City>>;
    }
    pub mod cities_arguments {
        pub struct r#where;
        impl ::cynic::schema::HasArgument<r#where> for super::cities {
            type ArgumentType = Option<super::super::CityWhereInput>;
            const NAME: &'static str = "where";
        }
        pub struct orderBy;
        impl ::cynic::schema::HasArgument<orderBy> for super::cities {
            type ArgumentType = Option<super::super::CityOrderByInput>;
            const NAME: &'static str = "orderBy";
        }
        pub struct skip;
        impl ::cynic::schema::HasArgument<skip> for super::cities {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "skip";
        }
        pub struct after;
        impl ::cynic::schema::HasArgument<after> for super::cities {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "after";
        }
        pub struct before;
        impl ::cynic::schema::HasArgument<before> for super::cities {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "before";
        }
        pub struct first;
        impl ::cynic::schema::HasArgument<first> for super::cities {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "first";
        }
        pub struct last;
        impl ::cynic::schema::HasArgument<last> for super::cities {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "last";
        }
    }
    pub struct jobs;
    impl ::cynic::schema::Field for jobs {
        type Type = Option<Vec<super::Job>>;
        const NAME: &'static str = "jobs";
    }
    impl ::cynic::schema::HasField<jobs> for super::Country {
        type Type = Option<Vec<super::Job>>;
    }
    pub mod jobs_arguments {
        pub struct r#where;
        impl ::cynic::schema::HasArgument<r#where> for super::jobs {
            type ArgumentType = Option<super::super::JobWhereInput>;
            const NAME: &'static str = "where";
        }
        pub struct orderBy;
        impl ::cynic::schema::HasArgument<orderBy> for super::jobs {
            type ArgumentType = Option<super::super::JobOrderByInput>;
            const NAME: &'static str = "orderBy";
        }
        pub struct skip;
        impl ::cynic::schema::HasArgument<skip> for super::jobs {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "skip";
        }
        pub struct after;
        impl ::cynic::schema::HasArgument<after> for super::jobs {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "after";
        }
        pub struct before;
        impl ::cynic::schema::HasArgument<before> for super::jobs {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "before";
        }
        pub struct first;
        impl ::cynic::schema::HasArgument<first> for super::jobs {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "first";
        }
        pub struct last;
        impl ::cynic::schema::HasArgument<last> for super::jobs {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "last";
        }
    }
    pub struct createdAt;
    impl ::cynic::schema::Field for createdAt {
        type Type = super::DateTime;
        const NAME: &'static str = "createdAt";
    }
    impl ::cynic::schema::HasField<createdAt> for super::Country {
        type Type = super::DateTime;
    }
    pub struct updatedAt;
    impl ::cynic::schema::Field for updatedAt {
        type Type = super::DateTime;
        const NAME: &'static str = "updatedAt";
    }
    impl ::cynic::schema::HasField<updatedAt> for super::Country {
        type Type = super::DateTime;
    }
}
pub struct CountryOrderByInput {}
pub struct CountryWhereInput;
impl ::cynic::schema::InputObjectMarker for CountryWhereInput {}
pub mod country_where_input_fields {
    pub struct id;
    impl ::cynic::schema::Field for id {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id";
    }
    impl ::cynic::schema::HasInputField<id, Option<super::ID>> for super::CountryWhereInput {}
    pub struct id_not;
    impl ::cynic::schema::Field for id_not {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_not";
    }
    impl ::cynic::schema::HasInputField<id_not, Option<super::ID>> for super::CountryWhereInput {}
    pub struct id_in;
    impl ::cynic::schema::Field for id_in {
        type Type = Option<Vec<super::ID>>;
        const NAME: &'static str = "id_in";
    }
    impl ::cynic::schema::HasInputField<id_in, Option<Vec<super::ID>>> for super::CountryWhereInput {}
    pub struct id_not_in;
    impl ::cynic::schema::Field for id_not_in {
        type Type = Option<Vec<super::ID>>;
        const NAME: &'static str = "id_not_in";
    }
    impl ::cynic::schema::HasInputField<id_not_in, Option<Vec<super::ID>>>
        for super::CountryWhereInput
    {
    }
    pub struct id_lt;
    impl ::cynic::schema::Field for id_lt {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_lt";
    }
    impl ::cynic::schema::HasInputField<id_lt, Option<super::ID>> for super::CountryWhereInput {}
    pub struct id_lte;
    impl ::cynic::schema::Field for id_lte {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_lte";
    }
    impl ::cynic::schema::HasInputField<id_lte, Option<super::ID>> for super::CountryWhereInput {}
    pub struct id_gt;
    impl ::cynic::schema::Field for id_gt {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_gt";
    }
    impl ::cynic::schema::HasInputField<id_gt, Option<super::ID>> for super::CountryWhereInput {}
    pub struct id_gte;
    impl ::cynic::schema::Field for id_gte {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_gte";
    }
    impl ::cynic::schema::HasInputField<id_gte, Option<super::ID>> for super::CountryWhereInput {}
    pub struct id_contains;
    impl ::cynic::schema::Field for id_contains {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_contains";
    }
    impl ::cynic::schema::HasInputField<id_contains, Option<super::ID>> for super::CountryWhereInput {}
    pub struct id_not_contains;
    impl ::cynic::schema::Field for id_not_contains {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_not_contains";
    }
    impl ::cynic::schema::HasInputField<id_not_contains, Option<super::ID>>
        for super::CountryWhereInput
    {
    }
    pub struct id_starts_with;
    impl ::cynic::schema::Field for id_starts_with {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_starts_with";
    }
    impl ::cynic::schema::HasInputField<id_starts_with, Option<super::ID>>
        for super::CountryWhereInput
    {
    }
    pub struct id_not_starts_with;
    impl ::cynic::schema::Field for id_not_starts_with {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_not_starts_with";
    }
    impl ::cynic::schema::HasInputField<id_not_starts_with, Option<super::ID>>
        for super::CountryWhereInput
    {
    }
    pub struct id_ends_with;
    impl ::cynic::schema::Field for id_ends_with {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_ends_with";
    }
    impl ::cynic::schema::HasInputField<id_ends_with, Option<super::ID>> for super::CountryWhereInput {}
    pub struct id_not_ends_with;
    impl ::cynic::schema::Field for id_not_ends_with {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_not_ends_with";
    }
    impl ::cynic::schema::HasInputField<id_not_ends_with, Option<super::ID>>
        for super::CountryWhereInput
    {
    }
    pub struct name;
    impl ::cynic::schema::Field for name {
        type Type = Option<super::String>;
        const NAME: &'static str = "name";
    }
    impl ::cynic::schema::HasInputField<name, Option<super::String>> for super::CountryWhereInput {}
    pub struct name_not;
    impl ::cynic::schema::Field for name_not {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_not";
    }
    impl ::cynic::schema::HasInputField<name_not, Option<super::String>> for super::CountryWhereInput {}
    pub struct name_in;
    impl ::cynic::schema::Field for name_in {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "name_in";
    }
    impl ::cynic::schema::HasInputField<name_in, Option<Vec<super::String>>>
        for super::CountryWhereInput
    {
    }
    pub struct name_not_in;
    impl ::cynic::schema::Field for name_not_in {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "name_not_in";
    }
    impl ::cynic::schema::HasInputField<name_not_in, Option<Vec<super::String>>>
        for super::CountryWhereInput
    {
    }
    pub struct name_lt;
    impl ::cynic::schema::Field for name_lt {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_lt";
    }
    impl ::cynic::schema::HasInputField<name_lt, Option<super::String>> for super::CountryWhereInput {}
    pub struct name_lte;
    impl ::cynic::schema::Field for name_lte {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_lte";
    }
    impl ::cynic::schema::HasInputField<name_lte, Option<super::String>> for super::CountryWhereInput {}
    pub struct name_gt;
    impl ::cynic::schema::Field for name_gt {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_gt";
    }
    impl ::cynic::schema::HasInputField<name_gt, Option<super::String>> for super::CountryWhereInput {}
    pub struct name_gte;
    impl ::cynic::schema::Field for name_gte {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_gte";
    }
    impl ::cynic::schema::HasInputField<name_gte, Option<super::String>> for super::CountryWhereInput {}
    pub struct name_contains;
    impl ::cynic::schema::Field for name_contains {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_contains";
    }
    impl ::cynic::schema::HasInputField<name_contains, Option<super::String>>
        for super::CountryWhereInput
    {
    }
    pub struct name_not_contains;
    impl ::cynic::schema::Field for name_not_contains {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_not_contains";
    }
    impl ::cynic::schema::HasInputField<name_not_contains, Option<super::String>>
        for super::CountryWhereInput
    {
    }
    pub struct name_starts_with;
    impl ::cynic::schema::Field for name_starts_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_starts_with";
    }
    impl ::cynic::schema::HasInputField<name_starts_with, Option<super::String>>
        for super::CountryWhereInput
    {
    }
    pub struct name_not_starts_with;
    impl ::cynic::schema::Field for name_not_starts_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_not_starts_with";
    }
    impl ::cynic::schema::HasInputField<name_not_starts_with, Option<super::String>>
        for super::CountryWhereInput
    {
    }
    pub struct name_ends_with;
    impl ::cynic::schema::Field for name_ends_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_ends_with";
    }
    impl ::cynic::schema::HasInputField<name_ends_with, Option<super::String>>
        for super::CountryWhereInput
    {
    }
    pub struct name_not_ends_with;
    impl ::cynic::schema::Field for name_not_ends_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_not_ends_with";
    }
    impl ::cynic::schema::HasInputField<name_not_ends_with, Option<super::String>>
        for super::CountryWhereInput
    {
    }
    pub struct slug;
    impl ::cynic::schema::Field for slug {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug";
    }
    impl ::cynic::schema::HasInputField<slug, Option<super::String>> for super::CountryWhereInput {}
    pub struct slug_not;
    impl ::cynic::schema::Field for slug_not {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_not";
    }
    impl ::cynic::schema::HasInputField<slug_not, Option<super::String>> for super::CountryWhereInput {}
    pub struct slug_in;
    impl ::cynic::schema::Field for slug_in {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "slug_in";
    }
    impl ::cynic::schema::HasInputField<slug_in, Option<Vec<super::String>>>
        for super::CountryWhereInput
    {
    }
    pub struct slug_not_in;
    impl ::cynic::schema::Field for slug_not_in {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "slug_not_in";
    }
    impl ::cynic::schema::HasInputField<slug_not_in, Option<Vec<super::String>>>
        for super::CountryWhereInput
    {
    }
    pub struct slug_lt;
    impl ::cynic::schema::Field for slug_lt {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_lt";
    }
    impl ::cynic::schema::HasInputField<slug_lt, Option<super::String>> for super::CountryWhereInput {}
    pub struct slug_lte;
    impl ::cynic::schema::Field for slug_lte {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_lte";
    }
    impl ::cynic::schema::HasInputField<slug_lte, Option<super::String>> for super::CountryWhereInput {}
    pub struct slug_gt;
    impl ::cynic::schema::Field for slug_gt {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_gt";
    }
    impl ::cynic::schema::HasInputField<slug_gt, Option<super::String>> for super::CountryWhereInput {}
    pub struct slug_gte;
    impl ::cynic::schema::Field for slug_gte {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_gte";
    }
    impl ::cynic::schema::HasInputField<slug_gte, Option<super::String>> for super::CountryWhereInput {}
    pub struct slug_contains;
    impl ::cynic::schema::Field for slug_contains {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_contains";
    }
    impl ::cynic::schema::HasInputField<slug_contains, Option<super::String>>
        for super::CountryWhereInput
    {
    }
    pub struct slug_not_contains;
    impl ::cynic::schema::Field for slug_not_contains {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_not_contains";
    }
    impl ::cynic::schema::HasInputField<slug_not_contains, Option<super::String>>
        for super::CountryWhereInput
    {
    }
    pub struct slug_starts_with;
    impl ::cynic::schema::Field for slug_starts_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_starts_with";
    }
    impl ::cynic::schema::HasInputField<slug_starts_with, Option<super::String>>
        for super::CountryWhereInput
    {
    }
    pub struct slug_not_starts_with;
    impl ::cynic::schema::Field for slug_not_starts_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_not_starts_with";
    }
    impl ::cynic::schema::HasInputField<slug_not_starts_with, Option<super::String>>
        for super::CountryWhereInput
    {
    }
    pub struct slug_ends_with;
    impl ::cynic::schema::Field for slug_ends_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_ends_with";
    }
    impl ::cynic::schema::HasInputField<slug_ends_with, Option<super::String>>
        for super::CountryWhereInput
    {
    }
    pub struct slug_not_ends_with;
    impl ::cynic::schema::Field for slug_not_ends_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_not_ends_with";
    }
    impl ::cynic::schema::HasInputField<slug_not_ends_with, Option<super::String>>
        for super::CountryWhereInput
    {
    }
    pub struct r#type;
    impl ::cynic::schema::Field for r#type {
        type Type = Option<super::String>;
        const NAME: &'static str = "type";
    }
    impl ::cynic::schema::HasInputField<r#type, Option<super::String>> for super::CountryWhereInput {}
    pub struct type_not;
    impl ::cynic::schema::Field for type_not {
        type Type = Option<super::String>;
        const NAME: &'static str = "type_not";
    }
    impl ::cynic::schema::HasInputField<type_not, Option<super::String>> for super::CountryWhereInput {}
    pub struct type_in;
    impl ::cynic::schema::Field for type_in {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "type_in";
    }
    impl ::cynic::schema::HasInputField<type_in, Option<Vec<super::String>>>
        for super::CountryWhereInput
    {
    }
    pub struct type_not_in;
    impl ::cynic::schema::Field for type_not_in {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "type_not_in";
    }
    impl ::cynic::schema::HasInputField<type_not_in, Option<Vec<super::String>>>
        for super::CountryWhereInput
    {
    }
    pub struct type_lt;
    impl ::cynic::schema::Field for type_lt {
        type Type = Option<super::String>;
        const NAME: &'static str = "type_lt";
    }
    impl ::cynic::schema::HasInputField<type_lt, Option<super::String>> for super::CountryWhereInput {}
    pub struct type_lte;
    impl ::cynic::schema::Field for type_lte {
        type Type = Option<super::String>;
        const NAME: &'static str = "type_lte";
    }
    impl ::cynic::schema::HasInputField<type_lte, Option<super::String>> for super::CountryWhereInput {}
    pub struct type_gt;
    impl ::cynic::schema::Field for type_gt {
        type Type = Option<super::String>;
        const NAME: &'static str = "type_gt";
    }
    impl ::cynic::schema::HasInputField<type_gt, Option<super::String>> for super::CountryWhereInput {}
    pub struct type_gte;
    impl ::cynic::schema::Field for type_gte {
        type Type = Option<super::String>;
        const NAME: &'static str = "type_gte";
    }
    impl ::cynic::schema::HasInputField<type_gte, Option<super::String>> for super::CountryWhereInput {}
    pub struct type_contains;
    impl ::cynic::schema::Field for type_contains {
        type Type = Option<super::String>;
        const NAME: &'static str = "type_contains";
    }
    impl ::cynic::schema::HasInputField<type_contains, Option<super::String>>
        for super::CountryWhereInput
    {
    }
    pub struct type_not_contains;
    impl ::cynic::schema::Field for type_not_contains {
        type Type = Option<super::String>;
        const NAME: &'static str = "type_not_contains";
    }
    impl ::cynic::schema::HasInputField<type_not_contains, Option<super::String>>
        for super::CountryWhereInput
    {
    }
    pub struct type_starts_with;
    impl ::cynic::schema::Field for type_starts_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "type_starts_with";
    }
    impl ::cynic::schema::HasInputField<type_starts_with, Option<super::String>>
        for super::CountryWhereInput
    {
    }
    pub struct type_not_starts_with;
    impl ::cynic::schema::Field for type_not_starts_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "type_not_starts_with";
    }
    impl ::cynic::schema::HasInputField<type_not_starts_with, Option<super::String>>
        for super::CountryWhereInput
    {
    }
    pub struct type_ends_with;
    impl ::cynic::schema::Field for type_ends_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "type_ends_with";
    }
    impl ::cynic::schema::HasInputField<type_ends_with, Option<super::String>>
        for super::CountryWhereInput
    {
    }
    pub struct type_not_ends_with;
    impl ::cynic::schema::Field for type_not_ends_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "type_not_ends_with";
    }
    impl ::cynic::schema::HasInputField<type_not_ends_with, Option<super::String>>
        for super::CountryWhereInput
    {
    }
    pub struct isoCode;
    impl ::cynic::schema::Field for isoCode {
        type Type = Option<super::String>;
        const NAME: &'static str = "isoCode";
    }
    impl ::cynic::schema::HasInputField<isoCode, Option<super::String>> for super::CountryWhereInput {}
    pub struct isoCode_not;
    impl ::cynic::schema::Field for isoCode_not {
        type Type = Option<super::String>;
        const NAME: &'static str = "isoCode_not";
    }
    impl ::cynic::schema::HasInputField<isoCode_not, Option<super::String>>
        for super::CountryWhereInput
    {
    }
    pub struct isoCode_in;
    impl ::cynic::schema::Field for isoCode_in {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "isoCode_in";
    }
    impl ::cynic::schema::HasInputField<isoCode_in, Option<Vec<super::String>>>
        for super::CountryWhereInput
    {
    }
    pub struct isoCode_not_in;
    impl ::cynic::schema::Field for isoCode_not_in {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "isoCode_not_in";
    }
    impl ::cynic::schema::HasInputField<isoCode_not_in, Option<Vec<super::String>>>
        for super::CountryWhereInput
    {
    }
    pub struct isoCode_lt;
    impl ::cynic::schema::Field for isoCode_lt {
        type Type = Option<super::String>;
        const NAME: &'static str = "isoCode_lt";
    }
    impl ::cynic::schema::HasInputField<isoCode_lt, Option<super::String>>
        for super::CountryWhereInput
    {
    }
    pub struct isoCode_lte;
    impl ::cynic::schema::Field for isoCode_lte {
        type Type = Option<super::String>;
        const NAME: &'static str = "isoCode_lte";
    }
    impl ::cynic::schema::HasInputField<isoCode_lte, Option<super::String>>
        for super::CountryWhereInput
    {
    }
    pub struct isoCode_gt;
    impl ::cynic::schema::Field for isoCode_gt {
        type Type = Option<super::String>;
        const NAME: &'static str = "isoCode_gt";
    }
    impl ::cynic::schema::HasInputField<isoCode_gt, Option<super::String>>
        for super::CountryWhereInput
    {
    }
    pub struct isoCode_gte;
    impl ::cynic::schema::Field for isoCode_gte {
        type Type = Option<super::String>;
        const NAME: &'static str = "isoCode_gte";
    }
    impl ::cynic::schema::HasInputField<isoCode_gte, Option<super::String>>
        for super::CountryWhereInput
    {
    }
    pub struct isoCode_contains;
    impl ::cynic::schema::Field for isoCode_contains {
        type Type = Option<super::String>;
        const NAME: &'static str = "isoCode_contains";
    }
    impl ::cynic::schema::HasInputField<isoCode_contains, Option<super::String>>
        for super::CountryWhereInput
    {
    }
    pub struct isoCode_not_contains;
    impl ::cynic::schema::Field for isoCode_not_contains {
        type Type = Option<super::String>;
        const NAME: &'static str = "isoCode_not_contains";
    }
    impl ::cynic::schema::HasInputField<isoCode_not_contains, Option<super::String>>
        for super::CountryWhereInput
    {
    }
    pub struct isoCode_starts_with;
    impl ::cynic::schema::Field for isoCode_starts_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "isoCode_starts_with";
    }
    impl ::cynic::schema::HasInputField<isoCode_starts_with, Option<super::String>>
        for super::CountryWhereInput
    {
    }
    pub struct isoCode_not_starts_with;
    impl ::cynic::schema::Field for isoCode_not_starts_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "isoCode_not_starts_with";
    }
    impl ::cynic::schema::HasInputField<isoCode_not_starts_with, Option<super::String>>
        for super::CountryWhereInput
    {
    }
    pub struct isoCode_ends_with;
    impl ::cynic::schema::Field for isoCode_ends_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "isoCode_ends_with";
    }
    impl ::cynic::schema::HasInputField<isoCode_ends_with, Option<super::String>>
        for super::CountryWhereInput
    {
    }
    pub struct isoCode_not_ends_with;
    impl ::cynic::schema::Field for isoCode_not_ends_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "isoCode_not_ends_with";
    }
    impl ::cynic::schema::HasInputField<isoCode_not_ends_with, Option<super::String>>
        for super::CountryWhereInput
    {
    }
    pub struct cities_every;
    impl ::cynic::schema::Field for cities_every {
        type Type = Option<super::CityWhereInput>;
        const NAME: &'static str = "cities_every";
    }
    impl ::cynic::schema::HasInputField<cities_every, Option<super::CityWhereInput>>
        for super::CountryWhereInput
    {
    }
    pub struct cities_some;
    impl ::cynic::schema::Field for cities_some {
        type Type = Option<super::CityWhereInput>;
        const NAME: &'static str = "cities_some";
    }
    impl ::cynic::schema::HasInputField<cities_some, Option<super::CityWhereInput>>
        for super::CountryWhereInput
    {
    }
    pub struct cities_none;
    impl ::cynic::schema::Field for cities_none {
        type Type = Option<super::CityWhereInput>;
        const NAME: &'static str = "cities_none";
    }
    impl ::cynic::schema::HasInputField<cities_none, Option<super::CityWhereInput>>
        for super::CountryWhereInput
    {
    }
    pub struct jobs_every;
    impl ::cynic::schema::Field for jobs_every {
        type Type = Option<super::JobWhereInput>;
        const NAME: &'static str = "jobs_every";
    }
    impl ::cynic::schema::HasInputField<jobs_every, Option<super::JobWhereInput>>
        for super::CountryWhereInput
    {
    }
    pub struct jobs_some;
    impl ::cynic::schema::Field for jobs_some {
        type Type = Option<super::JobWhereInput>;
        const NAME: &'static str = "jobs_some";
    }
    impl ::cynic::schema::HasInputField<jobs_some, Option<super::JobWhereInput>>
        for super::CountryWhereInput
    {
    }
    pub struct jobs_none;
    impl ::cynic::schema::Field for jobs_none {
        type Type = Option<super::JobWhereInput>;
        const NAME: &'static str = "jobs_none";
    }
    impl ::cynic::schema::HasInputField<jobs_none, Option<super::JobWhereInput>>
        for super::CountryWhereInput
    {
    }
    pub struct createdAt;
    impl ::cynic::schema::Field for createdAt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt";
    }
    impl ::cynic::schema::HasInputField<createdAt, Option<super::DateTime>>
        for super::CountryWhereInput
    {
    }
    pub struct createdAt_not;
    impl ::cynic::schema::Field for createdAt_not {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt_not";
    }
    impl ::cynic::schema::HasInputField<createdAt_not, Option<super::DateTime>>
        for super::CountryWhereInput
    {
    }
    pub struct createdAt_in;
    impl ::cynic::schema::Field for createdAt_in {
        type Type = Option<Vec<super::DateTime>>;
        const NAME: &'static str = "createdAt_in";
    }
    impl ::cynic::schema::HasInputField<createdAt_in, Option<Vec<super::DateTime>>>
        for super::CountryWhereInput
    {
    }
    pub struct createdAt_not_in;
    impl ::cynic::schema::Field for createdAt_not_in {
        type Type = Option<Vec<super::DateTime>>;
        const NAME: &'static str = "createdAt_not_in";
    }
    impl ::cynic::schema::HasInputField<createdAt_not_in, Option<Vec<super::DateTime>>>
        for super::CountryWhereInput
    {
    }
    pub struct createdAt_lt;
    impl ::cynic::schema::Field for createdAt_lt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt_lt";
    }
    impl ::cynic::schema::HasInputField<createdAt_lt, Option<super::DateTime>>
        for super::CountryWhereInput
    {
    }
    pub struct createdAt_lte;
    impl ::cynic::schema::Field for createdAt_lte {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt_lte";
    }
    impl ::cynic::schema::HasInputField<createdAt_lte, Option<super::DateTime>>
        for super::CountryWhereInput
    {
    }
    pub struct createdAt_gt;
    impl ::cynic::schema::Field for createdAt_gt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt_gt";
    }
    impl ::cynic::schema::HasInputField<createdAt_gt, Option<super::DateTime>>
        for super::CountryWhereInput
    {
    }
    pub struct createdAt_gte;
    impl ::cynic::schema::Field for createdAt_gte {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt_gte";
    }
    impl ::cynic::schema::HasInputField<createdAt_gte, Option<super::DateTime>>
        for super::CountryWhereInput
    {
    }
    pub struct updatedAt;
    impl ::cynic::schema::Field for updatedAt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt";
    }
    impl ::cynic::schema::HasInputField<updatedAt, Option<super::DateTime>>
        for super::CountryWhereInput
    {
    }
    pub struct updatedAt_not;
    impl ::cynic::schema::Field for updatedAt_not {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt_not";
    }
    impl ::cynic::schema::HasInputField<updatedAt_not, Option<super::DateTime>>
        for super::CountryWhereInput
    {
    }
    pub struct updatedAt_in;
    impl ::cynic::schema::Field for updatedAt_in {
        type Type = Option<Vec<super::DateTime>>;
        const NAME: &'static str = "updatedAt_in";
    }
    impl ::cynic::schema::HasInputField<updatedAt_in, Option<Vec<super::DateTime>>>
        for super::CountryWhereInput
    {
    }
    pub struct updatedAt_not_in;
    impl ::cynic::schema::Field for updatedAt_not_in {
        type Type = Option<Vec<super::DateTime>>;
        const NAME: &'static str = "updatedAt_not_in";
    }
    impl ::cynic::schema::HasInputField<updatedAt_not_in, Option<Vec<super::DateTime>>>
        for super::CountryWhereInput
    {
    }
    pub struct updatedAt_lt;
    impl ::cynic::schema::Field for updatedAt_lt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt_lt";
    }
    impl ::cynic::schema::HasInputField<updatedAt_lt, Option<super::DateTime>>
        for super::CountryWhereInput
    {
    }
    pub struct updatedAt_lte;
    impl ::cynic::schema::Field for updatedAt_lte {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt_lte";
    }
    impl ::cynic::schema::HasInputField<updatedAt_lte, Option<super::DateTime>>
        for super::CountryWhereInput
    {
    }
    pub struct updatedAt_gt;
    impl ::cynic::schema::Field for updatedAt_gt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt_gt";
    }
    impl ::cynic::schema::HasInputField<updatedAt_gt, Option<super::DateTime>>
        for super::CountryWhereInput
    {
    }
    pub struct updatedAt_gte;
    impl ::cynic::schema::Field for updatedAt_gte {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt_gte";
    }
    impl ::cynic::schema::HasInputField<updatedAt_gte, Option<super::DateTime>>
        for super::CountryWhereInput
    {
    }
    pub struct AND;
    impl ::cynic::schema::Field for AND {
        type Type = Option<Vec<super::CountryWhereInput>>;
        const NAME: &'static str = "AND";
    }
    impl ::cynic::schema::HasInputField<AND, Option<Vec<super::CountryWhereInput>>>
        for super::CountryWhereInput
    {
    }
    pub struct OR;
    impl ::cynic::schema::Field for OR {
        type Type = Option<Vec<super::CountryWhereInput>>;
        const NAME: &'static str = "OR";
    }
    impl ::cynic::schema::HasInputField<OR, Option<Vec<super::CountryWhereInput>>>
        for super::CountryWhereInput
    {
    }
    pub struct NOT;
    impl ::cynic::schema::Field for NOT {
        type Type = Option<Vec<super::CountryWhereInput>>;
        const NAME: &'static str = "NOT";
    }
    impl ::cynic::schema::HasInputField<NOT, Option<Vec<super::CountryWhereInput>>>
        for super::CountryWhereInput
    {
    }
}
pub struct DateTime {}
impl ::cynic::schema::NamedType for DateTime {
    const NAME: &'static str = "DateTime";
}
pub struct Job;
pub mod job_fields {
    pub struct id;
    impl ::cynic::schema::Field for id {
        type Type = super::ID;
        const NAME: &'static str = "id";
    }
    impl ::cynic::schema::HasField<id> for super::Job {
        type Type = super::ID;
    }
    pub struct title;
    impl ::cynic::schema::Field for title {
        type Type = super::String;
        const NAME: &'static str = "title";
    }
    impl ::cynic::schema::HasField<title> for super::Job {
        type Type = super::String;
    }
    pub struct slug;
    impl ::cynic::schema::Field for slug {
        type Type = super::String;
        const NAME: &'static str = "slug";
    }
    impl ::cynic::schema::HasField<slug> for super::Job {
        type Type = super::String;
    }
    pub struct commitment;
    impl ::cynic::schema::Field for commitment {
        type Type = super::Commitment;
        const NAME: &'static str = "commitment";
    }
    impl ::cynic::schema::HasField<commitment> for super::Job {
        type Type = super::Commitment;
    }
    pub struct cities;
    impl ::cynic::schema::Field for cities {
        type Type = Option<Vec<super::City>>;
        const NAME: &'static str = "cities";
    }
    impl ::cynic::schema::HasField<cities> for super::Job {
        type Type = Option<Vec<super::City>>;
    }
    pub mod cities_arguments {
        pub struct r#where;
        impl ::cynic::schema::HasArgument<r#where> for super::cities {
            type ArgumentType = Option<super::super::CityWhereInput>;
            const NAME: &'static str = "where";
        }
        pub struct orderBy;
        impl ::cynic::schema::HasArgument<orderBy> for super::cities {
            type ArgumentType = Option<super::super::CityOrderByInput>;
            const NAME: &'static str = "orderBy";
        }
        pub struct skip;
        impl ::cynic::schema::HasArgument<skip> for super::cities {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "skip";
        }
        pub struct after;
        impl ::cynic::schema::HasArgument<after> for super::cities {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "after";
        }
        pub struct before;
        impl ::cynic::schema::HasArgument<before> for super::cities {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "before";
        }
        pub struct first;
        impl ::cynic::schema::HasArgument<first> for super::cities {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "first";
        }
        pub struct last;
        impl ::cynic::schema::HasArgument<last> for super::cities {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "last";
        }
    }
    pub struct countries;
    impl ::cynic::schema::Field for countries {
        type Type = Option<Vec<super::Country>>;
        const NAME: &'static str = "countries";
    }
    impl ::cynic::schema::HasField<countries> for super::Job {
        type Type = Option<Vec<super::Country>>;
    }
    pub mod countries_arguments {
        pub struct r#where;
        impl ::cynic::schema::HasArgument<r#where> for super::countries {
            type ArgumentType = Option<super::super::CountryWhereInput>;
            const NAME: &'static str = "where";
        }
        pub struct orderBy;
        impl ::cynic::schema::HasArgument<orderBy> for super::countries {
            type ArgumentType = Option<super::super::CountryOrderByInput>;
            const NAME: &'static str = "orderBy";
        }
        pub struct skip;
        impl ::cynic::schema::HasArgument<skip> for super::countries {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "skip";
        }
        pub struct after;
        impl ::cynic::schema::HasArgument<after> for super::countries {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "after";
        }
        pub struct before;
        impl ::cynic::schema::HasArgument<before> for super::countries {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "before";
        }
        pub struct first;
        impl ::cynic::schema::HasArgument<first> for super::countries {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "first";
        }
        pub struct last;
        impl ::cynic::schema::HasArgument<last> for super::countries {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "last";
        }
    }
    pub struct remotes;
    impl ::cynic::schema::Field for remotes {
        type Type = Option<Vec<super::Remote>>;
        const NAME: &'static str = "remotes";
    }
    impl ::cynic::schema::HasField<remotes> for super::Job {
        type Type = Option<Vec<super::Remote>>;
    }
    pub mod remotes_arguments {
        pub struct r#where;
        impl ::cynic::schema::HasArgument<r#where> for super::remotes {
            type ArgumentType = Option<super::super::RemoteWhereInput>;
            const NAME: &'static str = "where";
        }
        pub struct orderBy;
        impl ::cynic::schema::HasArgument<orderBy> for super::remotes {
            type ArgumentType = Option<super::super::RemoteOrderByInput>;
            const NAME: &'static str = "orderBy";
        }
        pub struct skip;
        impl ::cynic::schema::HasArgument<skip> for super::remotes {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "skip";
        }
        pub struct after;
        impl ::cynic::schema::HasArgument<after> for super::remotes {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "after";
        }
        pub struct before;
        impl ::cynic::schema::HasArgument<before> for super::remotes {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "before";
        }
        pub struct first;
        impl ::cynic::schema::HasArgument<first> for super::remotes {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "first";
        }
        pub struct last;
        impl ::cynic::schema::HasArgument<last> for super::remotes {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "last";
        }
    }
    pub struct description;
    impl ::cynic::schema::Field for description {
        type Type = Option<super::String>;
        const NAME: &'static str = "description";
    }
    impl ::cynic::schema::HasField<description> for super::Job {
        type Type = Option<super::String>;
    }
    pub struct applyUrl;
    impl ::cynic::schema::Field for applyUrl {
        type Type = Option<super::String>;
        const NAME: &'static str = "applyUrl";
    }
    impl ::cynic::schema::HasField<applyUrl> for super::Job {
        type Type = Option<super::String>;
    }
    pub struct company;
    impl ::cynic::schema::Field for company {
        type Type = Option<super::Company>;
        const NAME: &'static str = "company";
    }
    impl ::cynic::schema::HasField<company> for super::Job {
        type Type = Option<super::Company>;
    }
    pub struct tags;
    impl ::cynic::schema::Field for tags {
        type Type = Option<Vec<super::Tag>>;
        const NAME: &'static str = "tags";
    }
    impl ::cynic::schema::HasField<tags> for super::Job {
        type Type = Option<Vec<super::Tag>>;
    }
    pub mod tags_arguments {
        pub struct r#where;
        impl ::cynic::schema::HasArgument<r#where> for super::tags {
            type ArgumentType = Option<super::super::TagWhereInput>;
            const NAME: &'static str = "where";
        }
        pub struct orderBy;
        impl ::cynic::schema::HasArgument<orderBy> for super::tags {
            type ArgumentType = Option<super::super::TagOrderByInput>;
            const NAME: &'static str = "orderBy";
        }
        pub struct skip;
        impl ::cynic::schema::HasArgument<skip> for super::tags {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "skip";
        }
        pub struct after;
        impl ::cynic::schema::HasArgument<after> for super::tags {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "after";
        }
        pub struct before;
        impl ::cynic::schema::HasArgument<before> for super::tags {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "before";
        }
        pub struct first;
        impl ::cynic::schema::HasArgument<first> for super::tags {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "first";
        }
        pub struct last;
        impl ::cynic::schema::HasArgument<last> for super::tags {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "last";
        }
    }
    pub struct isPublished;
    impl ::cynic::schema::Field for isPublished {
        type Type = Option<super::Boolean>;
        const NAME: &'static str = "isPublished";
    }
    impl ::cynic::schema::HasField<isPublished> for super::Job {
        type Type = Option<super::Boolean>;
    }
    pub struct isFeatured;
    impl ::cynic::schema::Field for isFeatured {
        type Type = Option<super::Boolean>;
        const NAME: &'static str = "isFeatured";
    }
    impl ::cynic::schema::HasField<isFeatured> for super::Job {
        type Type = Option<super::Boolean>;
    }
    pub struct locationNames;
    impl ::cynic::schema::Field for locationNames {
        type Type = Option<super::String>;
        const NAME: &'static str = "locationNames";
    }
    impl ::cynic::schema::HasField<locationNames> for super::Job {
        type Type = Option<super::String>;
    }
    pub struct userEmail;
    impl ::cynic::schema::Field for userEmail {
        type Type = Option<super::String>;
        const NAME: &'static str = "userEmail";
    }
    impl ::cynic::schema::HasField<userEmail> for super::Job {
        type Type = Option<super::String>;
    }
    pub struct postedAt;
    impl ::cynic::schema::Field for postedAt {
        type Type = super::DateTime;
        const NAME: &'static str = "postedAt";
    }
    impl ::cynic::schema::HasField<postedAt> for super::Job {
        type Type = super::DateTime;
    }
    pub struct createdAt;
    impl ::cynic::schema::Field for createdAt {
        type Type = super::DateTime;
        const NAME: &'static str = "createdAt";
    }
    impl ::cynic::schema::HasField<createdAt> for super::Job {
        type Type = super::DateTime;
    }
    pub struct updatedAt;
    impl ::cynic::schema::Field for updatedAt {
        type Type = super::DateTime;
        const NAME: &'static str = "updatedAt";
    }
    impl ::cynic::schema::HasField<updatedAt> for super::Job {
        type Type = super::DateTime;
    }
}
pub struct JobInput;
impl ::cynic::schema::InputObjectMarker for JobInput {}
pub mod job_input_fields {
    pub struct companySlug;
    impl ::cynic::schema::Field for companySlug {
        type Type = super::String;
        const NAME: &'static str = "companySlug";
    }
    impl ::cynic::schema::HasInputField<companySlug, super::String> for super::JobInput {}
    pub struct jobSlug;
    impl ::cynic::schema::Field for jobSlug {
        type Type = super::String;
        const NAME: &'static str = "jobSlug";
    }
    impl ::cynic::schema::HasInputField<jobSlug, super::String> for super::JobInput {}
}
pub struct JobOrderByInput {}
pub struct JobWhereInput;
impl ::cynic::schema::InputObjectMarker for JobWhereInput {}
pub mod job_where_input_fields {
    pub struct id;
    impl ::cynic::schema::Field for id {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id";
    }
    impl ::cynic::schema::HasInputField<id, Option<super::ID>> for super::JobWhereInput {}
    pub struct id_not;
    impl ::cynic::schema::Field for id_not {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_not";
    }
    impl ::cynic::schema::HasInputField<id_not, Option<super::ID>> for super::JobWhereInput {}
    pub struct id_in;
    impl ::cynic::schema::Field for id_in {
        type Type = Option<Vec<super::ID>>;
        const NAME: &'static str = "id_in";
    }
    impl ::cynic::schema::HasInputField<id_in, Option<Vec<super::ID>>> for super::JobWhereInput {}
    pub struct id_not_in;
    impl ::cynic::schema::Field for id_not_in {
        type Type = Option<Vec<super::ID>>;
        const NAME: &'static str = "id_not_in";
    }
    impl ::cynic::schema::HasInputField<id_not_in, Option<Vec<super::ID>>> for super::JobWhereInput {}
    pub struct id_lt;
    impl ::cynic::schema::Field for id_lt {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_lt";
    }
    impl ::cynic::schema::HasInputField<id_lt, Option<super::ID>> for super::JobWhereInput {}
    pub struct id_lte;
    impl ::cynic::schema::Field for id_lte {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_lte";
    }
    impl ::cynic::schema::HasInputField<id_lte, Option<super::ID>> for super::JobWhereInput {}
    pub struct id_gt;
    impl ::cynic::schema::Field for id_gt {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_gt";
    }
    impl ::cynic::schema::HasInputField<id_gt, Option<super::ID>> for super::JobWhereInput {}
    pub struct id_gte;
    impl ::cynic::schema::Field for id_gte {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_gte";
    }
    impl ::cynic::schema::HasInputField<id_gte, Option<super::ID>> for super::JobWhereInput {}
    pub struct id_contains;
    impl ::cynic::schema::Field for id_contains {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_contains";
    }
    impl ::cynic::schema::HasInputField<id_contains, Option<super::ID>> for super::JobWhereInput {}
    pub struct id_not_contains;
    impl ::cynic::schema::Field for id_not_contains {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_not_contains";
    }
    impl ::cynic::schema::HasInputField<id_not_contains, Option<super::ID>> for super::JobWhereInput {}
    pub struct id_starts_with;
    impl ::cynic::schema::Field for id_starts_with {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_starts_with";
    }
    impl ::cynic::schema::HasInputField<id_starts_with, Option<super::ID>> for super::JobWhereInput {}
    pub struct id_not_starts_with;
    impl ::cynic::schema::Field for id_not_starts_with {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_not_starts_with";
    }
    impl ::cynic::schema::HasInputField<id_not_starts_with, Option<super::ID>>
        for super::JobWhereInput
    {
    }
    pub struct id_ends_with;
    impl ::cynic::schema::Field for id_ends_with {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_ends_with";
    }
    impl ::cynic::schema::HasInputField<id_ends_with, Option<super::ID>> for super::JobWhereInput {}
    pub struct id_not_ends_with;
    impl ::cynic::schema::Field for id_not_ends_with {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_not_ends_with";
    }
    impl ::cynic::schema::HasInputField<id_not_ends_with, Option<super::ID>> for super::JobWhereInput {}
    pub struct title;
    impl ::cynic::schema::Field for title {
        type Type = Option<super::String>;
        const NAME: &'static str = "title";
    }
    impl ::cynic::schema::HasInputField<title, Option<super::String>> for super::JobWhereInput {}
    pub struct title_not;
    impl ::cynic::schema::Field for title_not {
        type Type = Option<super::String>;
        const NAME: &'static str = "title_not";
    }
    impl ::cynic::schema::HasInputField<title_not, Option<super::String>> for super::JobWhereInput {}
    pub struct title_in;
    impl ::cynic::schema::Field for title_in {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "title_in";
    }
    impl ::cynic::schema::HasInputField<title_in, Option<Vec<super::String>>> for super::JobWhereInput {}
    pub struct title_not_in;
    impl ::cynic::schema::Field for title_not_in {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "title_not_in";
    }
    impl ::cynic::schema::HasInputField<title_not_in, Option<Vec<super::String>>>
        for super::JobWhereInput
    {
    }
    pub struct title_lt;
    impl ::cynic::schema::Field for title_lt {
        type Type = Option<super::String>;
        const NAME: &'static str = "title_lt";
    }
    impl ::cynic::schema::HasInputField<title_lt, Option<super::String>> for super::JobWhereInput {}
    pub struct title_lte;
    impl ::cynic::schema::Field for title_lte {
        type Type = Option<super::String>;
        const NAME: &'static str = "title_lte";
    }
    impl ::cynic::schema::HasInputField<title_lte, Option<super::String>> for super::JobWhereInput {}
    pub struct title_gt;
    impl ::cynic::schema::Field for title_gt {
        type Type = Option<super::String>;
        const NAME: &'static str = "title_gt";
    }
    impl ::cynic::schema::HasInputField<title_gt, Option<super::String>> for super::JobWhereInput {}
    pub struct title_gte;
    impl ::cynic::schema::Field for title_gte {
        type Type = Option<super::String>;
        const NAME: &'static str = "title_gte";
    }
    impl ::cynic::schema::HasInputField<title_gte, Option<super::String>> for super::JobWhereInput {}
    pub struct title_contains;
    impl ::cynic::schema::Field for title_contains {
        type Type = Option<super::String>;
        const NAME: &'static str = "title_contains";
    }
    impl ::cynic::schema::HasInputField<title_contains, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct title_not_contains;
    impl ::cynic::schema::Field for title_not_contains {
        type Type = Option<super::String>;
        const NAME: &'static str = "title_not_contains";
    }
    impl ::cynic::schema::HasInputField<title_not_contains, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct title_starts_with;
    impl ::cynic::schema::Field for title_starts_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "title_starts_with";
    }
    impl ::cynic::schema::HasInputField<title_starts_with, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct title_not_starts_with;
    impl ::cynic::schema::Field for title_not_starts_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "title_not_starts_with";
    }
    impl ::cynic::schema::HasInputField<title_not_starts_with, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct title_ends_with;
    impl ::cynic::schema::Field for title_ends_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "title_ends_with";
    }
    impl ::cynic::schema::HasInputField<title_ends_with, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct title_not_ends_with;
    impl ::cynic::schema::Field for title_not_ends_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "title_not_ends_with";
    }
    impl ::cynic::schema::HasInputField<title_not_ends_with, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct slug;
    impl ::cynic::schema::Field for slug {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug";
    }
    impl ::cynic::schema::HasInputField<slug, Option<super::String>> for super::JobWhereInput {}
    pub struct slug_not;
    impl ::cynic::schema::Field for slug_not {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_not";
    }
    impl ::cynic::schema::HasInputField<slug_not, Option<super::String>> for super::JobWhereInput {}
    pub struct slug_in;
    impl ::cynic::schema::Field for slug_in {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "slug_in";
    }
    impl ::cynic::schema::HasInputField<slug_in, Option<Vec<super::String>>> for super::JobWhereInput {}
    pub struct slug_not_in;
    impl ::cynic::schema::Field for slug_not_in {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "slug_not_in";
    }
    impl ::cynic::schema::HasInputField<slug_not_in, Option<Vec<super::String>>>
        for super::JobWhereInput
    {
    }
    pub struct slug_lt;
    impl ::cynic::schema::Field for slug_lt {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_lt";
    }
    impl ::cynic::schema::HasInputField<slug_lt, Option<super::String>> for super::JobWhereInput {}
    pub struct slug_lte;
    impl ::cynic::schema::Field for slug_lte {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_lte";
    }
    impl ::cynic::schema::HasInputField<slug_lte, Option<super::String>> for super::JobWhereInput {}
    pub struct slug_gt;
    impl ::cynic::schema::Field for slug_gt {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_gt";
    }
    impl ::cynic::schema::HasInputField<slug_gt, Option<super::String>> for super::JobWhereInput {}
    pub struct slug_gte;
    impl ::cynic::schema::Field for slug_gte {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_gte";
    }
    impl ::cynic::schema::HasInputField<slug_gte, Option<super::String>> for super::JobWhereInput {}
    pub struct slug_contains;
    impl ::cynic::schema::Field for slug_contains {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_contains";
    }
    impl ::cynic::schema::HasInputField<slug_contains, Option<super::String>> for super::JobWhereInput {}
    pub struct slug_not_contains;
    impl ::cynic::schema::Field for slug_not_contains {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_not_contains";
    }
    impl ::cynic::schema::HasInputField<slug_not_contains, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct slug_starts_with;
    impl ::cynic::schema::Field for slug_starts_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_starts_with";
    }
    impl ::cynic::schema::HasInputField<slug_starts_with, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct slug_not_starts_with;
    impl ::cynic::schema::Field for slug_not_starts_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_not_starts_with";
    }
    impl ::cynic::schema::HasInputField<slug_not_starts_with, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct slug_ends_with;
    impl ::cynic::schema::Field for slug_ends_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_ends_with";
    }
    impl ::cynic::schema::HasInputField<slug_ends_with, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct slug_not_ends_with;
    impl ::cynic::schema::Field for slug_not_ends_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_not_ends_with";
    }
    impl ::cynic::schema::HasInputField<slug_not_ends_with, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct commitment;
    impl ::cynic::schema::Field for commitment {
        type Type = Option<super::CommitmentWhereInput>;
        const NAME: &'static str = "commitment";
    }
    impl ::cynic::schema::HasInputField<commitment, Option<super::CommitmentWhereInput>>
        for super::JobWhereInput
    {
    }
    pub struct cities_every;
    impl ::cynic::schema::Field for cities_every {
        type Type = Option<super::CityWhereInput>;
        const NAME: &'static str = "cities_every";
    }
    impl ::cynic::schema::HasInputField<cities_every, Option<super::CityWhereInput>>
        for super::JobWhereInput
    {
    }
    pub struct cities_some;
    impl ::cynic::schema::Field for cities_some {
        type Type = Option<super::CityWhereInput>;
        const NAME: &'static str = "cities_some";
    }
    impl ::cynic::schema::HasInputField<cities_some, Option<super::CityWhereInput>>
        for super::JobWhereInput
    {
    }
    pub struct cities_none;
    impl ::cynic::schema::Field for cities_none {
        type Type = Option<super::CityWhereInput>;
        const NAME: &'static str = "cities_none";
    }
    impl ::cynic::schema::HasInputField<cities_none, Option<super::CityWhereInput>>
        for super::JobWhereInput
    {
    }
    pub struct countries_every;
    impl ::cynic::schema::Field for countries_every {
        type Type = Option<super::CountryWhereInput>;
        const NAME: &'static str = "countries_every";
    }
    impl ::cynic::schema::HasInputField<countries_every, Option<super::CountryWhereInput>>
        for super::JobWhereInput
    {
    }
    pub struct countries_some;
    impl ::cynic::schema::Field for countries_some {
        type Type = Option<super::CountryWhereInput>;
        const NAME: &'static str = "countries_some";
    }
    impl ::cynic::schema::HasInputField<countries_some, Option<super::CountryWhereInput>>
        for super::JobWhereInput
    {
    }
    pub struct countries_none;
    impl ::cynic::schema::Field for countries_none {
        type Type = Option<super::CountryWhereInput>;
        const NAME: &'static str = "countries_none";
    }
    impl ::cynic::schema::HasInputField<countries_none, Option<super::CountryWhereInput>>
        for super::JobWhereInput
    {
    }
    pub struct remotes_every;
    impl ::cynic::schema::Field for remotes_every {
        type Type = Option<super::RemoteWhereInput>;
        const NAME: &'static str = "remotes_every";
    }
    impl ::cynic::schema::HasInputField<remotes_every, Option<super::RemoteWhereInput>>
        for super::JobWhereInput
    {
    }
    pub struct remotes_some;
    impl ::cynic::schema::Field for remotes_some {
        type Type = Option<super::RemoteWhereInput>;
        const NAME: &'static str = "remotes_some";
    }
    impl ::cynic::schema::HasInputField<remotes_some, Option<super::RemoteWhereInput>>
        for super::JobWhereInput
    {
    }
    pub struct remotes_none;
    impl ::cynic::schema::Field for remotes_none {
        type Type = Option<super::RemoteWhereInput>;
        const NAME: &'static str = "remotes_none";
    }
    impl ::cynic::schema::HasInputField<remotes_none, Option<super::RemoteWhereInput>>
        for super::JobWhereInput
    {
    }
    pub struct description;
    impl ::cynic::schema::Field for description {
        type Type = Option<super::String>;
        const NAME: &'static str = "description";
    }
    impl ::cynic::schema::HasInputField<description, Option<super::String>> for super::JobWhereInput {}
    pub struct description_not;
    impl ::cynic::schema::Field for description_not {
        type Type = Option<super::String>;
        const NAME: &'static str = "description_not";
    }
    impl ::cynic::schema::HasInputField<description_not, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct description_in;
    impl ::cynic::schema::Field for description_in {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "description_in";
    }
    impl ::cynic::schema::HasInputField<description_in, Option<Vec<super::String>>>
        for super::JobWhereInput
    {
    }
    pub struct description_not_in;
    impl ::cynic::schema::Field for description_not_in {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "description_not_in";
    }
    impl ::cynic::schema::HasInputField<description_not_in, Option<Vec<super::String>>>
        for super::JobWhereInput
    {
    }
    pub struct description_lt;
    impl ::cynic::schema::Field for description_lt {
        type Type = Option<super::String>;
        const NAME: &'static str = "description_lt";
    }
    impl ::cynic::schema::HasInputField<description_lt, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct description_lte;
    impl ::cynic::schema::Field for description_lte {
        type Type = Option<super::String>;
        const NAME: &'static str = "description_lte";
    }
    impl ::cynic::schema::HasInputField<description_lte, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct description_gt;
    impl ::cynic::schema::Field for description_gt {
        type Type = Option<super::String>;
        const NAME: &'static str = "description_gt";
    }
    impl ::cynic::schema::HasInputField<description_gt, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct description_gte;
    impl ::cynic::schema::Field for description_gte {
        type Type = Option<super::String>;
        const NAME: &'static str = "description_gte";
    }
    impl ::cynic::schema::HasInputField<description_gte, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct description_contains;
    impl ::cynic::schema::Field for description_contains {
        type Type = Option<super::String>;
        const NAME: &'static str = "description_contains";
    }
    impl ::cynic::schema::HasInputField<description_contains, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct description_not_contains;
    impl ::cynic::schema::Field for description_not_contains {
        type Type = Option<super::String>;
        const NAME: &'static str = "description_not_contains";
    }
    impl ::cynic::schema::HasInputField<description_not_contains, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct description_starts_with;
    impl ::cynic::schema::Field for description_starts_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "description_starts_with";
    }
    impl ::cynic::schema::HasInputField<description_starts_with, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct description_not_starts_with;
    impl ::cynic::schema::Field for description_not_starts_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "description_not_starts_with";
    }
    impl ::cynic::schema::HasInputField<description_not_starts_with, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct description_ends_with;
    impl ::cynic::schema::Field for description_ends_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "description_ends_with";
    }
    impl ::cynic::schema::HasInputField<description_ends_with, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct description_not_ends_with;
    impl ::cynic::schema::Field for description_not_ends_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "description_not_ends_with";
    }
    impl ::cynic::schema::HasInputField<description_not_ends_with, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct applyUrl;
    impl ::cynic::schema::Field for applyUrl {
        type Type = Option<super::String>;
        const NAME: &'static str = "applyUrl";
    }
    impl ::cynic::schema::HasInputField<applyUrl, Option<super::String>> for super::JobWhereInput {}
    pub struct applyUrl_not;
    impl ::cynic::schema::Field for applyUrl_not {
        type Type = Option<super::String>;
        const NAME: &'static str = "applyUrl_not";
    }
    impl ::cynic::schema::HasInputField<applyUrl_not, Option<super::String>> for super::JobWhereInput {}
    pub struct applyUrl_in;
    impl ::cynic::schema::Field for applyUrl_in {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "applyUrl_in";
    }
    impl ::cynic::schema::HasInputField<applyUrl_in, Option<Vec<super::String>>>
        for super::JobWhereInput
    {
    }
    pub struct applyUrl_not_in;
    impl ::cynic::schema::Field for applyUrl_not_in {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "applyUrl_not_in";
    }
    impl ::cynic::schema::HasInputField<applyUrl_not_in, Option<Vec<super::String>>>
        for super::JobWhereInput
    {
    }
    pub struct applyUrl_lt;
    impl ::cynic::schema::Field for applyUrl_lt {
        type Type = Option<super::String>;
        const NAME: &'static str = "applyUrl_lt";
    }
    impl ::cynic::schema::HasInputField<applyUrl_lt, Option<super::String>> for super::JobWhereInput {}
    pub struct applyUrl_lte;
    impl ::cynic::schema::Field for applyUrl_lte {
        type Type = Option<super::String>;
        const NAME: &'static str = "applyUrl_lte";
    }
    impl ::cynic::schema::HasInputField<applyUrl_lte, Option<super::String>> for super::JobWhereInput {}
    pub struct applyUrl_gt;
    impl ::cynic::schema::Field for applyUrl_gt {
        type Type = Option<super::String>;
        const NAME: &'static str = "applyUrl_gt";
    }
    impl ::cynic::schema::HasInputField<applyUrl_gt, Option<super::String>> for super::JobWhereInput {}
    pub struct applyUrl_gte;
    impl ::cynic::schema::Field for applyUrl_gte {
        type Type = Option<super::String>;
        const NAME: &'static str = "applyUrl_gte";
    }
    impl ::cynic::schema::HasInputField<applyUrl_gte, Option<super::String>> for super::JobWhereInput {}
    pub struct applyUrl_contains;
    impl ::cynic::schema::Field for applyUrl_contains {
        type Type = Option<super::String>;
        const NAME: &'static str = "applyUrl_contains";
    }
    impl ::cynic::schema::HasInputField<applyUrl_contains, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct applyUrl_not_contains;
    impl ::cynic::schema::Field for applyUrl_not_contains {
        type Type = Option<super::String>;
        const NAME: &'static str = "applyUrl_not_contains";
    }
    impl ::cynic::schema::HasInputField<applyUrl_not_contains, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct applyUrl_starts_with;
    impl ::cynic::schema::Field for applyUrl_starts_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "applyUrl_starts_with";
    }
    impl ::cynic::schema::HasInputField<applyUrl_starts_with, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct applyUrl_not_starts_with;
    impl ::cynic::schema::Field for applyUrl_not_starts_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "applyUrl_not_starts_with";
    }
    impl ::cynic::schema::HasInputField<applyUrl_not_starts_with, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct applyUrl_ends_with;
    impl ::cynic::schema::Field for applyUrl_ends_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "applyUrl_ends_with";
    }
    impl ::cynic::schema::HasInputField<applyUrl_ends_with, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct applyUrl_not_ends_with;
    impl ::cynic::schema::Field for applyUrl_not_ends_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "applyUrl_not_ends_with";
    }
    impl ::cynic::schema::HasInputField<applyUrl_not_ends_with, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct company;
    impl ::cynic::schema::Field for company {
        type Type = Option<super::CompanyWhereInput>;
        const NAME: &'static str = "company";
    }
    impl ::cynic::schema::HasInputField<company, Option<super::CompanyWhereInput>>
        for super::JobWhereInput
    {
    }
    pub struct tags_every;
    impl ::cynic::schema::Field for tags_every {
        type Type = Option<super::TagWhereInput>;
        const NAME: &'static str = "tags_every";
    }
    impl ::cynic::schema::HasInputField<tags_every, Option<super::TagWhereInput>>
        for super::JobWhereInput
    {
    }
    pub struct tags_some;
    impl ::cynic::schema::Field for tags_some {
        type Type = Option<super::TagWhereInput>;
        const NAME: &'static str = "tags_some";
    }
    impl ::cynic::schema::HasInputField<tags_some, Option<super::TagWhereInput>>
        for super::JobWhereInput
    {
    }
    pub struct tags_none;
    impl ::cynic::schema::Field for tags_none {
        type Type = Option<super::TagWhereInput>;
        const NAME: &'static str = "tags_none";
    }
    impl ::cynic::schema::HasInputField<tags_none, Option<super::TagWhereInput>>
        for super::JobWhereInput
    {
    }
    pub struct isPublished;
    impl ::cynic::schema::Field for isPublished {
        type Type = Option<super::Boolean>;
        const NAME: &'static str = "isPublished";
    }
    impl ::cynic::schema::HasInputField<isPublished, Option<super::Boolean>> for super::JobWhereInput {}
    pub struct isPublished_not;
    impl ::cynic::schema::Field for isPublished_not {
        type Type = Option<super::Boolean>;
        const NAME: &'static str = "isPublished_not";
    }
    impl ::cynic::schema::HasInputField<isPublished_not, Option<super::Boolean>>
        for super::JobWhereInput
    {
    }
    pub struct isFeatured;
    impl ::cynic::schema::Field for isFeatured {
        type Type = Option<super::Boolean>;
        const NAME: &'static str = "isFeatured";
    }
    impl ::cynic::schema::HasInputField<isFeatured, Option<super::Boolean>> for super::JobWhereInput {}
    pub struct isFeatured_not;
    impl ::cynic::schema::Field for isFeatured_not {
        type Type = Option<super::Boolean>;
        const NAME: &'static str = "isFeatured_not";
    }
    impl ::cynic::schema::HasInputField<isFeatured_not, Option<super::Boolean>>
        for super::JobWhereInput
    {
    }
    pub struct locationNames;
    impl ::cynic::schema::Field for locationNames {
        type Type = Option<super::String>;
        const NAME: &'static str = "locationNames";
    }
    impl ::cynic::schema::HasInputField<locationNames, Option<super::String>> for super::JobWhereInput {}
    pub struct locationNames_not;
    impl ::cynic::schema::Field for locationNames_not {
        type Type = Option<super::String>;
        const NAME: &'static str = "locationNames_not";
    }
    impl ::cynic::schema::HasInputField<locationNames_not, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct locationNames_in;
    impl ::cynic::schema::Field for locationNames_in {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "locationNames_in";
    }
    impl ::cynic::schema::HasInputField<locationNames_in, Option<Vec<super::String>>>
        for super::JobWhereInput
    {
    }
    pub struct locationNames_not_in;
    impl ::cynic::schema::Field for locationNames_not_in {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "locationNames_not_in";
    }
    impl ::cynic::schema::HasInputField<locationNames_not_in, Option<Vec<super::String>>>
        for super::JobWhereInput
    {
    }
    pub struct locationNames_lt;
    impl ::cynic::schema::Field for locationNames_lt {
        type Type = Option<super::String>;
        const NAME: &'static str = "locationNames_lt";
    }
    impl ::cynic::schema::HasInputField<locationNames_lt, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct locationNames_lte;
    impl ::cynic::schema::Field for locationNames_lte {
        type Type = Option<super::String>;
        const NAME: &'static str = "locationNames_lte";
    }
    impl ::cynic::schema::HasInputField<locationNames_lte, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct locationNames_gt;
    impl ::cynic::schema::Field for locationNames_gt {
        type Type = Option<super::String>;
        const NAME: &'static str = "locationNames_gt";
    }
    impl ::cynic::schema::HasInputField<locationNames_gt, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct locationNames_gte;
    impl ::cynic::schema::Field for locationNames_gte {
        type Type = Option<super::String>;
        const NAME: &'static str = "locationNames_gte";
    }
    impl ::cynic::schema::HasInputField<locationNames_gte, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct locationNames_contains;
    impl ::cynic::schema::Field for locationNames_contains {
        type Type = Option<super::String>;
        const NAME: &'static str = "locationNames_contains";
    }
    impl ::cynic::schema::HasInputField<locationNames_contains, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct locationNames_not_contains;
    impl ::cynic::schema::Field for locationNames_not_contains {
        type Type = Option<super::String>;
        const NAME: &'static str = "locationNames_not_contains";
    }
    impl ::cynic::schema::HasInputField<locationNames_not_contains, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct locationNames_starts_with;
    impl ::cynic::schema::Field for locationNames_starts_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "locationNames_starts_with";
    }
    impl ::cynic::schema::HasInputField<locationNames_starts_with, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct locationNames_not_starts_with;
    impl ::cynic::schema::Field for locationNames_not_starts_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "locationNames_not_starts_with";
    }
    impl ::cynic::schema::HasInputField<locationNames_not_starts_with, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct locationNames_ends_with;
    impl ::cynic::schema::Field for locationNames_ends_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "locationNames_ends_with";
    }
    impl ::cynic::schema::HasInputField<locationNames_ends_with, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct locationNames_not_ends_with;
    impl ::cynic::schema::Field for locationNames_not_ends_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "locationNames_not_ends_with";
    }
    impl ::cynic::schema::HasInputField<locationNames_not_ends_with, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct userEmail;
    impl ::cynic::schema::Field for userEmail {
        type Type = Option<super::String>;
        const NAME: &'static str = "userEmail";
    }
    impl ::cynic::schema::HasInputField<userEmail, Option<super::String>> for super::JobWhereInput {}
    pub struct userEmail_not;
    impl ::cynic::schema::Field for userEmail_not {
        type Type = Option<super::String>;
        const NAME: &'static str = "userEmail_not";
    }
    impl ::cynic::schema::HasInputField<userEmail_not, Option<super::String>> for super::JobWhereInput {}
    pub struct userEmail_in;
    impl ::cynic::schema::Field for userEmail_in {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "userEmail_in";
    }
    impl ::cynic::schema::HasInputField<userEmail_in, Option<Vec<super::String>>>
        for super::JobWhereInput
    {
    }
    pub struct userEmail_not_in;
    impl ::cynic::schema::Field for userEmail_not_in {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "userEmail_not_in";
    }
    impl ::cynic::schema::HasInputField<userEmail_not_in, Option<Vec<super::String>>>
        for super::JobWhereInput
    {
    }
    pub struct userEmail_lt;
    impl ::cynic::schema::Field for userEmail_lt {
        type Type = Option<super::String>;
        const NAME: &'static str = "userEmail_lt";
    }
    impl ::cynic::schema::HasInputField<userEmail_lt, Option<super::String>> for super::JobWhereInput {}
    pub struct userEmail_lte;
    impl ::cynic::schema::Field for userEmail_lte {
        type Type = Option<super::String>;
        const NAME: &'static str = "userEmail_lte";
    }
    impl ::cynic::schema::HasInputField<userEmail_lte, Option<super::String>> for super::JobWhereInput {}
    pub struct userEmail_gt;
    impl ::cynic::schema::Field for userEmail_gt {
        type Type = Option<super::String>;
        const NAME: &'static str = "userEmail_gt";
    }
    impl ::cynic::schema::HasInputField<userEmail_gt, Option<super::String>> for super::JobWhereInput {}
    pub struct userEmail_gte;
    impl ::cynic::schema::Field for userEmail_gte {
        type Type = Option<super::String>;
        const NAME: &'static str = "userEmail_gte";
    }
    impl ::cynic::schema::HasInputField<userEmail_gte, Option<super::String>> for super::JobWhereInput {}
    pub struct userEmail_contains;
    impl ::cynic::schema::Field for userEmail_contains {
        type Type = Option<super::String>;
        const NAME: &'static str = "userEmail_contains";
    }
    impl ::cynic::schema::HasInputField<userEmail_contains, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct userEmail_not_contains;
    impl ::cynic::schema::Field for userEmail_not_contains {
        type Type = Option<super::String>;
        const NAME: &'static str = "userEmail_not_contains";
    }
    impl ::cynic::schema::HasInputField<userEmail_not_contains, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct userEmail_starts_with;
    impl ::cynic::schema::Field for userEmail_starts_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "userEmail_starts_with";
    }
    impl ::cynic::schema::HasInputField<userEmail_starts_with, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct userEmail_not_starts_with;
    impl ::cynic::schema::Field for userEmail_not_starts_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "userEmail_not_starts_with";
    }
    impl ::cynic::schema::HasInputField<userEmail_not_starts_with, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct userEmail_ends_with;
    impl ::cynic::schema::Field for userEmail_ends_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "userEmail_ends_with";
    }
    impl ::cynic::schema::HasInputField<userEmail_ends_with, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct userEmail_not_ends_with;
    impl ::cynic::schema::Field for userEmail_not_ends_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "userEmail_not_ends_with";
    }
    impl ::cynic::schema::HasInputField<userEmail_not_ends_with, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct postedAt;
    impl ::cynic::schema::Field for postedAt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "postedAt";
    }
    impl ::cynic::schema::HasInputField<postedAt, Option<super::DateTime>> for super::JobWhereInput {}
    pub struct postedAt_not;
    impl ::cynic::schema::Field for postedAt_not {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "postedAt_not";
    }
    impl ::cynic::schema::HasInputField<postedAt_not, Option<super::DateTime>>
        for super::JobWhereInput
    {
    }
    pub struct postedAt_in;
    impl ::cynic::schema::Field for postedAt_in {
        type Type = Option<Vec<super::DateTime>>;
        const NAME: &'static str = "postedAt_in";
    }
    impl ::cynic::schema::HasInputField<postedAt_in, Option<Vec<super::DateTime>>>
        for super::JobWhereInput
    {
    }
    pub struct postedAt_not_in;
    impl ::cynic::schema::Field for postedAt_not_in {
        type Type = Option<Vec<super::DateTime>>;
        const NAME: &'static str = "postedAt_not_in";
    }
    impl ::cynic::schema::HasInputField<postedAt_not_in, Option<Vec<super::DateTime>>>
        for super::JobWhereInput
    {
    }
    pub struct postedAt_lt;
    impl ::cynic::schema::Field for postedAt_lt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "postedAt_lt";
    }
    impl ::cynic::schema::HasInputField<postedAt_lt, Option<super::DateTime>> for super::JobWhereInput {}
    pub struct postedAt_lte;
    impl ::cynic::schema::Field for postedAt_lte {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "postedAt_lte";
    }
    impl ::cynic::schema::HasInputField<postedAt_lte, Option<super::DateTime>>
        for super::JobWhereInput
    {
    }
    pub struct postedAt_gt;
    impl ::cynic::schema::Field for postedAt_gt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "postedAt_gt";
    }
    impl ::cynic::schema::HasInputField<postedAt_gt, Option<super::DateTime>> for super::JobWhereInput {}
    pub struct postedAt_gte;
    impl ::cynic::schema::Field for postedAt_gte {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "postedAt_gte";
    }
    impl ::cynic::schema::HasInputField<postedAt_gte, Option<super::DateTime>>
        for super::JobWhereInput
    {
    }
    pub struct createdAt;
    impl ::cynic::schema::Field for createdAt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt";
    }
    impl ::cynic::schema::HasInputField<createdAt, Option<super::DateTime>> for super::JobWhereInput {}
    pub struct createdAt_not;
    impl ::cynic::schema::Field for createdAt_not {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt_not";
    }
    impl ::cynic::schema::HasInputField<createdAt_not, Option<super::DateTime>>
        for super::JobWhereInput
    {
    }
    pub struct createdAt_in;
    impl ::cynic::schema::Field for createdAt_in {
        type Type = Option<Vec<super::DateTime>>;
        const NAME: &'static str = "createdAt_in";
    }
    impl ::cynic::schema::HasInputField<createdAt_in, Option<Vec<super::DateTime>>>
        for super::JobWhereInput
    {
    }
    pub struct createdAt_not_in;
    impl ::cynic::schema::Field for createdAt_not_in {
        type Type = Option<Vec<super::DateTime>>;
        const NAME: &'static str = "createdAt_not_in";
    }
    impl ::cynic::schema::HasInputField<createdAt_not_in, Option<Vec<super::DateTime>>>
        for super::JobWhereInput
    {
    }
    pub struct createdAt_lt;
    impl ::cynic::schema::Field for createdAt_lt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt_lt";
    }
    impl ::cynic::schema::HasInputField<createdAt_lt, Option<super::DateTime>>
        for super::JobWhereInput
    {
    }
    pub struct createdAt_lte;
    impl ::cynic::schema::Field for createdAt_lte {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt_lte";
    }
    impl ::cynic::schema::HasInputField<createdAt_lte, Option<super::DateTime>>
        for super::JobWhereInput
    {
    }
    pub struct createdAt_gt;
    impl ::cynic::schema::Field for createdAt_gt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt_gt";
    }
    impl ::cynic::schema::HasInputField<createdAt_gt, Option<super::DateTime>>
        for super::JobWhereInput
    {
    }
    pub struct createdAt_gte;
    impl ::cynic::schema::Field for createdAt_gte {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt_gte";
    }
    impl ::cynic::schema::HasInputField<createdAt_gte, Option<super::DateTime>>
        for super::JobWhereInput
    {
    }
    pub struct updatedAt;
    impl ::cynic::schema::Field for updatedAt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt";
    }
    impl ::cynic::schema::HasInputField<updatedAt, Option<super::DateTime>> for super::JobWhereInput {}
    pub struct updatedAt_not;
    impl ::cynic::schema::Field for updatedAt_not {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt_not";
    }
    impl ::cynic::schema::HasInputField<updatedAt_not, Option<super::DateTime>>
        for super::JobWhereInput
    {
    }
    pub struct updatedAt_in;
    impl ::cynic::schema::Field for updatedAt_in {
        type Type = Option<Vec<super::DateTime>>;
        const NAME: &'static str = "updatedAt_in";
    }
    impl ::cynic::schema::HasInputField<updatedAt_in, Option<Vec<super::DateTime>>>
        for super::JobWhereInput
    {
    }
    pub struct updatedAt_not_in;
    impl ::cynic::schema::Field for updatedAt_not_in {
        type Type = Option<Vec<super::DateTime>>;
        const NAME: &'static str = "updatedAt_not_in";
    }
    impl ::cynic::schema::HasInputField<updatedAt_not_in, Option<Vec<super::DateTime>>>
        for super::JobWhereInput
    {
    }
    pub struct updatedAt_lt;
    impl ::cynic::schema::Field for updatedAt_lt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt_lt";
    }
    impl ::cynic::schema::HasInputField<updatedAt_lt, Option<super::DateTime>>
        for super::JobWhereInput
    {
    }
    pub struct updatedAt_lte;
    impl ::cynic::schema::Field for updatedAt_lte {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt_lte";
    }
    impl ::cynic::schema::HasInputField<updatedAt_lte, Option<super::DateTime>>
        for super::JobWhereInput
    {
    }
    pub struct updatedAt_gt;
    impl ::cynic::schema::Field for updatedAt_gt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt_gt";
    }
    impl ::cynic::schema::HasInputField<updatedAt_gt, Option<super::DateTime>>
        for super::JobWhereInput
    {
    }
    pub struct updatedAt_gte;
    impl ::cynic::schema::Field for updatedAt_gte {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt_gte";
    }
    impl ::cynic::schema::HasInputField<updatedAt_gte, Option<super::DateTime>>
        for super::JobWhereInput
    {
    }
    pub struct AND;
    impl ::cynic::schema::Field for AND {
        type Type = Option<Vec<super::JobWhereInput>>;
        const NAME: &'static str = "AND";
    }
    impl ::cynic::schema::HasInputField<AND, Option<Vec<super::JobWhereInput>>>
        for super::JobWhereInput
    {
    }
    pub struct OR;
    impl ::cynic::schema::Field for OR {
        type Type = Option<Vec<super::JobWhereInput>>;
        const NAME: &'static str = "OR";
    }
    impl ::cynic::schema::HasInputField<OR, Option<Vec<super::JobWhereInput>>>
        for super::JobWhereInput
    {
    }
    pub struct NOT;
    impl ::cynic::schema::Field for NOT {
        type Type = Option<Vec<super::JobWhereInput>>;
        const NAME: &'static str = "NOT";
    }
    impl ::cynic::schema::HasInputField<NOT, Option<Vec<super::JobWhereInput>>>
        for super::JobWhereInput
    {
    }
}
pub struct JobsInput;
impl ::cynic::schema::InputObjectMarker for JobsInput {}
pub mod jobs_input_fields {
    pub struct r#type;
    impl ::cynic::schema::Field for r#type {
        type Type = Option<super::String>;
        const NAME: &'static str = "type";
    }
    impl ::cynic::schema::HasInputField<r#type, Option<super::String>> for super::JobsInput {}
    pub struct slug;
    impl ::cynic::schema::Field for slug {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug";
    }
    impl ::cynic::schema::HasInputField<slug, Option<super::String>> for super::JobsInput {}
}
pub struct Location;
pub mod location_fields {
    pub struct id;
    impl ::cynic::schema::Field for id {
        type Type = super::ID;
        const NAME: &'static str = "id";
    }
    impl ::cynic::schema::HasField<id> for super::Location {
        type Type = super::ID;
    }
    pub struct slug;
    impl ::cynic::schema::Field for slug {
        type Type = super::String;
        const NAME: &'static str = "slug";
    }
    impl ::cynic::schema::HasField<slug> for super::Location {
        type Type = super::String;
    }
    pub struct name;
    impl ::cynic::schema::Field for name {
        type Type = super::String;
        const NAME: &'static str = "name";
    }
    impl ::cynic::schema::HasField<name> for super::Location {
        type Type = super::String;
    }
    pub struct r#type;
    impl ::cynic::schema::Field for r#type {
        type Type = super::String;
        const NAME: &'static str = "type";
    }
    impl ::cynic::schema::HasField<r#type> for super::Location {
        type Type = super::String;
    }
}
pub struct LocationInput;
impl ::cynic::schema::InputObjectMarker for LocationInput {}
pub mod location_input_fields {
    pub struct slug;
    impl ::cynic::schema::Field for slug {
        type Type = super::String;
        const NAME: &'static str = "slug";
    }
    impl ::cynic::schema::HasInputField<slug, super::String> for super::LocationInput {}
}
pub struct LocationsInput;
impl ::cynic::schema::InputObjectMarker for LocationsInput {}
pub mod locations_input_fields {
    pub struct value;
    impl ::cynic::schema::Field for value {
        type Type = super::String;
        const NAME: &'static str = "value";
    }
    impl ::cynic::schema::HasInputField<value, super::String> for super::LocationsInput {}
}
pub struct Mutation;
pub mod mutation_fields {
    pub struct subscribe;
    impl ::cynic::schema::Field for subscribe {
        type Type = super::User;
        const NAME: &'static str = "subscribe";
    }
    impl ::cynic::schema::HasField<subscribe> for super::Mutation {
        type Type = super::User;
    }
    pub mod subscribe_arguments {
        pub struct input;
        impl ::cynic::schema::HasArgument<input> for super::subscribe {
            type ArgumentType = super::super::SubscribeInput;
            const NAME: &'static str = "input";
        }
    }
    pub struct postJob;
    impl ::cynic::schema::Field for postJob {
        type Type = super::Job;
        const NAME: &'static str = "postJob";
    }
    impl ::cynic::schema::HasField<postJob> for super::Mutation {
        type Type = super::Job;
    }
    pub mod post_job_arguments {
        pub struct input;
        impl ::cynic::schema::HasArgument<input> for super::postJob {
            type ArgumentType = super::super::PostJobInput;
            const NAME: &'static str = "input";
        }
    }
    pub struct updateJob;
    impl ::cynic::schema::Field for updateJob {
        type Type = super::Job;
        const NAME: &'static str = "updateJob";
    }
    impl ::cynic::schema::HasField<updateJob> for super::Mutation {
        type Type = super::Job;
    }
    pub mod update_job_arguments {
        pub struct input;
        impl ::cynic::schema::HasArgument<input> for super::updateJob {
            type ArgumentType = super::super::UpdateJobInput;
            const NAME: &'static str = "input";
        }
        pub struct adminSecret;
        impl ::cynic::schema::HasArgument<adminSecret> for super::updateJob {
            type ArgumentType = super::super::String;
            const NAME: &'static str = "adminSecret";
        }
    }
    pub struct updateCompany;
    impl ::cynic::schema::Field for updateCompany {
        type Type = super::Company;
        const NAME: &'static str = "updateCompany";
    }
    impl ::cynic::schema::HasField<updateCompany> for super::Mutation {
        type Type = super::Company;
    }
    pub mod update_company_arguments {
        pub struct input;
        impl ::cynic::schema::HasArgument<input> for super::updateCompany {
            type ArgumentType = super::super::UpdateCompanyInput;
            const NAME: &'static str = "input";
        }
        pub struct adminSecret;
        impl ::cynic::schema::HasArgument<adminSecret> for super::updateCompany {
            type ArgumentType = super::super::String;
            const NAME: &'static str = "adminSecret";
        }
    }
}
pub struct PostJobInput;
impl ::cynic::schema::InputObjectMarker for PostJobInput {}
pub mod post_job_input_fields {
    pub struct title;
    impl ::cynic::schema::Field for title {
        type Type = super::String;
        const NAME: &'static str = "title";
    }
    impl ::cynic::schema::HasInputField<title, super::String> for super::PostJobInput {}
    pub struct commitmentId;
    impl ::cynic::schema::Field for commitmentId {
        type Type = super::ID;
        const NAME: &'static str = "commitmentId";
    }
    impl ::cynic::schema::HasInputField<commitmentId, super::ID> for super::PostJobInput {}
    pub struct companyName;
    impl ::cynic::schema::Field for companyName {
        type Type = super::String;
        const NAME: &'static str = "companyName";
    }
    impl ::cynic::schema::HasInputField<companyName, super::String> for super::PostJobInput {}
    pub struct locationNames;
    impl ::cynic::schema::Field for locationNames {
        type Type = super::String;
        const NAME: &'static str = "locationNames";
    }
    impl ::cynic::schema::HasInputField<locationNames, super::String> for super::PostJobInput {}
    pub struct userEmail;
    impl ::cynic::schema::Field for userEmail {
        type Type = super::String;
        const NAME: &'static str = "userEmail";
    }
    impl ::cynic::schema::HasInputField<userEmail, super::String> for super::PostJobInput {}
    pub struct description;
    impl ::cynic::schema::Field for description {
        type Type = super::String;
        const NAME: &'static str = "description";
    }
    impl ::cynic::schema::HasInputField<description, super::String> for super::PostJobInput {}
    pub struct applyUrl;
    impl ::cynic::schema::Field for applyUrl {
        type Type = super::String;
        const NAME: &'static str = "applyUrl";
    }
    impl ::cynic::schema::HasInputField<applyUrl, super::String> for super::PostJobInput {}
}
pub struct Query;
pub mod query_fields {
    pub struct jobs;
    impl ::cynic::schema::Field for jobs {
        type Type = Vec<super::Job>;
        const NAME: &'static str = "jobs";
    }
    impl ::cynic::schema::HasField<jobs> for super::Query {
        type Type = Vec<super::Job>;
    }
    pub mod jobs_arguments {
        pub struct input;
        impl ::cynic::schema::HasArgument<input> for super::jobs {
            type ArgumentType = Option<super::super::JobsInput>;
            const NAME: &'static str = "input";
        }
    }
    pub struct job;
    impl ::cynic::schema::Field for job {
        type Type = super::Job;
        const NAME: &'static str = "job";
    }
    impl ::cynic::schema::HasField<job> for super::Query {
        type Type = super::Job;
    }
    pub mod job_arguments {
        pub struct input;
        impl ::cynic::schema::HasArgument<input> for super::job {
            type ArgumentType = super::super::JobInput;
            const NAME: &'static str = "input";
        }
    }
    pub struct locations;
    impl ::cynic::schema::Field for locations {
        type Type = Vec<super::Location>;
        const NAME: &'static str = "locations";
    }
    impl ::cynic::schema::HasField<locations> for super::Query {
        type Type = Vec<super::Location>;
    }
    pub mod locations_arguments {
        pub struct input;
        impl ::cynic::schema::HasArgument<input> for super::locations {
            type ArgumentType = super::super::LocationsInput;
            const NAME: &'static str = "input";
        }
    }
    pub struct city;
    impl ::cynic::schema::Field for city {
        type Type = super::City;
        const NAME: &'static str = "city";
    }
    impl ::cynic::schema::HasField<city> for super::Query {
        type Type = super::City;
    }
    pub mod city_arguments {
        pub struct input;
        impl ::cynic::schema::HasArgument<input> for super::city {
            type ArgumentType = super::super::LocationInput;
            const NAME: &'static str = "input";
        }
    }
    pub struct country;
    impl ::cynic::schema::Field for country {
        type Type = super::Country;
        const NAME: &'static str = "country";
    }
    impl ::cynic::schema::HasField<country> for super::Query {
        type Type = super::Country;
    }
    pub mod country_arguments {
        pub struct input;
        impl ::cynic::schema::HasArgument<input> for super::country {
            type ArgumentType = super::super::LocationInput;
            const NAME: &'static str = "input";
        }
    }
    pub struct remote;
    impl ::cynic::schema::Field for remote {
        type Type = super::Remote;
        const NAME: &'static str = "remote";
    }
    impl ::cynic::schema::HasField<remote> for super::Query {
        type Type = super::Remote;
    }
    pub mod remote_arguments {
        pub struct input;
        impl ::cynic::schema::HasArgument<input> for super::remote {
            type ArgumentType = super::super::LocationInput;
            const NAME: &'static str = "input";
        }
    }
    pub struct commitments;
    impl ::cynic::schema::Field for commitments {
        type Type = Vec<super::Commitment>;
        const NAME: &'static str = "commitments";
    }
    impl ::cynic::schema::HasField<commitments> for super::Query {
        type Type = Vec<super::Commitment>;
    }
    pub struct cities;
    impl ::cynic::schema::Field for cities {
        type Type = Vec<super::City>;
        const NAME: &'static str = "cities";
    }
    impl ::cynic::schema::HasField<cities> for super::Query {
        type Type = Vec<super::City>;
    }
    pub struct countries;
    impl ::cynic::schema::Field for countries {
        type Type = Vec<super::Country>;
        const NAME: &'static str = "countries";
    }
    impl ::cynic::schema::HasField<countries> for super::Query {
        type Type = Vec<super::Country>;
    }
    pub struct remotes;
    impl ::cynic::schema::Field for remotes {
        type Type = Vec<super::Remote>;
        const NAME: &'static str = "remotes";
    }
    impl ::cynic::schema::HasField<remotes> for super::Query {
        type Type = Vec<super::Remote>;
    }
    pub struct companies;
    impl ::cynic::schema::Field for companies {
        type Type = Vec<super::Company>;
        const NAME: &'static str = "companies";
    }
    impl ::cynic::schema::HasField<companies> for super::Query {
        type Type = Vec<super::Company>;
    }
}
pub struct Remote;
pub mod remote_fields {
    pub struct id;
    impl ::cynic::schema::Field for id {
        type Type = super::ID;
        const NAME: &'static str = "id";
    }
    impl ::cynic::schema::HasField<id> for super::Remote {
        type Type = super::ID;
    }
    pub struct name;
    impl ::cynic::schema::Field for name {
        type Type = super::String;
        const NAME: &'static str = "name";
    }
    impl ::cynic::schema::HasField<name> for super::Remote {
        type Type = super::String;
    }
    pub struct slug;
    impl ::cynic::schema::Field for slug {
        type Type = super::String;
        const NAME: &'static str = "slug";
    }
    impl ::cynic::schema::HasField<slug> for super::Remote {
        type Type = super::String;
    }
    pub struct r#type;
    impl ::cynic::schema::Field for r#type {
        type Type = super::String;
        const NAME: &'static str = "type";
    }
    impl ::cynic::schema::HasField<r#type> for super::Remote {
        type Type = super::String;
    }
    pub struct jobs;
    impl ::cynic::schema::Field for jobs {
        type Type = Option<Vec<super::Job>>;
        const NAME: &'static str = "jobs";
    }
    impl ::cynic::schema::HasField<jobs> for super::Remote {
        type Type = Option<Vec<super::Job>>;
    }
    pub mod jobs_arguments {
        pub struct r#where;
        impl ::cynic::schema::HasArgument<r#where> for super::jobs {
            type ArgumentType = Option<super::super::JobWhereInput>;
            const NAME: &'static str = "where";
        }
        pub struct orderBy;
        impl ::cynic::schema::HasArgument<orderBy> for super::jobs {
            type ArgumentType = Option<super::super::JobOrderByInput>;
            const NAME: &'static str = "orderBy";
        }
        pub struct skip;
        impl ::cynic::schema::HasArgument<skip> for super::jobs {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "skip";
        }
        pub struct after;
        impl ::cynic::schema::HasArgument<after> for super::jobs {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "after";
        }
        pub struct before;
        impl ::cynic::schema::HasArgument<before> for super::jobs {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "before";
        }
        pub struct first;
        impl ::cynic::schema::HasArgument<first> for super::jobs {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "first";
        }
        pub struct last;
        impl ::cynic::schema::HasArgument<last> for super::jobs {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "last";
        }
    }
    pub struct createdAt;
    impl ::cynic::schema::Field for createdAt {
        type Type = super::DateTime;
        const NAME: &'static str = "createdAt";
    }
    impl ::cynic::schema::HasField<createdAt> for super::Remote {
        type Type = super::DateTime;
    }
    pub struct updatedAt;
    impl ::cynic::schema::Field for updatedAt {
        type Type = super::DateTime;
        const NAME: &'static str = "updatedAt";
    }
    impl ::cynic::schema::HasField<updatedAt> for super::Remote {
        type Type = super::DateTime;
    }
}
pub struct RemoteOrderByInput {}
pub struct RemoteWhereInput;
impl ::cynic::schema::InputObjectMarker for RemoteWhereInput {}
pub mod remote_where_input_fields {
    pub struct id;
    impl ::cynic::schema::Field for id {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id";
    }
    impl ::cynic::schema::HasInputField<id, Option<super::ID>> for super::RemoteWhereInput {}
    pub struct id_not;
    impl ::cynic::schema::Field for id_not {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_not";
    }
    impl ::cynic::schema::HasInputField<id_not, Option<super::ID>> for super::RemoteWhereInput {}
    pub struct id_in;
    impl ::cynic::schema::Field for id_in {
        type Type = Option<Vec<super::ID>>;
        const NAME: &'static str = "id_in";
    }
    impl ::cynic::schema::HasInputField<id_in, Option<Vec<super::ID>>> for super::RemoteWhereInput {}
    pub struct id_not_in;
    impl ::cynic::schema::Field for id_not_in {
        type Type = Option<Vec<super::ID>>;
        const NAME: &'static str = "id_not_in";
    }
    impl ::cynic::schema::HasInputField<id_not_in, Option<Vec<super::ID>>> for super::RemoteWhereInput {}
    pub struct id_lt;
    impl ::cynic::schema::Field for id_lt {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_lt";
    }
    impl ::cynic::schema::HasInputField<id_lt, Option<super::ID>> for super::RemoteWhereInput {}
    pub struct id_lte;
    impl ::cynic::schema::Field for id_lte {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_lte";
    }
    impl ::cynic::schema::HasInputField<id_lte, Option<super::ID>> for super::RemoteWhereInput {}
    pub struct id_gt;
    impl ::cynic::schema::Field for id_gt {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_gt";
    }
    impl ::cynic::schema::HasInputField<id_gt, Option<super::ID>> for super::RemoteWhereInput {}
    pub struct id_gte;
    impl ::cynic::schema::Field for id_gte {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_gte";
    }
    impl ::cynic::schema::HasInputField<id_gte, Option<super::ID>> for super::RemoteWhereInput {}
    pub struct id_contains;
    impl ::cynic::schema::Field for id_contains {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_contains";
    }
    impl ::cynic::schema::HasInputField<id_contains, Option<super::ID>> for super::RemoteWhereInput {}
    pub struct id_not_contains;
    impl ::cynic::schema::Field for id_not_contains {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_not_contains";
    }
    impl ::cynic::schema::HasInputField<id_not_contains, Option<super::ID>>
        for super::RemoteWhereInput
    {
    }
    pub struct id_starts_with;
    impl ::cynic::schema::Field for id_starts_with {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_starts_with";
    }
    impl ::cynic::schema::HasInputField<id_starts_with, Option<super::ID>> for super::RemoteWhereInput {}
    pub struct id_not_starts_with;
    impl ::cynic::schema::Field for id_not_starts_with {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_not_starts_with";
    }
    impl ::cynic::schema::HasInputField<id_not_starts_with, Option<super::ID>>
        for super::RemoteWhereInput
    {
    }
    pub struct id_ends_with;
    impl ::cynic::schema::Field for id_ends_with {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_ends_with";
    }
    impl ::cynic::schema::HasInputField<id_ends_with, Option<super::ID>> for super::RemoteWhereInput {}
    pub struct id_not_ends_with;
    impl ::cynic::schema::Field for id_not_ends_with {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_not_ends_with";
    }
    impl ::cynic::schema::HasInputField<id_not_ends_with, Option<super::ID>>
        for super::RemoteWhereInput
    {
    }
    pub struct name;
    impl ::cynic::schema::Field for name {
        type Type = Option<super::String>;
        const NAME: &'static str = "name";
    }
    impl ::cynic::schema::HasInputField<name, Option<super::String>> for super::RemoteWhereInput {}
    pub struct name_not;
    impl ::cynic::schema::Field for name_not {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_not";
    }
    impl ::cynic::schema::HasInputField<name_not, Option<super::String>> for super::RemoteWhereInput {}
    pub struct name_in;
    impl ::cynic::schema::Field for name_in {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "name_in";
    }
    impl ::cynic::schema::HasInputField<name_in, Option<Vec<super::String>>>
        for super::RemoteWhereInput
    {
    }
    pub struct name_not_in;
    impl ::cynic::schema::Field for name_not_in {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "name_not_in";
    }
    impl ::cynic::schema::HasInputField<name_not_in, Option<Vec<super::String>>>
        for super::RemoteWhereInput
    {
    }
    pub struct name_lt;
    impl ::cynic::schema::Field for name_lt {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_lt";
    }
    impl ::cynic::schema::HasInputField<name_lt, Option<super::String>> for super::RemoteWhereInput {}
    pub struct name_lte;
    impl ::cynic::schema::Field for name_lte {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_lte";
    }
    impl ::cynic::schema::HasInputField<name_lte, Option<super::String>> for super::RemoteWhereInput {}
    pub struct name_gt;
    impl ::cynic::schema::Field for name_gt {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_gt";
    }
    impl ::cynic::schema::HasInputField<name_gt, Option<super::String>> for super::RemoteWhereInput {}
    pub struct name_gte;
    impl ::cynic::schema::Field for name_gte {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_gte";
    }
    impl ::cynic::schema::HasInputField<name_gte, Option<super::String>> for super::RemoteWhereInput {}
    pub struct name_contains;
    impl ::cynic::schema::Field for name_contains {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_contains";
    }
    impl ::cynic::schema::HasInputField<name_contains, Option<super::String>>
        for super::RemoteWhereInput
    {
    }
    pub struct name_not_contains;
    impl ::cynic::schema::Field for name_not_contains {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_not_contains";
    }
    impl ::cynic::schema::HasInputField<name_not_contains, Option<super::String>>
        for super::RemoteWhereInput
    {
    }
    pub struct name_starts_with;
    impl ::cynic::schema::Field for name_starts_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_starts_with";
    }
    impl ::cynic::schema::HasInputField<name_starts_with, Option<super::String>>
        for super::RemoteWhereInput
    {
    }
    pub struct name_not_starts_with;
    impl ::cynic::schema::Field for name_not_starts_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_not_starts_with";
    }
    impl ::cynic::schema::HasInputField<name_not_starts_with, Option<super::String>>
        for super::RemoteWhereInput
    {
    }
    pub struct name_ends_with;
    impl ::cynic::schema::Field for name_ends_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_ends_with";
    }
    impl ::cynic::schema::HasInputField<name_ends_with, Option<super::String>>
        for super::RemoteWhereInput
    {
    }
    pub struct name_not_ends_with;
    impl ::cynic::schema::Field for name_not_ends_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_not_ends_with";
    }
    impl ::cynic::schema::HasInputField<name_not_ends_with, Option<super::String>>
        for super::RemoteWhereInput
    {
    }
    pub struct slug;
    impl ::cynic::schema::Field for slug {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug";
    }
    impl ::cynic::schema::HasInputField<slug, Option<super::String>> for super::RemoteWhereInput {}
    pub struct slug_not;
    impl ::cynic::schema::Field for slug_not {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_not";
    }
    impl ::cynic::schema::HasInputField<slug_not, Option<super::String>> for super::RemoteWhereInput {}
    pub struct slug_in;
    impl ::cynic::schema::Field for slug_in {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "slug_in";
    }
    impl ::cynic::schema::HasInputField<slug_in, Option<Vec<super::String>>>
        for super::RemoteWhereInput
    {
    }
    pub struct slug_not_in;
    impl ::cynic::schema::Field for slug_not_in {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "slug_not_in";
    }
    impl ::cynic::schema::HasInputField<slug_not_in, Option<Vec<super::String>>>
        for super::RemoteWhereInput
    {
    }
    pub struct slug_lt;
    impl ::cynic::schema::Field for slug_lt {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_lt";
    }
    impl ::cynic::schema::HasInputField<slug_lt, Option<super::String>> for super::RemoteWhereInput {}
    pub struct slug_lte;
    impl ::cynic::schema::Field for slug_lte {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_lte";
    }
    impl ::cynic::schema::HasInputField<slug_lte, Option<super::String>> for super::RemoteWhereInput {}
    pub struct slug_gt;
    impl ::cynic::schema::Field for slug_gt {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_gt";
    }
    impl ::cynic::schema::HasInputField<slug_gt, Option<super::String>> for super::RemoteWhereInput {}
    pub struct slug_gte;
    impl ::cynic::schema::Field for slug_gte {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_gte";
    }
    impl ::cynic::schema::HasInputField<slug_gte, Option<super::String>> for super::RemoteWhereInput {}
    pub struct slug_contains;
    impl ::cynic::schema::Field for slug_contains {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_contains";
    }
    impl ::cynic::schema::HasInputField<slug_contains, Option<super::String>>
        for super::RemoteWhereInput
    {
    }
    pub struct slug_not_contains;
    impl ::cynic::schema::Field for slug_not_contains {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_not_contains";
    }
    impl ::cynic::schema::HasInputField<slug_not_contains, Option<super::String>>
        for super::RemoteWhereInput
    {
    }
    pub struct slug_starts_with;
    impl ::cynic::schema::Field for slug_starts_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_starts_with";
    }
    impl ::cynic::schema::HasInputField<slug_starts_with, Option<super::String>>
        for super::RemoteWhereInput
    {
    }
    pub struct slug_not_starts_with;
    impl ::cynic::schema::Field for slug_not_starts_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_not_starts_with";
    }
    impl ::cynic::schema::HasInputField<slug_not_starts_with, Option<super::String>>
        for super::RemoteWhereInput
    {
    }
    pub struct slug_ends_with;
    impl ::cynic::schema::Field for slug_ends_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_ends_with";
    }
    impl ::cynic::schema::HasInputField<slug_ends_with, Option<super::String>>
        for super::RemoteWhereInput
    {
    }
    pub struct slug_not_ends_with;
    impl ::cynic::schema::Field for slug_not_ends_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_not_ends_with";
    }
    impl ::cynic::schema::HasInputField<slug_not_ends_with, Option<super::String>>
        for super::RemoteWhereInput
    {
    }
    pub struct r#type;
    impl ::cynic::schema::Field for r#type {
        type Type = Option<super::String>;
        const NAME: &'static str = "type";
    }
    impl ::cynic::schema::HasInputField<r#type, Option<super::String>> for super::RemoteWhereInput {}
    pub struct type_not;
    impl ::cynic::schema::Field for type_not {
        type Type = Option<super::String>;
        const NAME: &'static str = "type_not";
    }
    impl ::cynic::schema::HasInputField<type_not, Option<super::String>> for super::RemoteWhereInput {}
    pub struct type_in;
    impl ::cynic::schema::Field for type_in {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "type_in";
    }
    impl ::cynic::schema::HasInputField<type_in, Option<Vec<super::String>>>
        for super::RemoteWhereInput
    {
    }
    pub struct type_not_in;
    impl ::cynic::schema::Field for type_not_in {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "type_not_in";
    }
    impl ::cynic::schema::HasInputField<type_not_in, Option<Vec<super::String>>>
        for super::RemoteWhereInput
    {
    }
    pub struct type_lt;
    impl ::cynic::schema::Field for type_lt {
        type Type = Option<super::String>;
        const NAME: &'static str = "type_lt";
    }
    impl ::cynic::schema::HasInputField<type_lt, Option<super::String>> for super::RemoteWhereInput {}
    pub struct type_lte;
    impl ::cynic::schema::Field for type_lte {
        type Type = Option<super::String>;
        const NAME: &'static str = "type_lte";
    }
    impl ::cynic::schema::HasInputField<type_lte, Option<super::String>> for super::RemoteWhereInput {}
    pub struct type_gt;
    impl ::cynic::schema::Field for type_gt {
        type Type = Option<super::String>;
        const NAME: &'static str = "type_gt";
    }
    impl ::cynic::schema::HasInputField<type_gt, Option<super::String>> for super::RemoteWhereInput {}
    pub struct type_gte;
    impl ::cynic::schema::Field for type_gte {
        type Type = Option<super::String>;
        const NAME: &'static str = "type_gte";
    }
    impl ::cynic::schema::HasInputField<type_gte, Option<super::String>> for super::RemoteWhereInput {}
    pub struct type_contains;
    impl ::cynic::schema::Field for type_contains {
        type Type = Option<super::String>;
        const NAME: &'static str = "type_contains";
    }
    impl ::cynic::schema::HasInputField<type_contains, Option<super::String>>
        for super::RemoteWhereInput
    {
    }
    pub struct type_not_contains;
    impl ::cynic::schema::Field for type_not_contains {
        type Type = Option<super::String>;
        const NAME: &'static str = "type_not_contains";
    }
    impl ::cynic::schema::HasInputField<type_not_contains, Option<super::String>>
        for super::RemoteWhereInput
    {
    }
    pub struct type_starts_with;
    impl ::cynic::schema::Field for type_starts_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "type_starts_with";
    }
    impl ::cynic::schema::HasInputField<type_starts_with, Option<super::String>>
        for super::RemoteWhereInput
    {
    }
    pub struct type_not_starts_with;
    impl ::cynic::schema::Field for type_not_starts_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "type_not_starts_with";
    }
    impl ::cynic::schema::HasInputField<type_not_starts_with, Option<super::String>>
        for super::RemoteWhereInput
    {
    }
    pub struct type_ends_with;
    impl ::cynic::schema::Field for type_ends_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "type_ends_with";
    }
    impl ::cynic::schema::HasInputField<type_ends_with, Option<super::String>>
        for super::RemoteWhereInput
    {
    }
    pub struct type_not_ends_with;
    impl ::cynic::schema::Field for type_not_ends_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "type_not_ends_with";
    }
    impl ::cynic::schema::HasInputField<type_not_ends_with, Option<super::String>>
        for super::RemoteWhereInput
    {
    }
    pub struct jobs_every;
    impl ::cynic::schema::Field for jobs_every {
        type Type = Option<super::JobWhereInput>;
        const NAME: &'static str = "jobs_every";
    }
    impl ::cynic::schema::HasInputField<jobs_every, Option<super::JobWhereInput>>
        for super::RemoteWhereInput
    {
    }
    pub struct jobs_some;
    impl ::cynic::schema::Field for jobs_some {
        type Type = Option<super::JobWhereInput>;
        const NAME: &'static str = "jobs_some";
    }
    impl ::cynic::schema::HasInputField<jobs_some, Option<super::JobWhereInput>>
        for super::RemoteWhereInput
    {
    }
    pub struct jobs_none;
    impl ::cynic::schema::Field for jobs_none {
        type Type = Option<super::JobWhereInput>;
        const NAME: &'static str = "jobs_none";
    }
    impl ::cynic::schema::HasInputField<jobs_none, Option<super::JobWhereInput>>
        for super::RemoteWhereInput
    {
    }
    pub struct createdAt;
    impl ::cynic::schema::Field for createdAt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt";
    }
    impl ::cynic::schema::HasInputField<createdAt, Option<super::DateTime>>
        for super::RemoteWhereInput
    {
    }
    pub struct createdAt_not;
    impl ::cynic::schema::Field for createdAt_not {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt_not";
    }
    impl ::cynic::schema::HasInputField<createdAt_not, Option<super::DateTime>>
        for super::RemoteWhereInput
    {
    }
    pub struct createdAt_in;
    impl ::cynic::schema::Field for createdAt_in {
        type Type = Option<Vec<super::DateTime>>;
        const NAME: &'static str = "createdAt_in";
    }
    impl ::cynic::schema::HasInputField<createdAt_in, Option<Vec<super::DateTime>>>
        for super::RemoteWhereInput
    {
    }
    pub struct createdAt_not_in;
    impl ::cynic::schema::Field for createdAt_not_in {
        type Type = Option<Vec<super::DateTime>>;
        const NAME: &'static str = "createdAt_not_in";
    }
    impl ::cynic::schema::HasInputField<createdAt_not_in, Option<Vec<super::DateTime>>>
        for super::RemoteWhereInput
    {
    }
    pub struct createdAt_lt;
    impl ::cynic::schema::Field for createdAt_lt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt_lt";
    }
    impl ::cynic::schema::HasInputField<createdAt_lt, Option<super::DateTime>>
        for super::RemoteWhereInput
    {
    }
    pub struct createdAt_lte;
    impl ::cynic::schema::Field for createdAt_lte {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt_lte";
    }
    impl ::cynic::schema::HasInputField<createdAt_lte, Option<super::DateTime>>
        for super::RemoteWhereInput
    {
    }
    pub struct createdAt_gt;
    impl ::cynic::schema::Field for createdAt_gt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt_gt";
    }
    impl ::cynic::schema::HasInputField<createdAt_gt, Option<super::DateTime>>
        for super::RemoteWhereInput
    {
    }
    pub struct createdAt_gte;
    impl ::cynic::schema::Field for createdAt_gte {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt_gte";
    }
    impl ::cynic::schema::HasInputField<createdAt_gte, Option<super::DateTime>>
        for super::RemoteWhereInput
    {
    }
    pub struct updatedAt;
    impl ::cynic::schema::Field for updatedAt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt";
    }
    impl ::cynic::schema::HasInputField<updatedAt, Option<super::DateTime>>
        for super::RemoteWhereInput
    {
    }
    pub struct updatedAt_not;
    impl ::cynic::schema::Field for updatedAt_not {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt_not";
    }
    impl ::cynic::schema::HasInputField<updatedAt_not, Option<super::DateTime>>
        for super::RemoteWhereInput
    {
    }
    pub struct updatedAt_in;
    impl ::cynic::schema::Field for updatedAt_in {
        type Type = Option<Vec<super::DateTime>>;
        const NAME: &'static str = "updatedAt_in";
    }
    impl ::cynic::schema::HasInputField<updatedAt_in, Option<Vec<super::DateTime>>>
        for super::RemoteWhereInput
    {
    }
    pub struct updatedAt_not_in;
    impl ::cynic::schema::Field for updatedAt_not_in {
        type Type = Option<Vec<super::DateTime>>;
        const NAME: &'static str = "updatedAt_not_in";
    }
    impl ::cynic::schema::HasInputField<updatedAt_not_in, Option<Vec<super::DateTime>>>
        for super::RemoteWhereInput
    {
    }
    pub struct updatedAt_lt;
    impl ::cynic::schema::Field for updatedAt_lt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt_lt";
    }
    impl ::cynic::schema::HasInputField<updatedAt_lt, Option<super::DateTime>>
        for super::RemoteWhereInput
    {
    }
    pub struct updatedAt_lte;
    impl ::cynic::schema::Field for updatedAt_lte {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt_lte";
    }
    impl ::cynic::schema::HasInputField<updatedAt_lte, Option<super::DateTime>>
        for super::RemoteWhereInput
    {
    }
    pub struct updatedAt_gt;
    impl ::cynic::schema::Field for updatedAt_gt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt_gt";
    }
    impl ::cynic::schema::HasInputField<updatedAt_gt, Option<super::DateTime>>
        for super::RemoteWhereInput
    {
    }
    pub struct updatedAt_gte;
    impl ::cynic::schema::Field for updatedAt_gte {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt_gte";
    }
    impl ::cynic::schema::HasInputField<updatedAt_gte, Option<super::DateTime>>
        for super::RemoteWhereInput
    {
    }
    pub struct AND;
    impl ::cynic::schema::Field for AND {
        type Type = Option<Vec<super::RemoteWhereInput>>;
        const NAME: &'static str = "AND";
    }
    impl ::cynic::schema::HasInputField<AND, Option<Vec<super::RemoteWhereInput>>>
        for super::RemoteWhereInput
    {
    }
    pub struct OR;
    impl ::cynic::schema::Field for OR {
        type Type = Option<Vec<super::RemoteWhereInput>>;
        const NAME: &'static str = "OR";
    }
    impl ::cynic::schema::HasInputField<OR, Option<Vec<super::RemoteWhereInput>>>
        for super::RemoteWhereInput
    {
    }
    pub struct NOT;
    impl ::cynic::schema::Field for NOT {
        type Type = Option<Vec<super::RemoteWhereInput>>;
        const NAME: &'static str = "NOT";
    }
    impl ::cynic::schema::HasInputField<NOT, Option<Vec<super::RemoteWhereInput>>>
        for super::RemoteWhereInput
    {
    }
}
pub struct SubscribeInput;
impl ::cynic::schema::InputObjectMarker for SubscribeInput {}
pub mod subscribe_input_fields {
    pub struct name;
    impl ::cynic::schema::Field for name {
        type Type = super::String;
        const NAME: &'static str = "name";
    }
    impl ::cynic::schema::HasInputField<name, super::String> for super::SubscribeInput {}
    pub struct email;
    impl ::cynic::schema::Field for email {
        type Type = super::String;
        const NAME: &'static str = "email";
    }
    impl ::cynic::schema::HasInputField<email, super::String> for super::SubscribeInput {}
}
pub struct Tag;
pub mod tag_fields {
    pub struct id;
    impl ::cynic::schema::Field for id {
        type Type = super::ID;
        const NAME: &'static str = "id";
    }
    impl ::cynic::schema::HasField<id> for super::Tag {
        type Type = super::ID;
    }
    pub struct name;
    impl ::cynic::schema::Field for name {
        type Type = super::String;
        const NAME: &'static str = "name";
    }
    impl ::cynic::schema::HasField<name> for super::Tag {
        type Type = super::String;
    }
    pub struct slug;
    impl ::cynic::schema::Field for slug {
        type Type = super::String;
        const NAME: &'static str = "slug";
    }
    impl ::cynic::schema::HasField<slug> for super::Tag {
        type Type = super::String;
    }
    pub struct jobs;
    impl ::cynic::schema::Field for jobs {
        type Type = Option<Vec<super::Job>>;
        const NAME: &'static str = "jobs";
    }
    impl ::cynic::schema::HasField<jobs> for super::Tag {
        type Type = Option<Vec<super::Job>>;
    }
    pub mod jobs_arguments {
        pub struct r#where;
        impl ::cynic::schema::HasArgument<r#where> for super::jobs {
            type ArgumentType = Option<super::super::JobWhereInput>;
            const NAME: &'static str = "where";
        }
        pub struct orderBy;
        impl ::cynic::schema::HasArgument<orderBy> for super::jobs {
            type ArgumentType = Option<super::super::JobOrderByInput>;
            const NAME: &'static str = "orderBy";
        }
        pub struct skip;
        impl ::cynic::schema::HasArgument<skip> for super::jobs {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "skip";
        }
        pub struct after;
        impl ::cynic::schema::HasArgument<after> for super::jobs {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "after";
        }
        pub struct before;
        impl ::cynic::schema::HasArgument<before> for super::jobs {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "before";
        }
        pub struct first;
        impl ::cynic::schema::HasArgument<first> for super::jobs {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "first";
        }
        pub struct last;
        impl ::cynic::schema::HasArgument<last> for super::jobs {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "last";
        }
    }
    pub struct createdAt;
    impl ::cynic::schema::Field for createdAt {
        type Type = super::DateTime;
        const NAME: &'static str = "createdAt";
    }
    impl ::cynic::schema::HasField<createdAt> for super::Tag {
        type Type = super::DateTime;
    }
    pub struct updatedAt;
    impl ::cynic::schema::Field for updatedAt {
        type Type = super::DateTime;
        const NAME: &'static str = "updatedAt";
    }
    impl ::cynic::schema::HasField<updatedAt> for super::Tag {
        type Type = super::DateTime;
    }
}
pub struct TagOrderByInput {}
pub struct TagWhereInput;
impl ::cynic::schema::InputObjectMarker for TagWhereInput {}
pub mod tag_where_input_fields {
    pub struct id;
    impl ::cynic::schema::Field for id {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id";
    }
    impl ::cynic::schema::HasInputField<id, Option<super::ID>> for super::TagWhereInput {}
    pub struct id_not;
    impl ::cynic::schema::Field for id_not {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_not";
    }
    impl ::cynic::schema::HasInputField<id_not, Option<super::ID>> for super::TagWhereInput {}
    pub struct id_in;
    impl ::cynic::schema::Field for id_in {
        type Type = Option<Vec<super::ID>>;
        const NAME: &'static str = "id_in";
    }
    impl ::cynic::schema::HasInputField<id_in, Option<Vec<super::ID>>> for super::TagWhereInput {}
    pub struct id_not_in;
    impl ::cynic::schema::Field for id_not_in {
        type Type = Option<Vec<super::ID>>;
        const NAME: &'static str = "id_not_in";
    }
    impl ::cynic::schema::HasInputField<id_not_in, Option<Vec<super::ID>>> for super::TagWhereInput {}
    pub struct id_lt;
    impl ::cynic::schema::Field for id_lt {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_lt";
    }
    impl ::cynic::schema::HasInputField<id_lt, Option<super::ID>> for super::TagWhereInput {}
    pub struct id_lte;
    impl ::cynic::schema::Field for id_lte {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_lte";
    }
    impl ::cynic::schema::HasInputField<id_lte, Option<super::ID>> for super::TagWhereInput {}
    pub struct id_gt;
    impl ::cynic::schema::Field for id_gt {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_gt";
    }
    impl ::cynic::schema::HasInputField<id_gt, Option<super::ID>> for super::TagWhereInput {}
    pub struct id_gte;
    impl ::cynic::schema::Field for id_gte {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_gte";
    }
    impl ::cynic::schema::HasInputField<id_gte, Option<super::ID>> for super::TagWhereInput {}
    pub struct id_contains;
    impl ::cynic::schema::Field for id_contains {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_contains";
    }
    impl ::cynic::schema::HasInputField<id_contains, Option<super::ID>> for super::TagWhereInput {}
    pub struct id_not_contains;
    impl ::cynic::schema::Field for id_not_contains {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_not_contains";
    }
    impl ::cynic::schema::HasInputField<id_not_contains, Option<super::ID>> for super::TagWhereInput {}
    pub struct id_starts_with;
    impl ::cynic::schema::Field for id_starts_with {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_starts_with";
    }
    impl ::cynic::schema::HasInputField<id_starts_with, Option<super::ID>> for super::TagWhereInput {}
    pub struct id_not_starts_with;
    impl ::cynic::schema::Field for id_not_starts_with {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_not_starts_with";
    }
    impl ::cynic::schema::HasInputField<id_not_starts_with, Option<super::ID>>
        for super::TagWhereInput
    {
    }
    pub struct id_ends_with;
    impl ::cynic::schema::Field for id_ends_with {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_ends_with";
    }
    impl ::cynic::schema::HasInputField<id_ends_with, Option<super::ID>> for super::TagWhereInput {}
    pub struct id_not_ends_with;
    impl ::cynic::schema::Field for id_not_ends_with {
        type Type = Option<super::ID>;
        const NAME: &'static str = "id_not_ends_with";
    }
    impl ::cynic::schema::HasInputField<id_not_ends_with, Option<super::ID>> for super::TagWhereInput {}
    pub struct name;
    impl ::cynic::schema::Field for name {
        type Type = Option<super::String>;
        const NAME: &'static str = "name";
    }
    impl ::cynic::schema::HasInputField<name, Option<super::String>> for super::TagWhereInput {}
    pub struct name_not;
    impl ::cynic::schema::Field for name_not {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_not";
    }
    impl ::cynic::schema::HasInputField<name_not, Option<super::String>> for super::TagWhereInput {}
    pub struct name_in;
    impl ::cynic::schema::Field for name_in {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "name_in";
    }
    impl ::cynic::schema::HasInputField<name_in, Option<Vec<super::String>>> for super::TagWhereInput {}
    pub struct name_not_in;
    impl ::cynic::schema::Field for name_not_in {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "name_not_in";
    }
    impl ::cynic::schema::HasInputField<name_not_in, Option<Vec<super::String>>>
        for super::TagWhereInput
    {
    }
    pub struct name_lt;
    impl ::cynic::schema::Field for name_lt {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_lt";
    }
    impl ::cynic::schema::HasInputField<name_lt, Option<super::String>> for super::TagWhereInput {}
    pub struct name_lte;
    impl ::cynic::schema::Field for name_lte {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_lte";
    }
    impl ::cynic::schema::HasInputField<name_lte, Option<super::String>> for super::TagWhereInput {}
    pub struct name_gt;
    impl ::cynic::schema::Field for name_gt {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_gt";
    }
    impl ::cynic::schema::HasInputField<name_gt, Option<super::String>> for super::TagWhereInput {}
    pub struct name_gte;
    impl ::cynic::schema::Field for name_gte {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_gte";
    }
    impl ::cynic::schema::HasInputField<name_gte, Option<super::String>> for super::TagWhereInput {}
    pub struct name_contains;
    impl ::cynic::schema::Field for name_contains {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_contains";
    }
    impl ::cynic::schema::HasInputField<name_contains, Option<super::String>> for super::TagWhereInput {}
    pub struct name_not_contains;
    impl ::cynic::schema::Field for name_not_contains {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_not_contains";
    }
    impl ::cynic::schema::HasInputField<name_not_contains, Option<super::String>>
        for super::TagWhereInput
    {
    }
    pub struct name_starts_with;
    impl ::cynic::schema::Field for name_starts_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_starts_with";
    }
    impl ::cynic::schema::HasInputField<name_starts_with, Option<super::String>>
        for super::TagWhereInput
    {
    }
    pub struct name_not_starts_with;
    impl ::cynic::schema::Field for name_not_starts_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_not_starts_with";
    }
    impl ::cynic::schema::HasInputField<name_not_starts_with, Option<super::String>>
        for super::TagWhereInput
    {
    }
    pub struct name_ends_with;
    impl ::cynic::schema::Field for name_ends_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_ends_with";
    }
    impl ::cynic::schema::HasInputField<name_ends_with, Option<super::String>>
        for super::TagWhereInput
    {
    }
    pub struct name_not_ends_with;
    impl ::cynic::schema::Field for name_not_ends_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_not_ends_with";
    }
    impl ::cynic::schema::HasInputField<name_not_ends_with, Option<super::String>>
        for super::TagWhereInput
    {
    }
    pub struct slug;
    impl ::cynic::schema::Field for slug {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug";
    }
    impl ::cynic::schema::HasInputField<slug, Option<super::String>> for super::TagWhereInput {}
    pub struct slug_not;
    impl ::cynic::schema::Field for slug_not {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_not";
    }
    impl ::cynic::schema::HasInputField<slug_not, Option<super::String>> for super::TagWhereInput {}
    pub struct slug_in;
    impl ::cynic::schema::Field for slug_in {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "slug_in";
    }
    impl ::cynic::schema::HasInputField<slug_in, Option<Vec<super::String>>> for super::TagWhereInput {}
    pub struct slug_not_in;
    impl ::cynic::schema::Field for slug_not_in {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "slug_not_in";
    }
    impl ::cynic::schema::HasInputField<slug_not_in, Option<Vec<super::String>>>
        for super::TagWhereInput
    {
    }
    pub struct slug_lt;
    impl ::cynic::schema::Field for slug_lt {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_lt";
    }
    impl ::cynic::schema::HasInputField<slug_lt, Option<super::String>> for super::TagWhereInput {}
    pub struct slug_lte;
    impl ::cynic::schema::Field for slug_lte {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_lte";
    }
    impl ::cynic::schema::HasInputField<slug_lte, Option<super::String>> for super::TagWhereInput {}
    pub struct slug_gt;
    impl ::cynic::schema::Field for slug_gt {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_gt";
    }
    impl ::cynic::schema::HasInputField<slug_gt, Option<super::String>> for super::TagWhereInput {}
    pub struct slug_gte;
    impl ::cynic::schema::Field for slug_gte {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_gte";
    }
    impl ::cynic::schema::HasInputField<slug_gte, Option<super::String>> for super::TagWhereInput {}
    pub struct slug_contains;
    impl ::cynic::schema::Field for slug_contains {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_contains";
    }
    impl ::cynic::schema::HasInputField<slug_contains, Option<super::String>> for super::TagWhereInput {}
    pub struct slug_not_contains;
    impl ::cynic::schema::Field for slug_not_contains {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_not_contains";
    }
    impl ::cynic::schema::HasInputField<slug_not_contains, Option<super::String>>
        for super::TagWhereInput
    {
    }
    pub struct slug_starts_with;
    impl ::cynic::schema::Field for slug_starts_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_starts_with";
    }
    impl ::cynic::schema::HasInputField<slug_starts_with, Option<super::String>>
        for super::TagWhereInput
    {
    }
    pub struct slug_not_starts_with;
    impl ::cynic::schema::Field for slug_not_starts_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_not_starts_with";
    }
    impl ::cynic::schema::HasInputField<slug_not_starts_with, Option<super::String>>
        for super::TagWhereInput
    {
    }
    pub struct slug_ends_with;
    impl ::cynic::schema::Field for slug_ends_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_ends_with";
    }
    impl ::cynic::schema::HasInputField<slug_ends_with, Option<super::String>>
        for super::TagWhereInput
    {
    }
    pub struct slug_not_ends_with;
    impl ::cynic::schema::Field for slug_not_ends_with {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_not_ends_with";
    }
    impl ::cynic::schema::HasInputField<slug_not_ends_with, Option<super::String>>
        for super::TagWhereInput
    {
    }
    pub struct jobs_every;
    impl ::cynic::schema::Field for jobs_every {
        type Type = Option<super::JobWhereInput>;
        const NAME: &'static str = "jobs_every";
    }
    impl ::cynic::schema::HasInputField<jobs_every, Option<super::JobWhereInput>>
        for super::TagWhereInput
    {
    }
    pub struct jobs_some;
    impl ::cynic::schema::Field for jobs_some {
        type Type = Option<super::JobWhereInput>;
        const NAME: &'static str = "jobs_some";
    }
    impl ::cynic::schema::HasInputField<jobs_some, Option<super::JobWhereInput>>
        for super::TagWhereInput
    {
    }
    pub struct jobs_none;
    impl ::cynic::schema::Field for jobs_none {
        type Type = Option<super::JobWhereInput>;
        const NAME: &'static str = "jobs_none";
    }
    impl ::cynic::schema::HasInputField<jobs_none, Option<super::JobWhereInput>>
        for super::TagWhereInput
    {
    }
    pub struct createdAt;
    impl ::cynic::schema::Field for createdAt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt";
    }
    impl ::cynic::schema::HasInputField<createdAt, Option<super::DateTime>> for super::TagWhereInput {}
    pub struct createdAt_not;
    impl ::cynic::schema::Field for createdAt_not {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt_not";
    }
    impl ::cynic::schema::HasInputField<createdAt_not, Option<super::DateTime>>
        for super::TagWhereInput
    {
    }
    pub struct createdAt_in;
    impl ::cynic::schema::Field for createdAt_in {
        type Type = Option<Vec<super::DateTime>>;
        const NAME: &'static str = "createdAt_in";
    }
    impl ::cynic::schema::HasInputField<createdAt_in, Option<Vec<super::DateTime>>>
        for super::TagWhereInput
    {
    }
    pub struct createdAt_not_in;
    impl ::cynic::schema::Field for createdAt_not_in {
        type Type = Option<Vec<super::DateTime>>;
        const NAME: &'static str = "createdAt_not_in";
    }
    impl ::cynic::schema::HasInputField<createdAt_not_in, Option<Vec<super::DateTime>>>
        for super::TagWhereInput
    {
    }
    pub struct createdAt_lt;
    impl ::cynic::schema::Field for createdAt_lt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt_lt";
    }
    impl ::cynic::schema::HasInputField<createdAt_lt, Option<super::DateTime>>
        for super::TagWhereInput
    {
    }
    pub struct createdAt_lte;
    impl ::cynic::schema::Field for createdAt_lte {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt_lte";
    }
    impl ::cynic::schema::HasInputField<createdAt_lte, Option<super::DateTime>>
        for super::TagWhereInput
    {
    }
    pub struct createdAt_gt;
    impl ::cynic::schema::Field for createdAt_gt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt_gt";
    }
    impl ::cynic::schema::HasInputField<createdAt_gt, Option<super::DateTime>>
        for super::TagWhereInput
    {
    }
    pub struct createdAt_gte;
    impl ::cynic::schema::Field for createdAt_gte {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt_gte";
    }
    impl ::cynic::schema::HasInputField<createdAt_gte, Option<super::DateTime>>
        for super::TagWhereInput
    {
    }
    pub struct updatedAt;
    impl ::cynic::schema::Field for updatedAt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt";
    }
    impl ::cynic::schema::HasInputField<updatedAt, Option<super::DateTime>> for super::TagWhereInput {}
    pub struct updatedAt_not;
    impl ::cynic::schema::Field for updatedAt_not {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt_not";
    }
    impl ::cynic::schema::HasInputField<updatedAt_not, Option<super::DateTime>>
        for super::TagWhereInput
    {
    }
    pub struct updatedAt_in;
    impl ::cynic::schema::Field for updatedAt_in {
        type Type = Option<Vec<super::DateTime>>;
        const NAME: &'static str = "updatedAt_in";
    }
    impl ::cynic::schema::HasInputField<updatedAt_in, Option<Vec<super::DateTime>>>
        for super::TagWhereInput
    {
    }
    pub struct updatedAt_not_in;
    impl ::cynic::schema::Field for updatedAt_not_in {
        type Type = Option<Vec<super::DateTime>>;
        const NAME: &'static str = "updatedAt_not_in";
    }
    impl ::cynic::schema::HasInputField<updatedAt_not_in, Option<Vec<super::DateTime>>>
        for super::TagWhereInput
    {
    }
    pub struct updatedAt_lt;
    impl ::cynic::schema::Field for updatedAt_lt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt_lt";
    }
    impl ::cynic::schema::HasInputField<updatedAt_lt, Option<super::DateTime>>
        for super::TagWhereInput
    {
    }
    pub struct updatedAt_lte;
    impl ::cynic::schema::Field for updatedAt_lte {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt_lte";
    }
    impl ::cynic::schema::HasInputField<updatedAt_lte, Option<super::DateTime>>
        for super::TagWhereInput
    {
    }
    pub struct updatedAt_gt;
    impl ::cynic::schema::Field for updatedAt_gt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt_gt";
    }
    impl ::cynic::schema::HasInputField<updatedAt_gt, Option<super::DateTime>>
        for super::TagWhereInput
    {
    }
    pub struct updatedAt_gte;
    impl ::cynic::schema::Field for updatedAt_gte {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt_gte";
    }
    impl ::cynic::schema::HasInputField<updatedAt_gte, Option<super::DateTime>>
        for super::TagWhereInput
    {
    }
    pub struct AND;
    impl ::cynic::schema::Field for AND {
        type Type = Option<Vec<super::TagWhereInput>>;
        const NAME: &'static str = "AND";
    }
    impl ::cynic::schema::HasInputField<AND, Option<Vec<super::TagWhereInput>>>
        for super::TagWhereInput
    {
    }
    pub struct OR;
    impl ::cynic::schema::Field for OR {
        type Type = Option<Vec<super::TagWhereInput>>;
        const NAME: &'static str = "OR";
    }
    impl ::cynic::schema::HasInputField<OR, Option<Vec<super::TagWhereInput>>>
        for super::TagWhereInput
    {
    }
    pub struct NOT;
    impl ::cynic::schema::Field for NOT {
        type Type = Option<Vec<super::TagWhereInput>>;
        const NAME: &'static str = "NOT";
    }
    impl ::cynic::schema::HasInputField<NOT, Option<Vec<super::TagWhereInput>>>
        for super::TagWhereInput
    {
    }
}
pub struct UpdateCompanyInput;
impl ::cynic::schema::InputObjectMarker for UpdateCompanyInput {}
pub mod update_company_input_fields {
    pub struct id;
    impl ::cynic::schema::Field for id {
        type Type = super::ID;
        const NAME: &'static str = "id";
    }
    impl ::cynic::schema::HasInputField<id, super::ID> for super::UpdateCompanyInput {}
    pub struct logoUrl;
    impl ::cynic::schema::Field for logoUrl {
        type Type = super::String;
        const NAME: &'static str = "logoUrl";
    }
    impl ::cynic::schema::HasInputField<logoUrl, super::String> for super::UpdateCompanyInput {}
}
pub struct UpdateJobInput;
impl ::cynic::schema::InputObjectMarker for UpdateJobInput {}
pub mod update_job_input_fields {
    pub struct id;
    impl ::cynic::schema::Field for id {
        type Type = super::ID;
        const NAME: &'static str = "id";
    }
    impl ::cynic::schema::HasInputField<id, super::ID> for super::UpdateJobInput {}
    pub struct description;
    impl ::cynic::schema::Field for description {
        type Type = super::String;
        const NAME: &'static str = "description";
    }
    impl ::cynic::schema::HasInputField<description, super::String> for super::UpdateJobInput {}
}
pub struct User;
pub mod user_fields {
    pub struct id;
    impl ::cynic::schema::Field for id {
        type Type = super::ID;
        const NAME: &'static str = "id";
    }
    impl ::cynic::schema::HasField<id> for super::User {
        type Type = super::ID;
    }
    pub struct name;
    impl ::cynic::schema::Field for name {
        type Type = Option<super::String>;
        const NAME: &'static str = "name";
    }
    impl ::cynic::schema::HasField<name> for super::User {
        type Type = Option<super::String>;
    }
    pub struct email;
    impl ::cynic::schema::Field for email {
        type Type = super::String;
        const NAME: &'static str = "email";
    }
    impl ::cynic::schema::HasField<email> for super::User {
        type Type = super::String;
    }
    pub struct subscribe;
    impl ::cynic::schema::Field for subscribe {
        type Type = super::Boolean;
        const NAME: &'static str = "subscribe";
    }
    impl ::cynic::schema::HasField<subscribe> for super::User {
        type Type = super::Boolean;
    }
    pub struct createdAt;
    impl ::cynic::schema::Field for createdAt {
        type Type = super::DateTime;
        const NAME: &'static str = "createdAt";
    }
    impl ::cynic::schema::HasField<createdAt> for super::User {
        type Type = super::DateTime;
    }
    pub struct updatedAt;
    impl ::cynic::schema::Field for updatedAt {
        type Type = super::DateTime;
        const NAME: &'static str = "updatedAt";
    }
    impl ::cynic::schema::HasField<updatedAt> for super::User {
        type Type = super::DateTime;
    }
}
impl ::cynic::schema::NamedType for City {
    const NAME: &'static str = "City";
}
impl ::cynic::schema::NamedType for Commitment {
    const NAME: &'static str = "Commitment";
}
impl ::cynic::schema::NamedType for Company {
    const NAME: &'static str = "Company";
}
impl ::cynic::schema::NamedType for Country {
    const NAME: &'static str = "Country";
}
impl ::cynic::schema::NamedType for Job {
    const NAME: &'static str = "Job";
}
impl ::cynic::schema::NamedType for Location {
    const NAME: &'static str = "Location";
}
impl ::cynic::schema::NamedType for Mutation {
    const NAME: &'static str = "Mutation";
}
impl ::cynic::schema::NamedType for Query {
    const NAME: &'static str = "Query";
}
impl ::cynic::schema::NamedType for Remote {
    const NAME: &'static str = "Remote";
}
impl ::cynic::schema::NamedType for Tag {
    const NAME: &'static str = "Tag";
}
impl ::cynic::schema::NamedType for User {
    const NAME: &'static str = "User";
}
pub type Boolean = bool;
pub type String = std::string::String;
pub type Float = f64;
pub type Int = i32;
pub type ID = ::cynic::Id;
pub mod variable {
    use cynic::variables::VariableType;
    #[doc = r" Used to determine the type of a given variable that"]
    #[doc = r" appears in an argument struct."]
    pub trait Variable {
        const TYPE: VariableType;
    }
    impl<T> Variable for &T
    where
        T: Variable,
    {
        const TYPE: VariableType = T::TYPE;
    }
    impl<T> Variable for Option<T>
    where
        T: Variable,
    {
        const TYPE: VariableType = VariableType::Nullable(&T::TYPE);
    }
    impl<T> Variable for Vec<T>
    where
        T: Variable,
    {
        const TYPE: VariableType = VariableType::List(&T::TYPE);
    }
    impl<T> Variable for Box<T>
    where
        T: Variable,
    {
        const TYPE: VariableType = T::TYPE;
    }
    impl<T> Variable for std::rc::Rc<T>
    where
        T: Variable,
    {
        const TYPE: VariableType = T::TYPE;
    }
    impl<T> Variable for std::sync::Arc<T>
    where
        T: Variable,
    {
        const TYPE: VariableType = T::TYPE;
    }
    impl Variable for bool {
        const TYPE: VariableType = VariableType::Named("Boolean");
    }
    impl Variable for String {
        const TYPE: VariableType = VariableType::Named("String");
    }
    impl Variable for f64 {
        const TYPE: VariableType = VariableType::Named("Float");
    }
    impl Variable for i32 {
        const TYPE: VariableType = VariableType::Named("Int");
    }
    impl Variable for ::cynic::Id {
        const TYPE: VariableType = VariableType::Named("ID");
    }
}

