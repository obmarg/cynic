---
source: cynic-codegen/tests/use-schema.rs
expression: "format_code(format!(\"{}\", tokens))"
---
impl ::cynic::schema::QueryRoot for Query {}
impl ::cynic::schema::MutationRoot for Mutation {}
pub struct City;
pub struct CityOrderByInput {}
pub struct CityWhereInput;
impl ::cynic::schema::InputObjectMarker for CityWhereInput {}
pub struct Commitment;
pub struct CommitmentWhereInput;
impl ::cynic::schema::InputObjectMarker for CommitmentWhereInput {}
pub struct Company;
pub struct CompanyWhereInput;
impl ::cynic::schema::InputObjectMarker for CompanyWhereInput {}
pub struct Country;
pub struct CountryOrderByInput {}
pub struct CountryWhereInput;
impl ::cynic::schema::InputObjectMarker for CountryWhereInput {}
pub struct DateTime {}
impl ::cynic::schema::NamedType for DateTime {
    const NAME: &'static str = "DateTime";
}
pub struct Job;
pub struct JobInput;
impl ::cynic::schema::InputObjectMarker for JobInput {}
pub struct JobOrderByInput {}
pub struct JobWhereInput;
impl ::cynic::schema::InputObjectMarker for JobWhereInput {}
pub struct JobsInput;
impl ::cynic::schema::InputObjectMarker for JobsInput {}
pub struct Location;
pub struct LocationInput;
impl ::cynic::schema::InputObjectMarker for LocationInput {}
pub struct LocationsInput;
impl ::cynic::schema::InputObjectMarker for LocationsInput {}
pub struct Mutation;
pub struct PostJobInput;
impl ::cynic::schema::InputObjectMarker for PostJobInput {}
pub struct Query;
pub struct Remote;
pub struct RemoteOrderByInput {}
pub struct RemoteWhereInput;
impl ::cynic::schema::InputObjectMarker for RemoteWhereInput {}
pub struct SubscribeInput;
impl ::cynic::schema::InputObjectMarker for SubscribeInput {}
pub struct Tag;
pub struct TagOrderByInput {}
pub struct TagWhereInput;
impl ::cynic::schema::InputObjectMarker for TagWhereInput {}
pub struct UpdateCompanyInput;
impl ::cynic::schema::InputObjectMarker for UpdateCompanyInput {}
pub struct UpdateJobInput;
impl ::cynic::schema::InputObjectMarker for UpdateJobInput {}
pub struct User;
impl ::cynic::schema::NamedType for City {
    const NAME: &'static str = "City";
}
impl ::cynic::schema::NamedType for Commitment {
    const NAME: &'static str = "Commitment";
}
impl ::cynic::schema::NamedType for Company {
    const NAME: &'static str = "Company";
}
impl ::cynic::schema::NamedType for Country {
    const NAME: &'static str = "Country";
}
impl ::cynic::schema::NamedType for Job {
    const NAME: &'static str = "Job";
}
impl ::cynic::schema::NamedType for Location {
    const NAME: &'static str = "Location";
}
impl ::cynic::schema::NamedType for Mutation {
    const NAME: &'static str = "Mutation";
}
impl ::cynic::schema::NamedType for Query {
    const NAME: &'static str = "Query";
}
impl ::cynic::schema::NamedType for Remote {
    const NAME: &'static str = "Remote";
}
impl ::cynic::schema::NamedType for Tag {
    const NAME: &'static str = "Tag";
}
impl ::cynic::schema::NamedType for User {
    const NAME: &'static str = "User";
}
#[allow(non_snake_case, non_camel_case_types)]
pub mod __fields {
    pub mod City {
        pub struct id;
        impl ::cynic::schema::Field for id {
            type Type = super::super::ID;
            const NAME: &'static str = "id";
        }
        impl ::cynic::schema::HasField<id> for super::super::City {
            type Type = super::super::ID;
        }
        pub struct name;
        impl ::cynic::schema::Field for name {
            type Type = super::super::String;
            const NAME: &'static str = "name";
        }
        impl ::cynic::schema::HasField<name> for super::super::City {
            type Type = super::super::String;
        }
        pub struct slug;
        impl ::cynic::schema::Field for slug {
            type Type = super::super::String;
            const NAME: &'static str = "slug";
        }
        impl ::cynic::schema::HasField<slug> for super::super::City {
            type Type = super::super::String;
        }
        pub struct country;
        impl ::cynic::schema::Field for country {
            type Type = super::super::Country;
            const NAME: &'static str = "country";
        }
        impl ::cynic::schema::HasField<country> for super::super::City {
            type Type = super::super::Country;
        }
        pub struct r#type;
        impl ::cynic::schema::Field for r#type {
            type Type = super::super::String;
            const NAME: &'static str = "type";
        }
        impl ::cynic::schema::HasField<r#type> for super::super::City {
            type Type = super::super::String;
        }
        pub struct jobs;
        impl ::cynic::schema::Field for jobs {
            type Type = Option<Vec<super::super::Job>>;
            const NAME: &'static str = "jobs";
        }
        impl ::cynic::schema::HasField<jobs> for super::super::City {
            type Type = Option<Vec<super::super::Job>>;
        }
        pub mod _jobs_arguments {
            pub struct r#where;
            impl ::cynic::schema::HasArgument<r#where> for super::jobs {
                type ArgumentType = Option<super::super::super::JobWhereInput>;
                const NAME: &'static str = "where";
            }
            pub struct orderBy;
            impl ::cynic::schema::HasArgument<orderBy> for super::jobs {
                type ArgumentType = Option<super::super::super::JobOrderByInput>;
                const NAME: &'static str = "orderBy";
            }
            pub struct skip;
            impl ::cynic::schema::HasArgument<skip> for super::jobs {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "skip";
            }
            pub struct after;
            impl ::cynic::schema::HasArgument<after> for super::jobs {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "after";
            }
            pub struct before;
            impl ::cynic::schema::HasArgument<before> for super::jobs {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "before";
            }
            pub struct first;
            impl ::cynic::schema::HasArgument<first> for super::jobs {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "first";
            }
            pub struct last;
            impl ::cynic::schema::HasArgument<last> for super::jobs {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "last";
            }
        }
        pub struct createdAt;
        impl ::cynic::schema::Field for createdAt {
            type Type = super::super::DateTime;
            const NAME: &'static str = "createdAt";
        }
        impl ::cynic::schema::HasField<createdAt> for super::super::City {
            type Type = super::super::DateTime;
        }
        pub struct updatedAt;
        impl ::cynic::schema::Field for updatedAt {
            type Type = super::super::DateTime;
            const NAME: &'static str = "updatedAt";
        }
        impl ::cynic::schema::HasField<updatedAt> for super::super::City {
            type Type = super::super::DateTime;
        }
        pub struct __typename;
        impl ::cynic::schema::Field for __typename {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
        impl ::cynic::schema::HasField<__typename> for super::super::City {
            type Type = super::super::String;
        }
    }
    pub mod CityWhereInput {
        pub struct id;
        impl ::cynic::schema::Field for id {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id";
        }
        impl ::cynic::schema::HasInputField<id, Option<super::super::ID>> for super::super::CityWhereInput {}
        pub struct id_not;
        impl ::cynic::schema::Field for id_not {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_not";
        }
        impl ::cynic::schema::HasInputField<id_not, Option<super::super::ID>>
            for super::super::CityWhereInput
        {
        }
        pub struct id_in;
        impl ::cynic::schema::Field for id_in {
            type Type = Option<Vec<super::super::ID>>;
            const NAME: &'static str = "id_in";
        }
        impl ::cynic::schema::HasInputField<id_in, Option<Vec<super::super::ID>>>
            for super::super::CityWhereInput
        {
        }
        pub struct id_not_in;
        impl ::cynic::schema::Field for id_not_in {
            type Type = Option<Vec<super::super::ID>>;
            const NAME: &'static str = "id_not_in";
        }
        impl ::cynic::schema::HasInputField<id_not_in, Option<Vec<super::super::ID>>>
            for super::super::CityWhereInput
        {
        }
        pub struct id_lt;
        impl ::cynic::schema::Field for id_lt {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_lt";
        }
        impl ::cynic::schema::HasInputField<id_lt, Option<super::super::ID>>
            for super::super::CityWhereInput
        {
        }
        pub struct id_lte;
        impl ::cynic::schema::Field for id_lte {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_lte";
        }
        impl ::cynic::schema::HasInputField<id_lte, Option<super::super::ID>>
            for super::super::CityWhereInput
        {
        }
        pub struct id_gt;
        impl ::cynic::schema::Field for id_gt {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_gt";
        }
        impl ::cynic::schema::HasInputField<id_gt, Option<super::super::ID>>
            for super::super::CityWhereInput
        {
        }
        pub struct id_gte;
        impl ::cynic::schema::Field for id_gte {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_gte";
        }
        impl ::cynic::schema::HasInputField<id_gte, Option<super::super::ID>>
            for super::super::CityWhereInput
        {
        }
        pub struct id_contains;
        impl ::cynic::schema::Field for id_contains {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_contains";
        }
        impl ::cynic::schema::HasInputField<id_contains, Option<super::super::ID>>
            for super::super::CityWhereInput
        {
        }
        pub struct id_not_contains;
        impl ::cynic::schema::Field for id_not_contains {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_not_contains";
        }
        impl ::cynic::schema::HasInputField<id_not_contains, Option<super::super::ID>>
            for super::super::CityWhereInput
        {
        }
        pub struct id_starts_with;
        impl ::cynic::schema::Field for id_starts_with {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_starts_with";
        }
        impl ::cynic::schema::HasInputField<id_starts_with, Option<super::super::ID>>
            for super::super::CityWhereInput
        {
        }
        pub struct id_not_starts_with;
        impl ::cynic::schema::Field for id_not_starts_with {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_not_starts_with";
        }
        impl ::cynic::schema::HasInputField<id_not_starts_with, Option<super::super::ID>>
            for super::super::CityWhereInput
        {
        }
        pub struct id_ends_with;
        impl ::cynic::schema::Field for id_ends_with {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_ends_with";
        }
        impl ::cynic::schema::HasInputField<id_ends_with, Option<super::super::ID>>
            for super::super::CityWhereInput
        {
        }
        pub struct id_not_ends_with;
        impl ::cynic::schema::Field for id_not_ends_with {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_not_ends_with";
        }
        impl ::cynic::schema::HasInputField<id_not_ends_with, Option<super::super::ID>>
            for super::super::CityWhereInput
        {
        }
        pub struct name;
        impl ::cynic::schema::Field for name {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name";
        }
        impl ::cynic::schema::HasInputField<name, Option<super::super::String>>
            for super::super::CityWhereInput
        {
        }
        pub struct name_not;
        impl ::cynic::schema::Field for name_not {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_not";
        }
        impl ::cynic::schema::HasInputField<name_not, Option<super::super::String>>
            for super::super::CityWhereInput
        {
        }
        pub struct name_in;
        impl ::cynic::schema::Field for name_in {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "name_in";
        }
        impl ::cynic::schema::HasInputField<name_in, Option<Vec<super::super::String>>>
            for super::super::CityWhereInput
        {
        }
        pub struct name_not_in;
        impl ::cynic::schema::Field for name_not_in {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "name_not_in";
        }
        impl ::cynic::schema::HasInputField<name_not_in, Option<Vec<super::super::String>>>
            for super::super::CityWhereInput
        {
        }
        pub struct name_lt;
        impl ::cynic::schema::Field for name_lt {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_lt";
        }
        impl ::cynic::schema::HasInputField<name_lt, Option<super::super::String>>
            for super::super::CityWhereInput
        {
        }
        pub struct name_lte;
        impl ::cynic::schema::Field for name_lte {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_lte";
        }
        impl ::cynic::schema::HasInputField<name_lte, Option<super::super::String>>
            for super::super::CityWhereInput
        {
        }
        pub struct name_gt;
        impl ::cynic::schema::Field for name_gt {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_gt";
        }
        impl ::cynic::schema::HasInputField<name_gt, Option<super::super::String>>
            for super::super::CityWhereInput
        {
        }
        pub struct name_gte;
        impl ::cynic::schema::Field for name_gte {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_gte";
        }
        impl ::cynic::schema::HasInputField<name_gte, Option<super::super::String>>
            for super::super::CityWhereInput
        {
        }
        pub struct name_contains;
        impl ::cynic::schema::Field for name_contains {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_contains";
        }
        impl ::cynic::schema::HasInputField<name_contains, Option<super::super::String>>
            for super::super::CityWhereInput
        {
        }
        pub struct name_not_contains;
        impl ::cynic::schema::Field for name_not_contains {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_not_contains";
        }
        impl ::cynic::schema::HasInputField<name_not_contains, Option<super::super::String>>
            for super::super::CityWhereInput
        {
        }
        pub struct name_starts_with;
        impl ::cynic::schema::Field for name_starts_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_starts_with";
        }
        impl ::cynic::schema::HasInputField<name_starts_with, Option<super::super::String>>
            for super::super::CityWhereInput
        {
        }
        pub struct name_not_starts_with;
        impl ::cynic::schema::Field for name_not_starts_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_not_starts_with";
        }
        impl ::cynic::schema::HasInputField<name_not_starts_with, Option<super::super::String>>
            for super::super::CityWhereInput
        {
        }
        pub struct name_ends_with;
        impl ::cynic::schema::Field for name_ends_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_ends_with";
        }
        impl ::cynic::schema::HasInputField<name_ends_with, Option<super::super::String>>
            for super::super::CityWhereInput
        {
        }
        pub struct name_not_ends_with;
        impl ::cynic::schema::Field for name_not_ends_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_not_ends_with";
        }
        impl ::cynic::schema::HasInputField<name_not_ends_with, Option<super::super::String>>
            for super::super::CityWhereInput
        {
        }
        pub struct slug;
        impl ::cynic::schema::Field for slug {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug";
        }
        impl ::cynic::schema::HasInputField<slug, Option<super::super::String>>
            for super::super::CityWhereInput
        {
        }
        pub struct slug_not;
        impl ::cynic::schema::Field for slug_not {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_not";
        }
        impl ::cynic::schema::HasInputField<slug_not, Option<super::super::String>>
            for super::super::CityWhereInput
        {
        }
        pub struct slug_in;
        impl ::cynic::schema::Field for slug_in {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "slug_in";
        }
        impl ::cynic::schema::HasInputField<slug_in, Option<Vec<super::super::String>>>
            for super::super::CityWhereInput
        {
        }
        pub struct slug_not_in;
        impl ::cynic::schema::Field for slug_not_in {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "slug_not_in";
        }
        impl ::cynic::schema::HasInputField<slug_not_in, Option<Vec<super::super::String>>>
            for super::super::CityWhereInput
        {
        }
        pub struct slug_lt;
        impl ::cynic::schema::Field for slug_lt {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_lt";
        }
        impl ::cynic::schema::HasInputField<slug_lt, Option<super::super::String>>
            for super::super::CityWhereInput
        {
        }
        pub struct slug_lte;
        impl ::cynic::schema::Field for slug_lte {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_lte";
        }
        impl ::cynic::schema::HasInputField<slug_lte, Option<super::super::String>>
            for super::super::CityWhereInput
        {
        }
        pub struct slug_gt;
        impl ::cynic::schema::Field for slug_gt {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_gt";
        }
        impl ::cynic::schema::HasInputField<slug_gt, Option<super::super::String>>
            for super::super::CityWhereInput
        {
        }
        pub struct slug_gte;
        impl ::cynic::schema::Field for slug_gte {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_gte";
        }
        impl ::cynic::schema::HasInputField<slug_gte, Option<super::super::String>>
            for super::super::CityWhereInput
        {
        }
        pub struct slug_contains;
        impl ::cynic::schema::Field for slug_contains {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_contains";
        }
        impl ::cynic::schema::HasInputField<slug_contains, Option<super::super::String>>
            for super::super::CityWhereInput
        {
        }
        pub struct slug_not_contains;
        impl ::cynic::schema::Field for slug_not_contains {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_not_contains";
        }
        impl ::cynic::schema::HasInputField<slug_not_contains, Option<super::super::String>>
            for super::super::CityWhereInput
        {
        }
        pub struct slug_starts_with;
        impl ::cynic::schema::Field for slug_starts_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_starts_with";
        }
        impl ::cynic::schema::HasInputField<slug_starts_with, Option<super::super::String>>
            for super::super::CityWhereInput
        {
        }
        pub struct slug_not_starts_with;
        impl ::cynic::schema::Field for slug_not_starts_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_not_starts_with";
        }
        impl ::cynic::schema::HasInputField<slug_not_starts_with, Option<super::super::String>>
            for super::super::CityWhereInput
        {
        }
        pub struct slug_ends_with;
        impl ::cynic::schema::Field for slug_ends_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_ends_with";
        }
        impl ::cynic::schema::HasInputField<slug_ends_with, Option<super::super::String>>
            for super::super::CityWhereInput
        {
        }
        pub struct slug_not_ends_with;
        impl ::cynic::schema::Field for slug_not_ends_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_not_ends_with";
        }
        impl ::cynic::schema::HasInputField<slug_not_ends_with, Option<super::super::String>>
            for super::super::CityWhereInput
        {
        }
        pub struct country;
        impl ::cynic::schema::Field for country {
            type Type = Option<super::super::CountryWhereInput>;
            const NAME: &'static str = "country";
        }
        impl ::cynic::schema::HasInputField<country, Option<super::super::CountryWhereInput>>
            for super::super::CityWhereInput
        {
        }
        pub struct r#type;
        impl ::cynic::schema::Field for r#type {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type";
        }
        impl ::cynic::schema::HasInputField<r#type, Option<super::super::String>>
            for super::super::CityWhereInput
        {
        }
        pub struct type_not;
        impl ::cynic::schema::Field for type_not {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type_not";
        }
        impl ::cynic::schema::HasInputField<type_not, Option<super::super::String>>
            for super::super::CityWhereInput
        {
        }
        pub struct type_in;
        impl ::cynic::schema::Field for type_in {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "type_in";
        }
        impl ::cynic::schema::HasInputField<type_in, Option<Vec<super::super::String>>>
            for super::super::CityWhereInput
        {
        }
        pub struct type_not_in;
        impl ::cynic::schema::Field for type_not_in {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "type_not_in";
        }
        impl ::cynic::schema::HasInputField<type_not_in, Option<Vec<super::super::String>>>
            for super::super::CityWhereInput
        {
        }
        pub struct type_lt;
        impl ::cynic::schema::Field for type_lt {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type_lt";
        }
        impl ::cynic::schema::HasInputField<type_lt, Option<super::super::String>>
            for super::super::CityWhereInput
        {
        }
        pub struct type_lte;
        impl ::cynic::schema::Field for type_lte {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type_lte";
        }
        impl ::cynic::schema::HasInputField<type_lte, Option<super::super::String>>
            for super::super::CityWhereInput
        {
        }
        pub struct type_gt;
        impl ::cynic::schema::Field for type_gt {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type_gt";
        }
        impl ::cynic::schema::HasInputField<type_gt, Option<super::super::String>>
            for super::super::CityWhereInput
        {
        }
        pub struct type_gte;
        impl ::cynic::schema::Field for type_gte {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type_gte";
        }
        impl ::cynic::schema::HasInputField<type_gte, Option<super::super::String>>
            for super::super::CityWhereInput
        {
        }
        pub struct type_contains;
        impl ::cynic::schema::Field for type_contains {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type_contains";
        }
        impl ::cynic::schema::HasInputField<type_contains, Option<super::super::String>>
            for super::super::CityWhereInput
        {
        }
        pub struct type_not_contains;
        impl ::cynic::schema::Field for type_not_contains {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type_not_contains";
        }
        impl ::cynic::schema::HasInputField<type_not_contains, Option<super::super::String>>
            for super::super::CityWhereInput
        {
        }
        pub struct type_starts_with;
        impl ::cynic::schema::Field for type_starts_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type_starts_with";
        }
        impl ::cynic::schema::HasInputField<type_starts_with, Option<super::super::String>>
            for super::super::CityWhereInput
        {
        }
        pub struct type_not_starts_with;
        impl ::cynic::schema::Field for type_not_starts_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type_not_starts_with";
        }
        impl ::cynic::schema::HasInputField<type_not_starts_with, Option<super::super::String>>
            for super::super::CityWhereInput
        {
        }
        pub struct type_ends_with;
        impl ::cynic::schema::Field for type_ends_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type_ends_with";
        }
        impl ::cynic::schema::HasInputField<type_ends_with, Option<super::super::String>>
            for super::super::CityWhereInput
        {
        }
        pub struct type_not_ends_with;
        impl ::cynic::schema::Field for type_not_ends_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type_not_ends_with";
        }
        impl ::cynic::schema::HasInputField<type_not_ends_with, Option<super::super::String>>
            for super::super::CityWhereInput
        {
        }
        pub struct jobs_every;
        impl ::cynic::schema::Field for jobs_every {
            type Type = Option<super::super::JobWhereInput>;
            const NAME: &'static str = "jobs_every";
        }
        impl ::cynic::schema::HasInputField<jobs_every, Option<super::super::JobWhereInput>>
            for super::super::CityWhereInput
        {
        }
        pub struct jobs_some;
        impl ::cynic::schema::Field for jobs_some {
            type Type = Option<super::super::JobWhereInput>;
            const NAME: &'static str = "jobs_some";
        }
        impl ::cynic::schema::HasInputField<jobs_some, Option<super::super::JobWhereInput>>
            for super::super::CityWhereInput
        {
        }
        pub struct jobs_none;
        impl ::cynic::schema::Field for jobs_none {
            type Type = Option<super::super::JobWhereInput>;
            const NAME: &'static str = "jobs_none";
        }
        impl ::cynic::schema::HasInputField<jobs_none, Option<super::super::JobWhereInput>>
            for super::super::CityWhereInput
        {
        }
        pub struct createdAt;
        impl ::cynic::schema::Field for createdAt {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt";
        }
        impl ::cynic::schema::HasInputField<createdAt, Option<super::super::DateTime>>
            for super::super::CityWhereInput
        {
        }
        pub struct createdAt_not;
        impl ::cynic::schema::Field for createdAt_not {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt_not";
        }
        impl ::cynic::schema::HasInputField<createdAt_not, Option<super::super::DateTime>>
            for super::super::CityWhereInput
        {
        }
        pub struct createdAt_in;
        impl ::cynic::schema::Field for createdAt_in {
            type Type = Option<Vec<super::super::DateTime>>;
            const NAME: &'static str = "createdAt_in";
        }
        impl ::cynic::schema::HasInputField<createdAt_in, Option<Vec<super::super::DateTime>>>
            for super::super::CityWhereInput
        {
        }
        pub struct createdAt_not_in;
        impl ::cynic::schema::Field for createdAt_not_in {
            type Type = Option<Vec<super::super::DateTime>>;
            const NAME: &'static str = "createdAt_not_in";
        }
        impl ::cynic::schema::HasInputField<createdAt_not_in, Option<Vec<super::super::DateTime>>>
            for super::super::CityWhereInput
        {
        }
        pub struct createdAt_lt;
        impl ::cynic::schema::Field for createdAt_lt {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt_lt";
        }
        impl ::cynic::schema::HasInputField<createdAt_lt, Option<super::super::DateTime>>
            for super::super::CityWhereInput
        {
        }
        pub struct createdAt_lte;
        impl ::cynic::schema::Field for createdAt_lte {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt_lte";
        }
        impl ::cynic::schema::HasInputField<createdAt_lte, Option<super::super::DateTime>>
            for super::super::CityWhereInput
        {
        }
        pub struct createdAt_gt;
        impl ::cynic::schema::Field for createdAt_gt {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt_gt";
        }
        impl ::cynic::schema::HasInputField<createdAt_gt, Option<super::super::DateTime>>
            for super::super::CityWhereInput
        {
        }
        pub struct createdAt_gte;
        impl ::cynic::schema::Field for createdAt_gte {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt_gte";
        }
        impl ::cynic::schema::HasInputField<createdAt_gte, Option<super::super::DateTime>>
            for super::super::CityWhereInput
        {
        }
        pub struct updatedAt;
        impl ::cynic::schema::Field for updatedAt {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt";
        }
        impl ::cynic::schema::HasInputField<updatedAt, Option<super::super::DateTime>>
            for super::super::CityWhereInput
        {
        }
        pub struct updatedAt_not;
        impl ::cynic::schema::Field for updatedAt_not {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt_not";
        }
        impl ::cynic::schema::HasInputField<updatedAt_not, Option<super::super::DateTime>>
            for super::super::CityWhereInput
        {
        }
        pub struct updatedAt_in;
        impl ::cynic::schema::Field for updatedAt_in {
            type Type = Option<Vec<super::super::DateTime>>;
            const NAME: &'static str = "updatedAt_in";
        }
        impl ::cynic::schema::HasInputField<updatedAt_in, Option<Vec<super::super::DateTime>>>
            for super::super::CityWhereInput
        {
        }
        pub struct updatedAt_not_in;
        impl ::cynic::schema::Field for updatedAt_not_in {
            type Type = Option<Vec<super::super::DateTime>>;
            const NAME: &'static str = "updatedAt_not_in";
        }
        impl ::cynic::schema::HasInputField<updatedAt_not_in, Option<Vec<super::super::DateTime>>>
            for super::super::CityWhereInput
        {
        }
        pub struct updatedAt_lt;
        impl ::cynic::schema::Field for updatedAt_lt {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt_lt";
        }
        impl ::cynic::schema::HasInputField<updatedAt_lt, Option<super::super::DateTime>>
            for super::super::CityWhereInput
        {
        }
        pub struct updatedAt_lte;
        impl ::cynic::schema::Field for updatedAt_lte {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt_lte";
        }
        impl ::cynic::schema::HasInputField<updatedAt_lte, Option<super::super::DateTime>>
            for super::super::CityWhereInput
        {
        }
        pub struct updatedAt_gt;
        impl ::cynic::schema::Field for updatedAt_gt {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt_gt";
        }
        impl ::cynic::schema::HasInputField<updatedAt_gt, Option<super::super::DateTime>>
            for super::super::CityWhereInput
        {
        }
        pub struct updatedAt_gte;
        impl ::cynic::schema::Field for updatedAt_gte {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt_gte";
        }
        impl ::cynic::schema::HasInputField<updatedAt_gte, Option<super::super::DateTime>>
            for super::super::CityWhereInput
        {
        }
        pub struct AND;
        impl ::cynic::schema::Field for AND {
            type Type = Option<Vec<super::super::CityWhereInput>>;
            const NAME: &'static str = "AND";
        }
        impl ::cynic::schema::HasInputField<AND, Option<Vec<super::super::CityWhereInput>>>
            for super::super::CityWhereInput
        {
        }
        pub struct OR;
        impl ::cynic::schema::Field for OR {
            type Type = Option<Vec<super::super::CityWhereInput>>;
            const NAME: &'static str = "OR";
        }
        impl ::cynic::schema::HasInputField<OR, Option<Vec<super::super::CityWhereInput>>>
            for super::super::CityWhereInput
        {
        }
        pub struct NOT;
        impl ::cynic::schema::Field for NOT {
            type Type = Option<Vec<super::super::CityWhereInput>>;
            const NAME: &'static str = "NOT";
        }
        impl ::cynic::schema::HasInputField<NOT, Option<Vec<super::super::CityWhereInput>>>
            for super::super::CityWhereInput
        {
        }
    }
    pub mod Commitment {
        pub struct id;
        impl ::cynic::schema::Field for id {
            type Type = super::super::ID;
            const NAME: &'static str = "id";
        }
        impl ::cynic::schema::HasField<id> for super::super::Commitment {
            type Type = super::super::ID;
        }
        pub struct title;
        impl ::cynic::schema::Field for title {
            type Type = super::super::String;
            const NAME: &'static str = "title";
        }
        impl ::cynic::schema::HasField<title> for super::super::Commitment {
            type Type = super::super::String;
        }
        pub struct slug;
        impl ::cynic::schema::Field for slug {
            type Type = super::super::String;
            const NAME: &'static str = "slug";
        }
        impl ::cynic::schema::HasField<slug> for super::super::Commitment {
            type Type = super::super::String;
        }
        pub struct jobs;
        impl ::cynic::schema::Field for jobs {
            type Type = Option<Vec<super::super::Job>>;
            const NAME: &'static str = "jobs";
        }
        impl ::cynic::schema::HasField<jobs> for super::super::Commitment {
            type Type = Option<Vec<super::super::Job>>;
        }
        pub mod _jobs_arguments {
            pub struct r#where;
            impl ::cynic::schema::HasArgument<r#where> for super::jobs {
                type ArgumentType = Option<super::super::super::JobWhereInput>;
                const NAME: &'static str = "where";
            }
            pub struct orderBy;
            impl ::cynic::schema::HasArgument<orderBy> for super::jobs {
                type ArgumentType = Option<super::super::super::JobOrderByInput>;
                const NAME: &'static str = "orderBy";
            }
            pub struct skip;
            impl ::cynic::schema::HasArgument<skip> for super::jobs {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "skip";
            }
            pub struct after;
            impl ::cynic::schema::HasArgument<after> for super::jobs {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "after";
            }
            pub struct before;
            impl ::cynic::schema::HasArgument<before> for super::jobs {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "before";
            }
            pub struct first;
            impl ::cynic::schema::HasArgument<first> for super::jobs {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "first";
            }
            pub struct last;
            impl ::cynic::schema::HasArgument<last> for super::jobs {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "last";
            }
        }
        pub struct createdAt;
        impl ::cynic::schema::Field for createdAt {
            type Type = super::super::DateTime;
            const NAME: &'static str = "createdAt";
        }
        impl ::cynic::schema::HasField<createdAt> for super::super::Commitment {
            type Type = super::super::DateTime;
        }
        pub struct updatedAt;
        impl ::cynic::schema::Field for updatedAt {
            type Type = super::super::DateTime;
            const NAME: &'static str = "updatedAt";
        }
        impl ::cynic::schema::HasField<updatedAt> for super::super::Commitment {
            type Type = super::super::DateTime;
        }
        pub struct __typename;
        impl ::cynic::schema::Field for __typename {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
        impl ::cynic::schema::HasField<__typename> for super::super::Commitment {
            type Type = super::super::String;
        }
    }
    pub mod CommitmentWhereInput {
        pub struct id;
        impl ::cynic::schema::Field for id {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id";
        }
        impl ::cynic::schema::HasInputField<id, Option<super::super::ID>>
            for super::super::CommitmentWhereInput
        {
        }
        pub struct id_not;
        impl ::cynic::schema::Field for id_not {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_not";
        }
        impl ::cynic::schema::HasInputField<id_not, Option<super::super::ID>>
            for super::super::CommitmentWhereInput
        {
        }
        pub struct id_in;
        impl ::cynic::schema::Field for id_in {
            type Type = Option<Vec<super::super::ID>>;
            const NAME: &'static str = "id_in";
        }
        impl ::cynic::schema::HasInputField<id_in, Option<Vec<super::super::ID>>>
            for super::super::CommitmentWhereInput
        {
        }
        pub struct id_not_in;
        impl ::cynic::schema::Field for id_not_in {
            type Type = Option<Vec<super::super::ID>>;
            const NAME: &'static str = "id_not_in";
        }
        impl ::cynic::schema::HasInputField<id_not_in, Option<Vec<super::super::ID>>>
            for super::super::CommitmentWhereInput
        {
        }
        pub struct id_lt;
        impl ::cynic::schema::Field for id_lt {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_lt";
        }
        impl ::cynic::schema::HasInputField<id_lt, Option<super::super::ID>>
            for super::super::CommitmentWhereInput
        {
        }
        pub struct id_lte;
        impl ::cynic::schema::Field for id_lte {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_lte";
        }
        impl ::cynic::schema::HasInputField<id_lte, Option<super::super::ID>>
            for super::super::CommitmentWhereInput
        {
        }
        pub struct id_gt;
        impl ::cynic::schema::Field for id_gt {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_gt";
        }
        impl ::cynic::schema::HasInputField<id_gt, Option<super::super::ID>>
            for super::super::CommitmentWhereInput
        {
        }
        pub struct id_gte;
        impl ::cynic::schema::Field for id_gte {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_gte";
        }
        impl ::cynic::schema::HasInputField<id_gte, Option<super::super::ID>>
            for super::super::CommitmentWhereInput
        {
        }
        pub struct id_contains;
        impl ::cynic::schema::Field for id_contains {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_contains";
        }
        impl ::cynic::schema::HasInputField<id_contains, Option<super::super::ID>>
            for super::super::CommitmentWhereInput
        {
        }
        pub struct id_not_contains;
        impl ::cynic::schema::Field for id_not_contains {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_not_contains";
        }
        impl ::cynic::schema::HasInputField<id_not_contains, Option<super::super::ID>>
            for super::super::CommitmentWhereInput
        {
        }
        pub struct id_starts_with;
        impl ::cynic::schema::Field for id_starts_with {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_starts_with";
        }
        impl ::cynic::schema::HasInputField<id_starts_with, Option<super::super::ID>>
            for super::super::CommitmentWhereInput
        {
        }
        pub struct id_not_starts_with;
        impl ::cynic::schema::Field for id_not_starts_with {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_not_starts_with";
        }
        impl ::cynic::schema::HasInputField<id_not_starts_with, Option<super::super::ID>>
            for super::super::CommitmentWhereInput
        {
        }
        pub struct id_ends_with;
        impl ::cynic::schema::Field for id_ends_with {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_ends_with";
        }
        impl ::cynic::schema::HasInputField<id_ends_with, Option<super::super::ID>>
            for super::super::CommitmentWhereInput
        {
        }
        pub struct id_not_ends_with;
        impl ::cynic::schema::Field for id_not_ends_with {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_not_ends_with";
        }
        impl ::cynic::schema::HasInputField<id_not_ends_with, Option<super::super::ID>>
            for super::super::CommitmentWhereInput
        {
        }
        pub struct title;
        impl ::cynic::schema::Field for title {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "title";
        }
        impl ::cynic::schema::HasInputField<title, Option<super::super::String>>
            for super::super::CommitmentWhereInput
        {
        }
        pub struct title_not;
        impl ::cynic::schema::Field for title_not {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "title_not";
        }
        impl ::cynic::schema::HasInputField<title_not, Option<super::super::String>>
            for super::super::CommitmentWhereInput
        {
        }
        pub struct title_in;
        impl ::cynic::schema::Field for title_in {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "title_in";
        }
        impl ::cynic::schema::HasInputField<title_in, Option<Vec<super::super::String>>>
            for super::super::CommitmentWhereInput
        {
        }
        pub struct title_not_in;
        impl ::cynic::schema::Field for title_not_in {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "title_not_in";
        }
        impl ::cynic::schema::HasInputField<title_not_in, Option<Vec<super::super::String>>>
            for super::super::CommitmentWhereInput
        {
        }
        pub struct title_lt;
        impl ::cynic::schema::Field for title_lt {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "title_lt";
        }
        impl ::cynic::schema::HasInputField<title_lt, Option<super::super::String>>
            for super::super::CommitmentWhereInput
        {
        }
        pub struct title_lte;
        impl ::cynic::schema::Field for title_lte {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "title_lte";
        }
        impl ::cynic::schema::HasInputField<title_lte, Option<super::super::String>>
            for super::super::CommitmentWhereInput
        {
        }
        pub struct title_gt;
        impl ::cynic::schema::Field for title_gt {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "title_gt";
        }
        impl ::cynic::schema::HasInputField<title_gt, Option<super::super::String>>
            for super::super::CommitmentWhereInput
        {
        }
        pub struct title_gte;
        impl ::cynic::schema::Field for title_gte {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "title_gte";
        }
        impl ::cynic::schema::HasInputField<title_gte, Option<super::super::String>>
            for super::super::CommitmentWhereInput
        {
        }
        pub struct title_contains;
        impl ::cynic::schema::Field for title_contains {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "title_contains";
        }
        impl ::cynic::schema::HasInputField<title_contains, Option<super::super::String>>
            for super::super::CommitmentWhereInput
        {
        }
        pub struct title_not_contains;
        impl ::cynic::schema::Field for title_not_contains {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "title_not_contains";
        }
        impl ::cynic::schema::HasInputField<title_not_contains, Option<super::super::String>>
            for super::super::CommitmentWhereInput
        {
        }
        pub struct title_starts_with;
        impl ::cynic::schema::Field for title_starts_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "title_starts_with";
        }
        impl ::cynic::schema::HasInputField<title_starts_with, Option<super::super::String>>
            for super::super::CommitmentWhereInput
        {
        }
        pub struct title_not_starts_with;
        impl ::cynic::schema::Field for title_not_starts_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "title_not_starts_with";
        }
        impl ::cynic::schema::HasInputField<title_not_starts_with, Option<super::super::String>>
            for super::super::CommitmentWhereInput
        {
        }
        pub struct title_ends_with;
        impl ::cynic::schema::Field for title_ends_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "title_ends_with";
        }
        impl ::cynic::schema::HasInputField<title_ends_with, Option<super::super::String>>
            for super::super::CommitmentWhereInput
        {
        }
        pub struct title_not_ends_with;
        impl ::cynic::schema::Field for title_not_ends_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "title_not_ends_with";
        }
        impl ::cynic::schema::HasInputField<title_not_ends_with, Option<super::super::String>>
            for super::super::CommitmentWhereInput
        {
        }
        pub struct slug;
        impl ::cynic::schema::Field for slug {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug";
        }
        impl ::cynic::schema::HasInputField<slug, Option<super::super::String>>
            for super::super::CommitmentWhereInput
        {
        }
        pub struct slug_not;
        impl ::cynic::schema::Field for slug_not {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_not";
        }
        impl ::cynic::schema::HasInputField<slug_not, Option<super::super::String>>
            for super::super::CommitmentWhereInput
        {
        }
        pub struct slug_in;
        impl ::cynic::schema::Field for slug_in {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "slug_in";
        }
        impl ::cynic::schema::HasInputField<slug_in, Option<Vec<super::super::String>>>
            for super::super::CommitmentWhereInput
        {
        }
        pub struct slug_not_in;
        impl ::cynic::schema::Field for slug_not_in {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "slug_not_in";
        }
        impl ::cynic::schema::HasInputField<slug_not_in, Option<Vec<super::super::String>>>
            for super::super::CommitmentWhereInput
        {
        }
        pub struct slug_lt;
        impl ::cynic::schema::Field for slug_lt {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_lt";
        }
        impl ::cynic::schema::HasInputField<slug_lt, Option<super::super::String>>
            for super::super::CommitmentWhereInput
        {
        }
        pub struct slug_lte;
        impl ::cynic::schema::Field for slug_lte {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_lte";
        }
        impl ::cynic::schema::HasInputField<slug_lte, Option<super::super::String>>
            for super::super::CommitmentWhereInput
        {
        }
        pub struct slug_gt;
        impl ::cynic::schema::Field for slug_gt {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_gt";
        }
        impl ::cynic::schema::HasInputField<slug_gt, Option<super::super::String>>
            for super::super::CommitmentWhereInput
        {
        }
        pub struct slug_gte;
        impl ::cynic::schema::Field for slug_gte {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_gte";
        }
        impl ::cynic::schema::HasInputField<slug_gte, Option<super::super::String>>
            for super::super::CommitmentWhereInput
        {
        }
        pub struct slug_contains;
        impl ::cynic::schema::Field for slug_contains {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_contains";
        }
        impl ::cynic::schema::HasInputField<slug_contains, Option<super::super::String>>
            for super::super::CommitmentWhereInput
        {
        }
        pub struct slug_not_contains;
        impl ::cynic::schema::Field for slug_not_contains {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_not_contains";
        }
        impl ::cynic::schema::HasInputField<slug_not_contains, Option<super::super::String>>
            for super::super::CommitmentWhereInput
        {
        }
        pub struct slug_starts_with;
        impl ::cynic::schema::Field for slug_starts_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_starts_with";
        }
        impl ::cynic::schema::HasInputField<slug_starts_with, Option<super::super::String>>
            for super::super::CommitmentWhereInput
        {
        }
        pub struct slug_not_starts_with;
        impl ::cynic::schema::Field for slug_not_starts_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_not_starts_with";
        }
        impl ::cynic::schema::HasInputField<slug_not_starts_with, Option<super::super::String>>
            for super::super::CommitmentWhereInput
        {
        }
        pub struct slug_ends_with;
        impl ::cynic::schema::Field for slug_ends_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_ends_with";
        }
        impl ::cynic::schema::HasInputField<slug_ends_with, Option<super::super::String>>
            for super::super::CommitmentWhereInput
        {
        }
        pub struct slug_not_ends_with;
        impl ::cynic::schema::Field for slug_not_ends_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_not_ends_with";
        }
        impl ::cynic::schema::HasInputField<slug_not_ends_with, Option<super::super::String>>
            for super::super::CommitmentWhereInput
        {
        }
        pub struct jobs_every;
        impl ::cynic::schema::Field for jobs_every {
            type Type = Option<super::super::JobWhereInput>;
            const NAME: &'static str = "jobs_every";
        }
        impl ::cynic::schema::HasInputField<jobs_every, Option<super::super::JobWhereInput>>
            for super::super::CommitmentWhereInput
        {
        }
        pub struct jobs_some;
        impl ::cynic::schema::Field for jobs_some {
            type Type = Option<super::super::JobWhereInput>;
            const NAME: &'static str = "jobs_some";
        }
        impl ::cynic::schema::HasInputField<jobs_some, Option<super::super::JobWhereInput>>
            for super::super::CommitmentWhereInput
        {
        }
        pub struct jobs_none;
        impl ::cynic::schema::Field for jobs_none {
            type Type = Option<super::super::JobWhereInput>;
            const NAME: &'static str = "jobs_none";
        }
        impl ::cynic::schema::HasInputField<jobs_none, Option<super::super::JobWhereInput>>
            for super::super::CommitmentWhereInput
        {
        }
        pub struct createdAt;
        impl ::cynic::schema::Field for createdAt {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt";
        }
        impl ::cynic::schema::HasInputField<createdAt, Option<super::super::DateTime>>
            for super::super::CommitmentWhereInput
        {
        }
        pub struct createdAt_not;
        impl ::cynic::schema::Field for createdAt_not {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt_not";
        }
        impl ::cynic::schema::HasInputField<createdAt_not, Option<super::super::DateTime>>
            for super::super::CommitmentWhereInput
        {
        }
        pub struct createdAt_in;
        impl ::cynic::schema::Field for createdAt_in {
            type Type = Option<Vec<super::super::DateTime>>;
            const NAME: &'static str = "createdAt_in";
        }
        impl ::cynic::schema::HasInputField<createdAt_in, Option<Vec<super::super::DateTime>>>
            for super::super::CommitmentWhereInput
        {
        }
        pub struct createdAt_not_in;
        impl ::cynic::schema::Field for createdAt_not_in {
            type Type = Option<Vec<super::super::DateTime>>;
            const NAME: &'static str = "createdAt_not_in";
        }
        impl ::cynic::schema::HasInputField<createdAt_not_in, Option<Vec<super::super::DateTime>>>
            for super::super::CommitmentWhereInput
        {
        }
        pub struct createdAt_lt;
        impl ::cynic::schema::Field for createdAt_lt {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt_lt";
        }
        impl ::cynic::schema::HasInputField<createdAt_lt, Option<super::super::DateTime>>
            for super::super::CommitmentWhereInput
        {
        }
        pub struct createdAt_lte;
        impl ::cynic::schema::Field for createdAt_lte {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt_lte";
        }
        impl ::cynic::schema::HasInputField<createdAt_lte, Option<super::super::DateTime>>
            for super::super::CommitmentWhereInput
        {
        }
        pub struct createdAt_gt;
        impl ::cynic::schema::Field for createdAt_gt {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt_gt";
        }
        impl ::cynic::schema::HasInputField<createdAt_gt, Option<super::super::DateTime>>
            for super::super::CommitmentWhereInput
        {
        }
        pub struct createdAt_gte;
        impl ::cynic::schema::Field for createdAt_gte {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt_gte";
        }
        impl ::cynic::schema::HasInputField<createdAt_gte, Option<super::super::DateTime>>
            for super::super::CommitmentWhereInput
        {
        }
        pub struct updatedAt;
        impl ::cynic::schema::Field for updatedAt {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt";
        }
        impl ::cynic::schema::HasInputField<updatedAt, Option<super::super::DateTime>>
            for super::super::CommitmentWhereInput
        {
        }
        pub struct updatedAt_not;
        impl ::cynic::schema::Field for updatedAt_not {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt_not";
        }
        impl ::cynic::schema::HasInputField<updatedAt_not, Option<super::super::DateTime>>
            for super::super::CommitmentWhereInput
        {
        }
        pub struct updatedAt_in;
        impl ::cynic::schema::Field for updatedAt_in {
            type Type = Option<Vec<super::super::DateTime>>;
            const NAME: &'static str = "updatedAt_in";
        }
        impl ::cynic::schema::HasInputField<updatedAt_in, Option<Vec<super::super::DateTime>>>
            for super::super::CommitmentWhereInput
        {
        }
        pub struct updatedAt_not_in;
        impl ::cynic::schema::Field for updatedAt_not_in {
            type Type = Option<Vec<super::super::DateTime>>;
            const NAME: &'static str = "updatedAt_not_in";
        }
        impl ::cynic::schema::HasInputField<updatedAt_not_in, Option<Vec<super::super::DateTime>>>
            for super::super::CommitmentWhereInput
        {
        }
        pub struct updatedAt_lt;
        impl ::cynic::schema::Field for updatedAt_lt {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt_lt";
        }
        impl ::cynic::schema::HasInputField<updatedAt_lt, Option<super::super::DateTime>>
            for super::super::CommitmentWhereInput
        {
        }
        pub struct updatedAt_lte;
        impl ::cynic::schema::Field for updatedAt_lte {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt_lte";
        }
        impl ::cynic::schema::HasInputField<updatedAt_lte, Option<super::super::DateTime>>
            for super::super::CommitmentWhereInput
        {
        }
        pub struct updatedAt_gt;
        impl ::cynic::schema::Field for updatedAt_gt {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt_gt";
        }
        impl ::cynic::schema::HasInputField<updatedAt_gt, Option<super::super::DateTime>>
            for super::super::CommitmentWhereInput
        {
        }
        pub struct updatedAt_gte;
        impl ::cynic::schema::Field for updatedAt_gte {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt_gte";
        }
        impl ::cynic::schema::HasInputField<updatedAt_gte, Option<super::super::DateTime>>
            for super::super::CommitmentWhereInput
        {
        }
        pub struct AND;
        impl ::cynic::schema::Field for AND {
            type Type = Option<Vec<super::super::CommitmentWhereInput>>;
            const NAME: &'static str = "AND";
        }
        impl ::cynic::schema::HasInputField<AND, Option<Vec<super::super::CommitmentWhereInput>>>
            for super::super::CommitmentWhereInput
        {
        }
        pub struct OR;
        impl ::cynic::schema::Field for OR {
            type Type = Option<Vec<super::super::CommitmentWhereInput>>;
            const NAME: &'static str = "OR";
        }
        impl ::cynic::schema::HasInputField<OR, Option<Vec<super::super::CommitmentWhereInput>>>
            for super::super::CommitmentWhereInput
        {
        }
        pub struct NOT;
        impl ::cynic::schema::Field for NOT {
            type Type = Option<Vec<super::super::CommitmentWhereInput>>;
            const NAME: &'static str = "NOT";
        }
        impl ::cynic::schema::HasInputField<NOT, Option<Vec<super::super::CommitmentWhereInput>>>
            for super::super::CommitmentWhereInput
        {
        }
    }
    pub mod Company {
        pub struct id;
        impl ::cynic::schema::Field for id {
            type Type = super::super::ID;
            const NAME: &'static str = "id";
        }
        impl ::cynic::schema::HasField<id> for super::super::Company {
            type Type = super::super::ID;
        }
        pub struct name;
        impl ::cynic::schema::Field for name {
            type Type = super::super::String;
            const NAME: &'static str = "name";
        }
        impl ::cynic::schema::HasField<name> for super::super::Company {
            type Type = super::super::String;
        }
        pub struct slug;
        impl ::cynic::schema::Field for slug {
            type Type = super::super::String;
            const NAME: &'static str = "slug";
        }
        impl ::cynic::schema::HasField<slug> for super::super::Company {
            type Type = super::super::String;
        }
        pub struct websiteUrl;
        impl ::cynic::schema::Field for websiteUrl {
            type Type = super::super::String;
            const NAME: &'static str = "websiteUrl";
        }
        impl ::cynic::schema::HasField<websiteUrl> for super::super::Company {
            type Type = super::super::String;
        }
        pub struct logoUrl;
        impl ::cynic::schema::Field for logoUrl {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "logoUrl";
        }
        impl ::cynic::schema::HasField<logoUrl> for super::super::Company {
            type Type = Option<super::super::String>;
        }
        pub struct jobs;
        impl ::cynic::schema::Field for jobs {
            type Type = Option<Vec<super::super::Job>>;
            const NAME: &'static str = "jobs";
        }
        impl ::cynic::schema::HasField<jobs> for super::super::Company {
            type Type = Option<Vec<super::super::Job>>;
        }
        pub mod _jobs_arguments {
            pub struct r#where;
            impl ::cynic::schema::HasArgument<r#where> for super::jobs {
                type ArgumentType = Option<super::super::super::JobWhereInput>;
                const NAME: &'static str = "where";
            }
            pub struct orderBy;
            impl ::cynic::schema::HasArgument<orderBy> for super::jobs {
                type ArgumentType = Option<super::super::super::JobOrderByInput>;
                const NAME: &'static str = "orderBy";
            }
            pub struct skip;
            impl ::cynic::schema::HasArgument<skip> for super::jobs {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "skip";
            }
            pub struct after;
            impl ::cynic::schema::HasArgument<after> for super::jobs {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "after";
            }
            pub struct before;
            impl ::cynic::schema::HasArgument<before> for super::jobs {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "before";
            }
            pub struct first;
            impl ::cynic::schema::HasArgument<first> for super::jobs {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "first";
            }
            pub struct last;
            impl ::cynic::schema::HasArgument<last> for super::jobs {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "last";
            }
        }
        pub struct twitter;
        impl ::cynic::schema::Field for twitter {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "twitter";
        }
        impl ::cynic::schema::HasField<twitter> for super::super::Company {
            type Type = Option<super::super::String>;
        }
        pub struct emailed;
        impl ::cynic::schema::Field for emailed {
            type Type = Option<super::super::Boolean>;
            const NAME: &'static str = "emailed";
        }
        impl ::cynic::schema::HasField<emailed> for super::super::Company {
            type Type = Option<super::super::Boolean>;
        }
        pub struct createdAt;
        impl ::cynic::schema::Field for createdAt {
            type Type = super::super::DateTime;
            const NAME: &'static str = "createdAt";
        }
        impl ::cynic::schema::HasField<createdAt> for super::super::Company {
            type Type = super::super::DateTime;
        }
        pub struct updatedAt;
        impl ::cynic::schema::Field for updatedAt {
            type Type = super::super::DateTime;
            const NAME: &'static str = "updatedAt";
        }
        impl ::cynic::schema::HasField<updatedAt> for super::super::Company {
            type Type = super::super::DateTime;
        }
        pub struct __typename;
        impl ::cynic::schema::Field for __typename {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
        impl ::cynic::schema::HasField<__typename> for super::super::Company {
            type Type = super::super::String;
        }
    }
    pub mod CompanyWhereInput {
        pub struct id;
        impl ::cynic::schema::Field for id {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id";
        }
        impl ::cynic::schema::HasInputField<id, Option<super::super::ID>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct id_not;
        impl ::cynic::schema::Field for id_not {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_not";
        }
        impl ::cynic::schema::HasInputField<id_not, Option<super::super::ID>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct id_in;
        impl ::cynic::schema::Field for id_in {
            type Type = Option<Vec<super::super::ID>>;
            const NAME: &'static str = "id_in";
        }
        impl ::cynic::schema::HasInputField<id_in, Option<Vec<super::super::ID>>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct id_not_in;
        impl ::cynic::schema::Field for id_not_in {
            type Type = Option<Vec<super::super::ID>>;
            const NAME: &'static str = "id_not_in";
        }
        impl ::cynic::schema::HasInputField<id_not_in, Option<Vec<super::super::ID>>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct id_lt;
        impl ::cynic::schema::Field for id_lt {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_lt";
        }
        impl ::cynic::schema::HasInputField<id_lt, Option<super::super::ID>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct id_lte;
        impl ::cynic::schema::Field for id_lte {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_lte";
        }
        impl ::cynic::schema::HasInputField<id_lte, Option<super::super::ID>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct id_gt;
        impl ::cynic::schema::Field for id_gt {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_gt";
        }
        impl ::cynic::schema::HasInputField<id_gt, Option<super::super::ID>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct id_gte;
        impl ::cynic::schema::Field for id_gte {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_gte";
        }
        impl ::cynic::schema::HasInputField<id_gte, Option<super::super::ID>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct id_contains;
        impl ::cynic::schema::Field for id_contains {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_contains";
        }
        impl ::cynic::schema::HasInputField<id_contains, Option<super::super::ID>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct id_not_contains;
        impl ::cynic::schema::Field for id_not_contains {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_not_contains";
        }
        impl ::cynic::schema::HasInputField<id_not_contains, Option<super::super::ID>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct id_starts_with;
        impl ::cynic::schema::Field for id_starts_with {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_starts_with";
        }
        impl ::cynic::schema::HasInputField<id_starts_with, Option<super::super::ID>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct id_not_starts_with;
        impl ::cynic::schema::Field for id_not_starts_with {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_not_starts_with";
        }
        impl ::cynic::schema::HasInputField<id_not_starts_with, Option<super::super::ID>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct id_ends_with;
        impl ::cynic::schema::Field for id_ends_with {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_ends_with";
        }
        impl ::cynic::schema::HasInputField<id_ends_with, Option<super::super::ID>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct id_not_ends_with;
        impl ::cynic::schema::Field for id_not_ends_with {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_not_ends_with";
        }
        impl ::cynic::schema::HasInputField<id_not_ends_with, Option<super::super::ID>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct name;
        impl ::cynic::schema::Field for name {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name";
        }
        impl ::cynic::schema::HasInputField<name, Option<super::super::String>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct name_not;
        impl ::cynic::schema::Field for name_not {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_not";
        }
        impl ::cynic::schema::HasInputField<name_not, Option<super::super::String>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct name_in;
        impl ::cynic::schema::Field for name_in {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "name_in";
        }
        impl ::cynic::schema::HasInputField<name_in, Option<Vec<super::super::String>>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct name_not_in;
        impl ::cynic::schema::Field for name_not_in {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "name_not_in";
        }
        impl ::cynic::schema::HasInputField<name_not_in, Option<Vec<super::super::String>>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct name_lt;
        impl ::cynic::schema::Field for name_lt {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_lt";
        }
        impl ::cynic::schema::HasInputField<name_lt, Option<super::super::String>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct name_lte;
        impl ::cynic::schema::Field for name_lte {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_lte";
        }
        impl ::cynic::schema::HasInputField<name_lte, Option<super::super::String>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct name_gt;
        impl ::cynic::schema::Field for name_gt {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_gt";
        }
        impl ::cynic::schema::HasInputField<name_gt, Option<super::super::String>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct name_gte;
        impl ::cynic::schema::Field for name_gte {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_gte";
        }
        impl ::cynic::schema::HasInputField<name_gte, Option<super::super::String>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct name_contains;
        impl ::cynic::schema::Field for name_contains {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_contains";
        }
        impl ::cynic::schema::HasInputField<name_contains, Option<super::super::String>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct name_not_contains;
        impl ::cynic::schema::Field for name_not_contains {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_not_contains";
        }
        impl ::cynic::schema::HasInputField<name_not_contains, Option<super::super::String>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct name_starts_with;
        impl ::cynic::schema::Field for name_starts_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_starts_with";
        }
        impl ::cynic::schema::HasInputField<name_starts_with, Option<super::super::String>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct name_not_starts_with;
        impl ::cynic::schema::Field for name_not_starts_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_not_starts_with";
        }
        impl ::cynic::schema::HasInputField<name_not_starts_with, Option<super::super::String>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct name_ends_with;
        impl ::cynic::schema::Field for name_ends_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_ends_with";
        }
        impl ::cynic::schema::HasInputField<name_ends_with, Option<super::super::String>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct name_not_ends_with;
        impl ::cynic::schema::Field for name_not_ends_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_not_ends_with";
        }
        impl ::cynic::schema::HasInputField<name_not_ends_with, Option<super::super::String>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct slug;
        impl ::cynic::schema::Field for slug {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug";
        }
        impl ::cynic::schema::HasInputField<slug, Option<super::super::String>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct slug_not;
        impl ::cynic::schema::Field for slug_not {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_not";
        }
        impl ::cynic::schema::HasInputField<slug_not, Option<super::super::String>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct slug_in;
        impl ::cynic::schema::Field for slug_in {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "slug_in";
        }
        impl ::cynic::schema::HasInputField<slug_in, Option<Vec<super::super::String>>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct slug_not_in;
        impl ::cynic::schema::Field for slug_not_in {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "slug_not_in";
        }
        impl ::cynic::schema::HasInputField<slug_not_in, Option<Vec<super::super::String>>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct slug_lt;
        impl ::cynic::schema::Field for slug_lt {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_lt";
        }
        impl ::cynic::schema::HasInputField<slug_lt, Option<super::super::String>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct slug_lte;
        impl ::cynic::schema::Field for slug_lte {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_lte";
        }
        impl ::cynic::schema::HasInputField<slug_lte, Option<super::super::String>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct slug_gt;
        impl ::cynic::schema::Field for slug_gt {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_gt";
        }
        impl ::cynic::schema::HasInputField<slug_gt, Option<super::super::String>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct slug_gte;
        impl ::cynic::schema::Field for slug_gte {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_gte";
        }
        impl ::cynic::schema::HasInputField<slug_gte, Option<super::super::String>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct slug_contains;
        impl ::cynic::schema::Field for slug_contains {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_contains";
        }
        impl ::cynic::schema::HasInputField<slug_contains, Option<super::super::String>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct slug_not_contains;
        impl ::cynic::schema::Field for slug_not_contains {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_not_contains";
        }
        impl ::cynic::schema::HasInputField<slug_not_contains, Option<super::super::String>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct slug_starts_with;
        impl ::cynic::schema::Field for slug_starts_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_starts_with";
        }
        impl ::cynic::schema::HasInputField<slug_starts_with, Option<super::super::String>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct slug_not_starts_with;
        impl ::cynic::schema::Field for slug_not_starts_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_not_starts_with";
        }
        impl ::cynic::schema::HasInputField<slug_not_starts_with, Option<super::super::String>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct slug_ends_with;
        impl ::cynic::schema::Field for slug_ends_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_ends_with";
        }
        impl ::cynic::schema::HasInputField<slug_ends_with, Option<super::super::String>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct slug_not_ends_with;
        impl ::cynic::schema::Field for slug_not_ends_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_not_ends_with";
        }
        impl ::cynic::schema::HasInputField<slug_not_ends_with, Option<super::super::String>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct websiteUrl;
        impl ::cynic::schema::Field for websiteUrl {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "websiteUrl";
        }
        impl ::cynic::schema::HasInputField<websiteUrl, Option<super::super::String>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct websiteUrl_not;
        impl ::cynic::schema::Field for websiteUrl_not {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "websiteUrl_not";
        }
        impl ::cynic::schema::HasInputField<websiteUrl_not, Option<super::super::String>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct websiteUrl_in;
        impl ::cynic::schema::Field for websiteUrl_in {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "websiteUrl_in";
        }
        impl ::cynic::schema::HasInputField<websiteUrl_in, Option<Vec<super::super::String>>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct websiteUrl_not_in;
        impl ::cynic::schema::Field for websiteUrl_not_in {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "websiteUrl_not_in";
        }
        impl ::cynic::schema::HasInputField<websiteUrl_not_in, Option<Vec<super::super::String>>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct websiteUrl_lt;
        impl ::cynic::schema::Field for websiteUrl_lt {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "websiteUrl_lt";
        }
        impl ::cynic::schema::HasInputField<websiteUrl_lt, Option<super::super::String>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct websiteUrl_lte;
        impl ::cynic::schema::Field for websiteUrl_lte {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "websiteUrl_lte";
        }
        impl ::cynic::schema::HasInputField<websiteUrl_lte, Option<super::super::String>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct websiteUrl_gt;
        impl ::cynic::schema::Field for websiteUrl_gt {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "websiteUrl_gt";
        }
        impl ::cynic::schema::HasInputField<websiteUrl_gt, Option<super::super::String>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct websiteUrl_gte;
        impl ::cynic::schema::Field for websiteUrl_gte {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "websiteUrl_gte";
        }
        impl ::cynic::schema::HasInputField<websiteUrl_gte, Option<super::super::String>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct websiteUrl_contains;
        impl ::cynic::schema::Field for websiteUrl_contains {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "websiteUrl_contains";
        }
        impl ::cynic::schema::HasInputField<websiteUrl_contains, Option<super::super::String>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct websiteUrl_not_contains;
        impl ::cynic::schema::Field for websiteUrl_not_contains {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "websiteUrl_not_contains";
        }
        impl ::cynic::schema::HasInputField<websiteUrl_not_contains, Option<super::super::String>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct websiteUrl_starts_with;
        impl ::cynic::schema::Field for websiteUrl_starts_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "websiteUrl_starts_with";
        }
        impl ::cynic::schema::HasInputField<websiteUrl_starts_with, Option<super::super::String>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct websiteUrl_not_starts_with;
        impl ::cynic::schema::Field for websiteUrl_not_starts_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "websiteUrl_not_starts_with";
        }
        impl
            ::cynic::schema::HasInputField<websiteUrl_not_starts_with, Option<super::super::String>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct websiteUrl_ends_with;
        impl ::cynic::schema::Field for websiteUrl_ends_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "websiteUrl_ends_with";
        }
        impl ::cynic::schema::HasInputField<websiteUrl_ends_with, Option<super::super::String>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct websiteUrl_not_ends_with;
        impl ::cynic::schema::Field for websiteUrl_not_ends_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "websiteUrl_not_ends_with";
        }
        impl ::cynic::schema::HasInputField<websiteUrl_not_ends_with, Option<super::super::String>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct logoUrl;
        impl ::cynic::schema::Field for logoUrl {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "logoUrl";
        }
        impl ::cynic::schema::HasInputField<logoUrl, Option<super::super::String>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct logoUrl_not;
        impl ::cynic::schema::Field for logoUrl_not {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "logoUrl_not";
        }
        impl ::cynic::schema::HasInputField<logoUrl_not, Option<super::super::String>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct logoUrl_in;
        impl ::cynic::schema::Field for logoUrl_in {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "logoUrl_in";
        }
        impl ::cynic::schema::HasInputField<logoUrl_in, Option<Vec<super::super::String>>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct logoUrl_not_in;
        impl ::cynic::schema::Field for logoUrl_not_in {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "logoUrl_not_in";
        }
        impl ::cynic::schema::HasInputField<logoUrl_not_in, Option<Vec<super::super::String>>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct logoUrl_lt;
        impl ::cynic::schema::Field for logoUrl_lt {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "logoUrl_lt";
        }
        impl ::cynic::schema::HasInputField<logoUrl_lt, Option<super::super::String>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct logoUrl_lte;
        impl ::cynic::schema::Field for logoUrl_lte {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "logoUrl_lte";
        }
        impl ::cynic::schema::HasInputField<logoUrl_lte, Option<super::super::String>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct logoUrl_gt;
        impl ::cynic::schema::Field for logoUrl_gt {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "logoUrl_gt";
        }
        impl ::cynic::schema::HasInputField<logoUrl_gt, Option<super::super::String>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct logoUrl_gte;
        impl ::cynic::schema::Field for logoUrl_gte {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "logoUrl_gte";
        }
        impl ::cynic::schema::HasInputField<logoUrl_gte, Option<super::super::String>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct logoUrl_contains;
        impl ::cynic::schema::Field for logoUrl_contains {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "logoUrl_contains";
        }
        impl ::cynic::schema::HasInputField<logoUrl_contains, Option<super::super::String>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct logoUrl_not_contains;
        impl ::cynic::schema::Field for logoUrl_not_contains {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "logoUrl_not_contains";
        }
        impl ::cynic::schema::HasInputField<logoUrl_not_contains, Option<super::super::String>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct logoUrl_starts_with;
        impl ::cynic::schema::Field for logoUrl_starts_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "logoUrl_starts_with";
        }
        impl ::cynic::schema::HasInputField<logoUrl_starts_with, Option<super::super::String>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct logoUrl_not_starts_with;
        impl ::cynic::schema::Field for logoUrl_not_starts_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "logoUrl_not_starts_with";
        }
        impl ::cynic::schema::HasInputField<logoUrl_not_starts_with, Option<super::super::String>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct logoUrl_ends_with;
        impl ::cynic::schema::Field for logoUrl_ends_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "logoUrl_ends_with";
        }
        impl ::cynic::schema::HasInputField<logoUrl_ends_with, Option<super::super::String>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct logoUrl_not_ends_with;
        impl ::cynic::schema::Field for logoUrl_not_ends_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "logoUrl_not_ends_with";
        }
        impl ::cynic::schema::HasInputField<logoUrl_not_ends_with, Option<super::super::String>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct jobs_every;
        impl ::cynic::schema::Field for jobs_every {
            type Type = Option<super::super::JobWhereInput>;
            const NAME: &'static str = "jobs_every";
        }
        impl ::cynic::schema::HasInputField<jobs_every, Option<super::super::JobWhereInput>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct jobs_some;
        impl ::cynic::schema::Field for jobs_some {
            type Type = Option<super::super::JobWhereInput>;
            const NAME: &'static str = "jobs_some";
        }
        impl ::cynic::schema::HasInputField<jobs_some, Option<super::super::JobWhereInput>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct jobs_none;
        impl ::cynic::schema::Field for jobs_none {
            type Type = Option<super::super::JobWhereInput>;
            const NAME: &'static str = "jobs_none";
        }
        impl ::cynic::schema::HasInputField<jobs_none, Option<super::super::JobWhereInput>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct twitter;
        impl ::cynic::schema::Field for twitter {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "twitter";
        }
        impl ::cynic::schema::HasInputField<twitter, Option<super::super::String>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct twitter_not;
        impl ::cynic::schema::Field for twitter_not {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "twitter_not";
        }
        impl ::cynic::schema::HasInputField<twitter_not, Option<super::super::String>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct twitter_in;
        impl ::cynic::schema::Field for twitter_in {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "twitter_in";
        }
        impl ::cynic::schema::HasInputField<twitter_in, Option<Vec<super::super::String>>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct twitter_not_in;
        impl ::cynic::schema::Field for twitter_not_in {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "twitter_not_in";
        }
        impl ::cynic::schema::HasInputField<twitter_not_in, Option<Vec<super::super::String>>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct twitter_lt;
        impl ::cynic::schema::Field for twitter_lt {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "twitter_lt";
        }
        impl ::cynic::schema::HasInputField<twitter_lt, Option<super::super::String>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct twitter_lte;
        impl ::cynic::schema::Field for twitter_lte {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "twitter_lte";
        }
        impl ::cynic::schema::HasInputField<twitter_lte, Option<super::super::String>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct twitter_gt;
        impl ::cynic::schema::Field for twitter_gt {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "twitter_gt";
        }
        impl ::cynic::schema::HasInputField<twitter_gt, Option<super::super::String>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct twitter_gte;
        impl ::cynic::schema::Field for twitter_gte {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "twitter_gte";
        }
        impl ::cynic::schema::HasInputField<twitter_gte, Option<super::super::String>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct twitter_contains;
        impl ::cynic::schema::Field for twitter_contains {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "twitter_contains";
        }
        impl ::cynic::schema::HasInputField<twitter_contains, Option<super::super::String>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct twitter_not_contains;
        impl ::cynic::schema::Field for twitter_not_contains {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "twitter_not_contains";
        }
        impl ::cynic::schema::HasInputField<twitter_not_contains, Option<super::super::String>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct twitter_starts_with;
        impl ::cynic::schema::Field for twitter_starts_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "twitter_starts_with";
        }
        impl ::cynic::schema::HasInputField<twitter_starts_with, Option<super::super::String>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct twitter_not_starts_with;
        impl ::cynic::schema::Field for twitter_not_starts_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "twitter_not_starts_with";
        }
        impl ::cynic::schema::HasInputField<twitter_not_starts_with, Option<super::super::String>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct twitter_ends_with;
        impl ::cynic::schema::Field for twitter_ends_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "twitter_ends_with";
        }
        impl ::cynic::schema::HasInputField<twitter_ends_with, Option<super::super::String>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct twitter_not_ends_with;
        impl ::cynic::schema::Field for twitter_not_ends_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "twitter_not_ends_with";
        }
        impl ::cynic::schema::HasInputField<twitter_not_ends_with, Option<super::super::String>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct emailed;
        impl ::cynic::schema::Field for emailed {
            type Type = Option<super::super::Boolean>;
            const NAME: &'static str = "emailed";
        }
        impl ::cynic::schema::HasInputField<emailed, Option<super::super::Boolean>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct emailed_not;
        impl ::cynic::schema::Field for emailed_not {
            type Type = Option<super::super::Boolean>;
            const NAME: &'static str = "emailed_not";
        }
        impl ::cynic::schema::HasInputField<emailed_not, Option<super::super::Boolean>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct createdAt;
        impl ::cynic::schema::Field for createdAt {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt";
        }
        impl ::cynic::schema::HasInputField<createdAt, Option<super::super::DateTime>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct createdAt_not;
        impl ::cynic::schema::Field for createdAt_not {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt_not";
        }
        impl ::cynic::schema::HasInputField<createdAt_not, Option<super::super::DateTime>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct createdAt_in;
        impl ::cynic::schema::Field for createdAt_in {
            type Type = Option<Vec<super::super::DateTime>>;
            const NAME: &'static str = "createdAt_in";
        }
        impl ::cynic::schema::HasInputField<createdAt_in, Option<Vec<super::super::DateTime>>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct createdAt_not_in;
        impl ::cynic::schema::Field for createdAt_not_in {
            type Type = Option<Vec<super::super::DateTime>>;
            const NAME: &'static str = "createdAt_not_in";
        }
        impl ::cynic::schema::HasInputField<createdAt_not_in, Option<Vec<super::super::DateTime>>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct createdAt_lt;
        impl ::cynic::schema::Field for createdAt_lt {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt_lt";
        }
        impl ::cynic::schema::HasInputField<createdAt_lt, Option<super::super::DateTime>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct createdAt_lte;
        impl ::cynic::schema::Field for createdAt_lte {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt_lte";
        }
        impl ::cynic::schema::HasInputField<createdAt_lte, Option<super::super::DateTime>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct createdAt_gt;
        impl ::cynic::schema::Field for createdAt_gt {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt_gt";
        }
        impl ::cynic::schema::HasInputField<createdAt_gt, Option<super::super::DateTime>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct createdAt_gte;
        impl ::cynic::schema::Field for createdAt_gte {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt_gte";
        }
        impl ::cynic::schema::HasInputField<createdAt_gte, Option<super::super::DateTime>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct updatedAt;
        impl ::cynic::schema::Field for updatedAt {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt";
        }
        impl ::cynic::schema::HasInputField<updatedAt, Option<super::super::DateTime>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct updatedAt_not;
        impl ::cynic::schema::Field for updatedAt_not {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt_not";
        }
        impl ::cynic::schema::HasInputField<updatedAt_not, Option<super::super::DateTime>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct updatedAt_in;
        impl ::cynic::schema::Field for updatedAt_in {
            type Type = Option<Vec<super::super::DateTime>>;
            const NAME: &'static str = "updatedAt_in";
        }
        impl ::cynic::schema::HasInputField<updatedAt_in, Option<Vec<super::super::DateTime>>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct updatedAt_not_in;
        impl ::cynic::schema::Field for updatedAt_not_in {
            type Type = Option<Vec<super::super::DateTime>>;
            const NAME: &'static str = "updatedAt_not_in";
        }
        impl ::cynic::schema::HasInputField<updatedAt_not_in, Option<Vec<super::super::DateTime>>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct updatedAt_lt;
        impl ::cynic::schema::Field for updatedAt_lt {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt_lt";
        }
        impl ::cynic::schema::HasInputField<updatedAt_lt, Option<super::super::DateTime>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct updatedAt_lte;
        impl ::cynic::schema::Field for updatedAt_lte {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt_lte";
        }
        impl ::cynic::schema::HasInputField<updatedAt_lte, Option<super::super::DateTime>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct updatedAt_gt;
        impl ::cynic::schema::Field for updatedAt_gt {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt_gt";
        }
        impl ::cynic::schema::HasInputField<updatedAt_gt, Option<super::super::DateTime>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct updatedAt_gte;
        impl ::cynic::schema::Field for updatedAt_gte {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt_gte";
        }
        impl ::cynic::schema::HasInputField<updatedAt_gte, Option<super::super::DateTime>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct AND;
        impl ::cynic::schema::Field for AND {
            type Type = Option<Vec<super::super::CompanyWhereInput>>;
            const NAME: &'static str = "AND";
        }
        impl ::cynic::schema::HasInputField<AND, Option<Vec<super::super::CompanyWhereInput>>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct OR;
        impl ::cynic::schema::Field for OR {
            type Type = Option<Vec<super::super::CompanyWhereInput>>;
            const NAME: &'static str = "OR";
        }
        impl ::cynic::schema::HasInputField<OR, Option<Vec<super::super::CompanyWhereInput>>>
            for super::super::CompanyWhereInput
        {
        }
        pub struct NOT;
        impl ::cynic::schema::Field for NOT {
            type Type = Option<Vec<super::super::CompanyWhereInput>>;
            const NAME: &'static str = "NOT";
        }
        impl ::cynic::schema::HasInputField<NOT, Option<Vec<super::super::CompanyWhereInput>>>
            for super::super::CompanyWhereInput
        {
        }
    }
    pub mod Country {
        pub struct id;
        impl ::cynic::schema::Field for id {
            type Type = super::super::ID;
            const NAME: &'static str = "id";
        }
        impl ::cynic::schema::HasField<id> for super::super::Country {
            type Type = super::super::ID;
        }
        pub struct name;
        impl ::cynic::schema::Field for name {
            type Type = super::super::String;
            const NAME: &'static str = "name";
        }
        impl ::cynic::schema::HasField<name> for super::super::Country {
            type Type = super::super::String;
        }
        pub struct slug;
        impl ::cynic::schema::Field for slug {
            type Type = super::super::String;
            const NAME: &'static str = "slug";
        }
        impl ::cynic::schema::HasField<slug> for super::super::Country {
            type Type = super::super::String;
        }
        pub struct r#type;
        impl ::cynic::schema::Field for r#type {
            type Type = super::super::String;
            const NAME: &'static str = "type";
        }
        impl ::cynic::schema::HasField<r#type> for super::super::Country {
            type Type = super::super::String;
        }
        pub struct isoCode;
        impl ::cynic::schema::Field for isoCode {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "isoCode";
        }
        impl ::cynic::schema::HasField<isoCode> for super::super::Country {
            type Type = Option<super::super::String>;
        }
        pub struct cities;
        impl ::cynic::schema::Field for cities {
            type Type = Option<Vec<super::super::City>>;
            const NAME: &'static str = "cities";
        }
        impl ::cynic::schema::HasField<cities> for super::super::Country {
            type Type = Option<Vec<super::super::City>>;
        }
        pub mod _cities_arguments {
            pub struct r#where;
            impl ::cynic::schema::HasArgument<r#where> for super::cities {
                type ArgumentType = Option<super::super::super::CityWhereInput>;
                const NAME: &'static str = "where";
            }
            pub struct orderBy;
            impl ::cynic::schema::HasArgument<orderBy> for super::cities {
                type ArgumentType = Option<super::super::super::CityOrderByInput>;
                const NAME: &'static str = "orderBy";
            }
            pub struct skip;
            impl ::cynic::schema::HasArgument<skip> for super::cities {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "skip";
            }
            pub struct after;
            impl ::cynic::schema::HasArgument<after> for super::cities {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "after";
            }
            pub struct before;
            impl ::cynic::schema::HasArgument<before> for super::cities {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "before";
            }
            pub struct first;
            impl ::cynic::schema::HasArgument<first> for super::cities {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "first";
            }
            pub struct last;
            impl ::cynic::schema::HasArgument<last> for super::cities {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "last";
            }
        }
        pub struct jobs;
        impl ::cynic::schema::Field for jobs {
            type Type = Option<Vec<super::super::Job>>;
            const NAME: &'static str = "jobs";
        }
        impl ::cynic::schema::HasField<jobs> for super::super::Country {
            type Type = Option<Vec<super::super::Job>>;
        }
        pub mod _jobs_arguments {
            pub struct r#where;
            impl ::cynic::schema::HasArgument<r#where> for super::jobs {
                type ArgumentType = Option<super::super::super::JobWhereInput>;
                const NAME: &'static str = "where";
            }
            pub struct orderBy;
            impl ::cynic::schema::HasArgument<orderBy> for super::jobs {
                type ArgumentType = Option<super::super::super::JobOrderByInput>;
                const NAME: &'static str = "orderBy";
            }
            pub struct skip;
            impl ::cynic::schema::HasArgument<skip> for super::jobs {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "skip";
            }
            pub struct after;
            impl ::cynic::schema::HasArgument<after> for super::jobs {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "after";
            }
            pub struct before;
            impl ::cynic::schema::HasArgument<before> for super::jobs {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "before";
            }
            pub struct first;
            impl ::cynic::schema::HasArgument<first> for super::jobs {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "first";
            }
            pub struct last;
            impl ::cynic::schema::HasArgument<last> for super::jobs {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "last";
            }
        }
        pub struct createdAt;
        impl ::cynic::schema::Field for createdAt {
            type Type = super::super::DateTime;
            const NAME: &'static str = "createdAt";
        }
        impl ::cynic::schema::HasField<createdAt> for super::super::Country {
            type Type = super::super::DateTime;
        }
        pub struct updatedAt;
        impl ::cynic::schema::Field for updatedAt {
            type Type = super::super::DateTime;
            const NAME: &'static str = "updatedAt";
        }
        impl ::cynic::schema::HasField<updatedAt> for super::super::Country {
            type Type = super::super::DateTime;
        }
        pub struct __typename;
        impl ::cynic::schema::Field for __typename {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
        impl ::cynic::schema::HasField<__typename> for super::super::Country {
            type Type = super::super::String;
        }
    }
    pub mod CountryWhereInput {
        pub struct id;
        impl ::cynic::schema::Field for id {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id";
        }
        impl ::cynic::schema::HasInputField<id, Option<super::super::ID>>
            for super::super::CountryWhereInput
        {
        }
        pub struct id_not;
        impl ::cynic::schema::Field for id_not {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_not";
        }
        impl ::cynic::schema::HasInputField<id_not, Option<super::super::ID>>
            for super::super::CountryWhereInput
        {
        }
        pub struct id_in;
        impl ::cynic::schema::Field for id_in {
            type Type = Option<Vec<super::super::ID>>;
            const NAME: &'static str = "id_in";
        }
        impl ::cynic::schema::HasInputField<id_in, Option<Vec<super::super::ID>>>
            for super::super::CountryWhereInput
        {
        }
        pub struct id_not_in;
        impl ::cynic::schema::Field for id_not_in {
            type Type = Option<Vec<super::super::ID>>;
            const NAME: &'static str = "id_not_in";
        }
        impl ::cynic::schema::HasInputField<id_not_in, Option<Vec<super::super::ID>>>
            for super::super::CountryWhereInput
        {
        }
        pub struct id_lt;
        impl ::cynic::schema::Field for id_lt {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_lt";
        }
        impl ::cynic::schema::HasInputField<id_lt, Option<super::super::ID>>
            for super::super::CountryWhereInput
        {
        }
        pub struct id_lte;
        impl ::cynic::schema::Field for id_lte {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_lte";
        }
        impl ::cynic::schema::HasInputField<id_lte, Option<super::super::ID>>
            for super::super::CountryWhereInput
        {
        }
        pub struct id_gt;
        impl ::cynic::schema::Field for id_gt {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_gt";
        }
        impl ::cynic::schema::HasInputField<id_gt, Option<super::super::ID>>
            for super::super::CountryWhereInput
        {
        }
        pub struct id_gte;
        impl ::cynic::schema::Field for id_gte {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_gte";
        }
        impl ::cynic::schema::HasInputField<id_gte, Option<super::super::ID>>
            for super::super::CountryWhereInput
        {
        }
        pub struct id_contains;
        impl ::cynic::schema::Field for id_contains {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_contains";
        }
        impl ::cynic::schema::HasInputField<id_contains, Option<super::super::ID>>
            for super::super::CountryWhereInput
        {
        }
        pub struct id_not_contains;
        impl ::cynic::schema::Field for id_not_contains {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_not_contains";
        }
        impl ::cynic::schema::HasInputField<id_not_contains, Option<super::super::ID>>
            for super::super::CountryWhereInput
        {
        }
        pub struct id_starts_with;
        impl ::cynic::schema::Field for id_starts_with {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_starts_with";
        }
        impl ::cynic::schema::HasInputField<id_starts_with, Option<super::super::ID>>
            for super::super::CountryWhereInput
        {
        }
        pub struct id_not_starts_with;
        impl ::cynic::schema::Field for id_not_starts_with {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_not_starts_with";
        }
        impl ::cynic::schema::HasInputField<id_not_starts_with, Option<super::super::ID>>
            for super::super::CountryWhereInput
        {
        }
        pub struct id_ends_with;
        impl ::cynic::schema::Field for id_ends_with {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_ends_with";
        }
        impl ::cynic::schema::HasInputField<id_ends_with, Option<super::super::ID>>
            for super::super::CountryWhereInput
        {
        }
        pub struct id_not_ends_with;
        impl ::cynic::schema::Field for id_not_ends_with {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_not_ends_with";
        }
        impl ::cynic::schema::HasInputField<id_not_ends_with, Option<super::super::ID>>
            for super::super::CountryWhereInput
        {
        }
        pub struct name;
        impl ::cynic::schema::Field for name {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name";
        }
        impl ::cynic::schema::HasInputField<name, Option<super::super::String>>
            for super::super::CountryWhereInput
        {
        }
        pub struct name_not;
        impl ::cynic::schema::Field for name_not {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_not";
        }
        impl ::cynic::schema::HasInputField<name_not, Option<super::super::String>>
            for super::super::CountryWhereInput
        {
        }
        pub struct name_in;
        impl ::cynic::schema::Field for name_in {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "name_in";
        }
        impl ::cynic::schema::HasInputField<name_in, Option<Vec<super::super::String>>>
            for super::super::CountryWhereInput
        {
        }
        pub struct name_not_in;
        impl ::cynic::schema::Field for name_not_in {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "name_not_in";
        }
        impl ::cynic::schema::HasInputField<name_not_in, Option<Vec<super::super::String>>>
            for super::super::CountryWhereInput
        {
        }
        pub struct name_lt;
        impl ::cynic::schema::Field for name_lt {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_lt";
        }
        impl ::cynic::schema::HasInputField<name_lt, Option<super::super::String>>
            for super::super::CountryWhereInput
        {
        }
        pub struct name_lte;
        impl ::cynic::schema::Field for name_lte {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_lte";
        }
        impl ::cynic::schema::HasInputField<name_lte, Option<super::super::String>>
            for super::super::CountryWhereInput
        {
        }
        pub struct name_gt;
        impl ::cynic::schema::Field for name_gt {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_gt";
        }
        impl ::cynic::schema::HasInputField<name_gt, Option<super::super::String>>
            for super::super::CountryWhereInput
        {
        }
        pub struct name_gte;
        impl ::cynic::schema::Field for name_gte {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_gte";
        }
        impl ::cynic::schema::HasInputField<name_gte, Option<super::super::String>>
            for super::super::CountryWhereInput
        {
        }
        pub struct name_contains;
        impl ::cynic::schema::Field for name_contains {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_contains";
        }
        impl ::cynic::schema::HasInputField<name_contains, Option<super::super::String>>
            for super::super::CountryWhereInput
        {
        }
        pub struct name_not_contains;
        impl ::cynic::schema::Field for name_not_contains {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_not_contains";
        }
        impl ::cynic::schema::HasInputField<name_not_contains, Option<super::super::String>>
            for super::super::CountryWhereInput
        {
        }
        pub struct name_starts_with;
        impl ::cynic::schema::Field for name_starts_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_starts_with";
        }
        impl ::cynic::schema::HasInputField<name_starts_with, Option<super::super::String>>
            for super::super::CountryWhereInput
        {
        }
        pub struct name_not_starts_with;
        impl ::cynic::schema::Field for name_not_starts_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_not_starts_with";
        }
        impl ::cynic::schema::HasInputField<name_not_starts_with, Option<super::super::String>>
            for super::super::CountryWhereInput
        {
        }
        pub struct name_ends_with;
        impl ::cynic::schema::Field for name_ends_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_ends_with";
        }
        impl ::cynic::schema::HasInputField<name_ends_with, Option<super::super::String>>
            for super::super::CountryWhereInput
        {
        }
        pub struct name_not_ends_with;
        impl ::cynic::schema::Field for name_not_ends_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_not_ends_with";
        }
        impl ::cynic::schema::HasInputField<name_not_ends_with, Option<super::super::String>>
            for super::super::CountryWhereInput
        {
        }
        pub struct slug;
        impl ::cynic::schema::Field for slug {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug";
        }
        impl ::cynic::schema::HasInputField<slug, Option<super::super::String>>
            for super::super::CountryWhereInput
        {
        }
        pub struct slug_not;
        impl ::cynic::schema::Field for slug_not {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_not";
        }
        impl ::cynic::schema::HasInputField<slug_not, Option<super::super::String>>
            for super::super::CountryWhereInput
        {
        }
        pub struct slug_in;
        impl ::cynic::schema::Field for slug_in {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "slug_in";
        }
        impl ::cynic::schema::HasInputField<slug_in, Option<Vec<super::super::String>>>
            for super::super::CountryWhereInput
        {
        }
        pub struct slug_not_in;
        impl ::cynic::schema::Field for slug_not_in {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "slug_not_in";
        }
        impl ::cynic::schema::HasInputField<slug_not_in, Option<Vec<super::super::String>>>
            for super::super::CountryWhereInput
        {
        }
        pub struct slug_lt;
        impl ::cynic::schema::Field for slug_lt {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_lt";
        }
        impl ::cynic::schema::HasInputField<slug_lt, Option<super::super::String>>
            for super::super::CountryWhereInput
        {
        }
        pub struct slug_lte;
        impl ::cynic::schema::Field for slug_lte {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_lte";
        }
        impl ::cynic::schema::HasInputField<slug_lte, Option<super::super::String>>
            for super::super::CountryWhereInput
        {
        }
        pub struct slug_gt;
        impl ::cynic::schema::Field for slug_gt {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_gt";
        }
        impl ::cynic::schema::HasInputField<slug_gt, Option<super::super::String>>
            for super::super::CountryWhereInput
        {
        }
        pub struct slug_gte;
        impl ::cynic::schema::Field for slug_gte {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_gte";
        }
        impl ::cynic::schema::HasInputField<slug_gte, Option<super::super::String>>
            for super::super::CountryWhereInput
        {
        }
        pub struct slug_contains;
        impl ::cynic::schema::Field for slug_contains {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_contains";
        }
        impl ::cynic::schema::HasInputField<slug_contains, Option<super::super::String>>
            for super::super::CountryWhereInput
        {
        }
        pub struct slug_not_contains;
        impl ::cynic::schema::Field for slug_not_contains {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_not_contains";
        }
        impl ::cynic::schema::HasInputField<slug_not_contains, Option<super::super::String>>
            for super::super::CountryWhereInput
        {
        }
        pub struct slug_starts_with;
        impl ::cynic::schema::Field for slug_starts_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_starts_with";
        }
        impl ::cynic::schema::HasInputField<slug_starts_with, Option<super::super::String>>
            for super::super::CountryWhereInput
        {
        }
        pub struct slug_not_starts_with;
        impl ::cynic::schema::Field for slug_not_starts_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_not_starts_with";
        }
        impl ::cynic::schema::HasInputField<slug_not_starts_with, Option<super::super::String>>
            for super::super::CountryWhereInput
        {
        }
        pub struct slug_ends_with;
        impl ::cynic::schema::Field for slug_ends_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_ends_with";
        }
        impl ::cynic::schema::HasInputField<slug_ends_with, Option<super::super::String>>
            for super::super::CountryWhereInput
        {
        }
        pub struct slug_not_ends_with;
        impl ::cynic::schema::Field for slug_not_ends_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_not_ends_with";
        }
        impl ::cynic::schema::HasInputField<slug_not_ends_with, Option<super::super::String>>
            for super::super::CountryWhereInput
        {
        }
        pub struct r#type;
        impl ::cynic::schema::Field for r#type {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type";
        }
        impl ::cynic::schema::HasInputField<r#type, Option<super::super::String>>
            for super::super::CountryWhereInput
        {
        }
        pub struct type_not;
        impl ::cynic::schema::Field for type_not {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type_not";
        }
        impl ::cynic::schema::HasInputField<type_not, Option<super::super::String>>
            for super::super::CountryWhereInput
        {
        }
        pub struct type_in;
        impl ::cynic::schema::Field for type_in {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "type_in";
        }
        impl ::cynic::schema::HasInputField<type_in, Option<Vec<super::super::String>>>
            for super::super::CountryWhereInput
        {
        }
        pub struct type_not_in;
        impl ::cynic::schema::Field for type_not_in {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "type_not_in";
        }
        impl ::cynic::schema::HasInputField<type_not_in, Option<Vec<super::super::String>>>
            for super::super::CountryWhereInput
        {
        }
        pub struct type_lt;
        impl ::cynic::schema::Field for type_lt {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type_lt";
        }
        impl ::cynic::schema::HasInputField<type_lt, Option<super::super::String>>
            for super::super::CountryWhereInput
        {
        }
        pub struct type_lte;
        impl ::cynic::schema::Field for type_lte {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type_lte";
        }
        impl ::cynic::schema::HasInputField<type_lte, Option<super::super::String>>
            for super::super::CountryWhereInput
        {
        }
        pub struct type_gt;
        impl ::cynic::schema::Field for type_gt {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type_gt";
        }
        impl ::cynic::schema::HasInputField<type_gt, Option<super::super::String>>
            for super::super::CountryWhereInput
        {
        }
        pub struct type_gte;
        impl ::cynic::schema::Field for type_gte {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type_gte";
        }
        impl ::cynic::schema::HasInputField<type_gte, Option<super::super::String>>
            for super::super::CountryWhereInput
        {
        }
        pub struct type_contains;
        impl ::cynic::schema::Field for type_contains {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type_contains";
        }
        impl ::cynic::schema::HasInputField<type_contains, Option<super::super::String>>
            for super::super::CountryWhereInput
        {
        }
        pub struct type_not_contains;
        impl ::cynic::schema::Field for type_not_contains {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type_not_contains";
        }
        impl ::cynic::schema::HasInputField<type_not_contains, Option<super::super::String>>
            for super::super::CountryWhereInput
        {
        }
        pub struct type_starts_with;
        impl ::cynic::schema::Field for type_starts_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type_starts_with";
        }
        impl ::cynic::schema::HasInputField<type_starts_with, Option<super::super::String>>
            for super::super::CountryWhereInput
        {
        }
        pub struct type_not_starts_with;
        impl ::cynic::schema::Field for type_not_starts_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type_not_starts_with";
        }
        impl ::cynic::schema::HasInputField<type_not_starts_with, Option<super::super::String>>
            for super::super::CountryWhereInput
        {
        }
        pub struct type_ends_with;
        impl ::cynic::schema::Field for type_ends_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type_ends_with";
        }
        impl ::cynic::schema::HasInputField<type_ends_with, Option<super::super::String>>
            for super::super::CountryWhereInput
        {
        }
        pub struct type_not_ends_with;
        impl ::cynic::schema::Field for type_not_ends_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type_not_ends_with";
        }
        impl ::cynic::schema::HasInputField<type_not_ends_with, Option<super::super::String>>
            for super::super::CountryWhereInput
        {
        }
        pub struct isoCode;
        impl ::cynic::schema::Field for isoCode {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "isoCode";
        }
        impl ::cynic::schema::HasInputField<isoCode, Option<super::super::String>>
            for super::super::CountryWhereInput
        {
        }
        pub struct isoCode_not;
        impl ::cynic::schema::Field for isoCode_not {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "isoCode_not";
        }
        impl ::cynic::schema::HasInputField<isoCode_not, Option<super::super::String>>
            for super::super::CountryWhereInput
        {
        }
        pub struct isoCode_in;
        impl ::cynic::schema::Field for isoCode_in {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "isoCode_in";
        }
        impl ::cynic::schema::HasInputField<isoCode_in, Option<Vec<super::super::String>>>
            for super::super::CountryWhereInput
        {
        }
        pub struct isoCode_not_in;
        impl ::cynic::schema::Field for isoCode_not_in {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "isoCode_not_in";
        }
        impl ::cynic::schema::HasInputField<isoCode_not_in, Option<Vec<super::super::String>>>
            for super::super::CountryWhereInput
        {
        }
        pub struct isoCode_lt;
        impl ::cynic::schema::Field for isoCode_lt {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "isoCode_lt";
        }
        impl ::cynic::schema::HasInputField<isoCode_lt, Option<super::super::String>>
            for super::super::CountryWhereInput
        {
        }
        pub struct isoCode_lte;
        impl ::cynic::schema::Field for isoCode_lte {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "isoCode_lte";
        }
        impl ::cynic::schema::HasInputField<isoCode_lte, Option<super::super::String>>
            for super::super::CountryWhereInput
        {
        }
        pub struct isoCode_gt;
        impl ::cynic::schema::Field for isoCode_gt {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "isoCode_gt";
        }
        impl ::cynic::schema::HasInputField<isoCode_gt, Option<super::super::String>>
            for super::super::CountryWhereInput
        {
        }
        pub struct isoCode_gte;
        impl ::cynic::schema::Field for isoCode_gte {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "isoCode_gte";
        }
        impl ::cynic::schema::HasInputField<isoCode_gte, Option<super::super::String>>
            for super::super::CountryWhereInput
        {
        }
        pub struct isoCode_contains;
        impl ::cynic::schema::Field for isoCode_contains {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "isoCode_contains";
        }
        impl ::cynic::schema::HasInputField<isoCode_contains, Option<super::super::String>>
            for super::super::CountryWhereInput
        {
        }
        pub struct isoCode_not_contains;
        impl ::cynic::schema::Field for isoCode_not_contains {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "isoCode_not_contains";
        }
        impl ::cynic::schema::HasInputField<isoCode_not_contains, Option<super::super::String>>
            for super::super::CountryWhereInput
        {
        }
        pub struct isoCode_starts_with;
        impl ::cynic::schema::Field for isoCode_starts_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "isoCode_starts_with";
        }
        impl ::cynic::schema::HasInputField<isoCode_starts_with, Option<super::super::String>>
            for super::super::CountryWhereInput
        {
        }
        pub struct isoCode_not_starts_with;
        impl ::cynic::schema::Field for isoCode_not_starts_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "isoCode_not_starts_with";
        }
        impl ::cynic::schema::HasInputField<isoCode_not_starts_with, Option<super::super::String>>
            for super::super::CountryWhereInput
        {
        }
        pub struct isoCode_ends_with;
        impl ::cynic::schema::Field for isoCode_ends_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "isoCode_ends_with";
        }
        impl ::cynic::schema::HasInputField<isoCode_ends_with, Option<super::super::String>>
            for super::super::CountryWhereInput
        {
        }
        pub struct isoCode_not_ends_with;
        impl ::cynic::schema::Field for isoCode_not_ends_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "isoCode_not_ends_with";
        }
        impl ::cynic::schema::HasInputField<isoCode_not_ends_with, Option<super::super::String>>
            for super::super::CountryWhereInput
        {
        }
        pub struct cities_every;
        impl ::cynic::schema::Field for cities_every {
            type Type = Option<super::super::CityWhereInput>;
            const NAME: &'static str = "cities_every";
        }
        impl ::cynic::schema::HasInputField<cities_every, Option<super::super::CityWhereInput>>
            for super::super::CountryWhereInput
        {
        }
        pub struct cities_some;
        impl ::cynic::schema::Field for cities_some {
            type Type = Option<super::super::CityWhereInput>;
            const NAME: &'static str = "cities_some";
        }
        impl ::cynic::schema::HasInputField<cities_some, Option<super::super::CityWhereInput>>
            for super::super::CountryWhereInput
        {
        }
        pub struct cities_none;
        impl ::cynic::schema::Field for cities_none {
            type Type = Option<super::super::CityWhereInput>;
            const NAME: &'static str = "cities_none";
        }
        impl ::cynic::schema::HasInputField<cities_none, Option<super::super::CityWhereInput>>
            for super::super::CountryWhereInput
        {
        }
        pub struct jobs_every;
        impl ::cynic::schema::Field for jobs_every {
            type Type = Option<super::super::JobWhereInput>;
            const NAME: &'static str = "jobs_every";
        }
        impl ::cynic::schema::HasInputField<jobs_every, Option<super::super::JobWhereInput>>
            for super::super::CountryWhereInput
        {
        }
        pub struct jobs_some;
        impl ::cynic::schema::Field for jobs_some {
            type Type = Option<super::super::JobWhereInput>;
            const NAME: &'static str = "jobs_some";
        }
        impl ::cynic::schema::HasInputField<jobs_some, Option<super::super::JobWhereInput>>
            for super::super::CountryWhereInput
        {
        }
        pub struct jobs_none;
        impl ::cynic::schema::Field for jobs_none {
            type Type = Option<super::super::JobWhereInput>;
            const NAME: &'static str = "jobs_none";
        }
        impl ::cynic::schema::HasInputField<jobs_none, Option<super::super::JobWhereInput>>
            for super::super::CountryWhereInput
        {
        }
        pub struct createdAt;
        impl ::cynic::schema::Field for createdAt {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt";
        }
        impl ::cynic::schema::HasInputField<createdAt, Option<super::super::DateTime>>
            for super::super::CountryWhereInput
        {
        }
        pub struct createdAt_not;
        impl ::cynic::schema::Field for createdAt_not {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt_not";
        }
        impl ::cynic::schema::HasInputField<createdAt_not, Option<super::super::DateTime>>
            for super::super::CountryWhereInput
        {
        }
        pub struct createdAt_in;
        impl ::cynic::schema::Field for createdAt_in {
            type Type = Option<Vec<super::super::DateTime>>;
            const NAME: &'static str = "createdAt_in";
        }
        impl ::cynic::schema::HasInputField<createdAt_in, Option<Vec<super::super::DateTime>>>
            for super::super::CountryWhereInput
        {
        }
        pub struct createdAt_not_in;
        impl ::cynic::schema::Field for createdAt_not_in {
            type Type = Option<Vec<super::super::DateTime>>;
            const NAME: &'static str = "createdAt_not_in";
        }
        impl ::cynic::schema::HasInputField<createdAt_not_in, Option<Vec<super::super::DateTime>>>
            for super::super::CountryWhereInput
        {
        }
        pub struct createdAt_lt;
        impl ::cynic::schema::Field for createdAt_lt {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt_lt";
        }
        impl ::cynic::schema::HasInputField<createdAt_lt, Option<super::super::DateTime>>
            for super::super::CountryWhereInput
        {
        }
        pub struct createdAt_lte;
        impl ::cynic::schema::Field for createdAt_lte {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt_lte";
        }
        impl ::cynic::schema::HasInputField<createdAt_lte, Option<super::super::DateTime>>
            for super::super::CountryWhereInput
        {
        }
        pub struct createdAt_gt;
        impl ::cynic::schema::Field for createdAt_gt {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt_gt";
        }
        impl ::cynic::schema::HasInputField<createdAt_gt, Option<super::super::DateTime>>
            for super::super::CountryWhereInput
        {
        }
        pub struct createdAt_gte;
        impl ::cynic::schema::Field for createdAt_gte {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt_gte";
        }
        impl ::cynic::schema::HasInputField<createdAt_gte, Option<super::super::DateTime>>
            for super::super::CountryWhereInput
        {
        }
        pub struct updatedAt;
        impl ::cynic::schema::Field for updatedAt {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt";
        }
        impl ::cynic::schema::HasInputField<updatedAt, Option<super::super::DateTime>>
            for super::super::CountryWhereInput
        {
        }
        pub struct updatedAt_not;
        impl ::cynic::schema::Field for updatedAt_not {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt_not";
        }
        impl ::cynic::schema::HasInputField<updatedAt_not, Option<super::super::DateTime>>
            for super::super::CountryWhereInput
        {
        }
        pub struct updatedAt_in;
        impl ::cynic::schema::Field for updatedAt_in {
            type Type = Option<Vec<super::super::DateTime>>;
            const NAME: &'static str = "updatedAt_in";
        }
        impl ::cynic::schema::HasInputField<updatedAt_in, Option<Vec<super::super::DateTime>>>
            for super::super::CountryWhereInput
        {
        }
        pub struct updatedAt_not_in;
        impl ::cynic::schema::Field for updatedAt_not_in {
            type Type = Option<Vec<super::super::DateTime>>;
            const NAME: &'static str = "updatedAt_not_in";
        }
        impl ::cynic::schema::HasInputField<updatedAt_not_in, Option<Vec<super::super::DateTime>>>
            for super::super::CountryWhereInput
        {
        }
        pub struct updatedAt_lt;
        impl ::cynic::schema::Field for updatedAt_lt {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt_lt";
        }
        impl ::cynic::schema::HasInputField<updatedAt_lt, Option<super::super::DateTime>>
            for super::super::CountryWhereInput
        {
        }
        pub struct updatedAt_lte;
        impl ::cynic::schema::Field for updatedAt_lte {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt_lte";
        }
        impl ::cynic::schema::HasInputField<updatedAt_lte, Option<super::super::DateTime>>
            for super::super::CountryWhereInput
        {
        }
        pub struct updatedAt_gt;
        impl ::cynic::schema::Field for updatedAt_gt {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt_gt";
        }
        impl ::cynic::schema::HasInputField<updatedAt_gt, Option<super::super::DateTime>>
            for super::super::CountryWhereInput
        {
        }
        pub struct updatedAt_gte;
        impl ::cynic::schema::Field for updatedAt_gte {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt_gte";
        }
        impl ::cynic::schema::HasInputField<updatedAt_gte, Option<super::super::DateTime>>
            for super::super::CountryWhereInput
        {
        }
        pub struct AND;
        impl ::cynic::schema::Field for AND {
            type Type = Option<Vec<super::super::CountryWhereInput>>;
            const NAME: &'static str = "AND";
        }
        impl ::cynic::schema::HasInputField<AND, Option<Vec<super::super::CountryWhereInput>>>
            for super::super::CountryWhereInput
        {
        }
        pub struct OR;
        impl ::cynic::schema::Field for OR {
            type Type = Option<Vec<super::super::CountryWhereInput>>;
            const NAME: &'static str = "OR";
        }
        impl ::cynic::schema::HasInputField<OR, Option<Vec<super::super::CountryWhereInput>>>
            for super::super::CountryWhereInput
        {
        }
        pub struct NOT;
        impl ::cynic::schema::Field for NOT {
            type Type = Option<Vec<super::super::CountryWhereInput>>;
            const NAME: &'static str = "NOT";
        }
        impl ::cynic::schema::HasInputField<NOT, Option<Vec<super::super::CountryWhereInput>>>
            for super::super::CountryWhereInput
        {
        }
    }
    pub mod Job {
        pub struct id;
        impl ::cynic::schema::Field for id {
            type Type = super::super::ID;
            const NAME: &'static str = "id";
        }
        impl ::cynic::schema::HasField<id> for super::super::Job {
            type Type = super::super::ID;
        }
        pub struct title;
        impl ::cynic::schema::Field for title {
            type Type = super::super::String;
            const NAME: &'static str = "title";
        }
        impl ::cynic::schema::HasField<title> for super::super::Job {
            type Type = super::super::String;
        }
        pub struct slug;
        impl ::cynic::schema::Field for slug {
            type Type = super::super::String;
            const NAME: &'static str = "slug";
        }
        impl ::cynic::schema::HasField<slug> for super::super::Job {
            type Type = super::super::String;
        }
        pub struct commitment;
        impl ::cynic::schema::Field for commitment {
            type Type = super::super::Commitment;
            const NAME: &'static str = "commitment";
        }
        impl ::cynic::schema::HasField<commitment> for super::super::Job {
            type Type = super::super::Commitment;
        }
        pub struct cities;
        impl ::cynic::schema::Field for cities {
            type Type = Option<Vec<super::super::City>>;
            const NAME: &'static str = "cities";
        }
        impl ::cynic::schema::HasField<cities> for super::super::Job {
            type Type = Option<Vec<super::super::City>>;
        }
        pub mod _cities_arguments {
            pub struct r#where;
            impl ::cynic::schema::HasArgument<r#where> for super::cities {
                type ArgumentType = Option<super::super::super::CityWhereInput>;
                const NAME: &'static str = "where";
            }
            pub struct orderBy;
            impl ::cynic::schema::HasArgument<orderBy> for super::cities {
                type ArgumentType = Option<super::super::super::CityOrderByInput>;
                const NAME: &'static str = "orderBy";
            }
            pub struct skip;
            impl ::cynic::schema::HasArgument<skip> for super::cities {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "skip";
            }
            pub struct after;
            impl ::cynic::schema::HasArgument<after> for super::cities {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "after";
            }
            pub struct before;
            impl ::cynic::schema::HasArgument<before> for super::cities {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "before";
            }
            pub struct first;
            impl ::cynic::schema::HasArgument<first> for super::cities {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "first";
            }
            pub struct last;
            impl ::cynic::schema::HasArgument<last> for super::cities {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "last";
            }
        }
        pub struct countries;
        impl ::cynic::schema::Field for countries {
            type Type = Option<Vec<super::super::Country>>;
            const NAME: &'static str = "countries";
        }
        impl ::cynic::schema::HasField<countries> for super::super::Job {
            type Type = Option<Vec<super::super::Country>>;
        }
        pub mod _countries_arguments {
            pub struct r#where;
            impl ::cynic::schema::HasArgument<r#where> for super::countries {
                type ArgumentType = Option<super::super::super::CountryWhereInput>;
                const NAME: &'static str = "where";
            }
            pub struct orderBy;
            impl ::cynic::schema::HasArgument<orderBy> for super::countries {
                type ArgumentType = Option<super::super::super::CountryOrderByInput>;
                const NAME: &'static str = "orderBy";
            }
            pub struct skip;
            impl ::cynic::schema::HasArgument<skip> for super::countries {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "skip";
            }
            pub struct after;
            impl ::cynic::schema::HasArgument<after> for super::countries {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "after";
            }
            pub struct before;
            impl ::cynic::schema::HasArgument<before> for super::countries {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "before";
            }
            pub struct first;
            impl ::cynic::schema::HasArgument<first> for super::countries {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "first";
            }
            pub struct last;
            impl ::cynic::schema::HasArgument<last> for super::countries {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "last";
            }
        }
        pub struct remotes;
        impl ::cynic::schema::Field for remotes {
            type Type = Option<Vec<super::super::Remote>>;
            const NAME: &'static str = "remotes";
        }
        impl ::cynic::schema::HasField<remotes> for super::super::Job {
            type Type = Option<Vec<super::super::Remote>>;
        }
        pub mod _remotes_arguments {
            pub struct r#where;
            impl ::cynic::schema::HasArgument<r#where> for super::remotes {
                type ArgumentType = Option<super::super::super::RemoteWhereInput>;
                const NAME: &'static str = "where";
            }
            pub struct orderBy;
            impl ::cynic::schema::HasArgument<orderBy> for super::remotes {
                type ArgumentType = Option<super::super::super::RemoteOrderByInput>;
                const NAME: &'static str = "orderBy";
            }
            pub struct skip;
            impl ::cynic::schema::HasArgument<skip> for super::remotes {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "skip";
            }
            pub struct after;
            impl ::cynic::schema::HasArgument<after> for super::remotes {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "after";
            }
            pub struct before;
            impl ::cynic::schema::HasArgument<before> for super::remotes {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "before";
            }
            pub struct first;
            impl ::cynic::schema::HasArgument<first> for super::remotes {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "first";
            }
            pub struct last;
            impl ::cynic::schema::HasArgument<last> for super::remotes {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "last";
            }
        }
        pub struct description;
        impl ::cynic::schema::Field for description {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "description";
        }
        impl ::cynic::schema::HasField<description> for super::super::Job {
            type Type = Option<super::super::String>;
        }
        pub struct applyUrl;
        impl ::cynic::schema::Field for applyUrl {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "applyUrl";
        }
        impl ::cynic::schema::HasField<applyUrl> for super::super::Job {
            type Type = Option<super::super::String>;
        }
        pub struct company;
        impl ::cynic::schema::Field for company {
            type Type = Option<super::super::Company>;
            const NAME: &'static str = "company";
        }
        impl ::cynic::schema::HasField<company> for super::super::Job {
            type Type = Option<super::super::Company>;
        }
        pub struct tags;
        impl ::cynic::schema::Field for tags {
            type Type = Option<Vec<super::super::Tag>>;
            const NAME: &'static str = "tags";
        }
        impl ::cynic::schema::HasField<tags> for super::super::Job {
            type Type = Option<Vec<super::super::Tag>>;
        }
        pub mod _tags_arguments {
            pub struct r#where;
            impl ::cynic::schema::HasArgument<r#where> for super::tags {
                type ArgumentType = Option<super::super::super::TagWhereInput>;
                const NAME: &'static str = "where";
            }
            pub struct orderBy;
            impl ::cynic::schema::HasArgument<orderBy> for super::tags {
                type ArgumentType = Option<super::super::super::TagOrderByInput>;
                const NAME: &'static str = "orderBy";
            }
            pub struct skip;
            impl ::cynic::schema::HasArgument<skip> for super::tags {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "skip";
            }
            pub struct after;
            impl ::cynic::schema::HasArgument<after> for super::tags {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "after";
            }
            pub struct before;
            impl ::cynic::schema::HasArgument<before> for super::tags {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "before";
            }
            pub struct first;
            impl ::cynic::schema::HasArgument<first> for super::tags {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "first";
            }
            pub struct last;
            impl ::cynic::schema::HasArgument<last> for super::tags {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "last";
            }
        }
        pub struct isPublished;
        impl ::cynic::schema::Field for isPublished {
            type Type = Option<super::super::Boolean>;
            const NAME: &'static str = "isPublished";
        }
        impl ::cynic::schema::HasField<isPublished> for super::super::Job {
            type Type = Option<super::super::Boolean>;
        }
        pub struct isFeatured;
        impl ::cynic::schema::Field for isFeatured {
            type Type = Option<super::super::Boolean>;
            const NAME: &'static str = "isFeatured";
        }
        impl ::cynic::schema::HasField<isFeatured> for super::super::Job {
            type Type = Option<super::super::Boolean>;
        }
        pub struct locationNames;
        impl ::cynic::schema::Field for locationNames {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "locationNames";
        }
        impl ::cynic::schema::HasField<locationNames> for super::super::Job {
            type Type = Option<super::super::String>;
        }
        pub struct userEmail;
        impl ::cynic::schema::Field for userEmail {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "userEmail";
        }
        impl ::cynic::schema::HasField<userEmail> for super::super::Job {
            type Type = Option<super::super::String>;
        }
        pub struct postedAt;
        impl ::cynic::schema::Field for postedAt {
            type Type = super::super::DateTime;
            const NAME: &'static str = "postedAt";
        }
        impl ::cynic::schema::HasField<postedAt> for super::super::Job {
            type Type = super::super::DateTime;
        }
        pub struct createdAt;
        impl ::cynic::schema::Field for createdAt {
            type Type = super::super::DateTime;
            const NAME: &'static str = "createdAt";
        }
        impl ::cynic::schema::HasField<createdAt> for super::super::Job {
            type Type = super::super::DateTime;
        }
        pub struct updatedAt;
        impl ::cynic::schema::Field for updatedAt {
            type Type = super::super::DateTime;
            const NAME: &'static str = "updatedAt";
        }
        impl ::cynic::schema::HasField<updatedAt> for super::super::Job {
            type Type = super::super::DateTime;
        }
        pub struct __typename;
        impl ::cynic::schema::Field for __typename {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
        impl ::cynic::schema::HasField<__typename> for super::super::Job {
            type Type = super::super::String;
        }
    }
    pub mod JobInput {
        pub struct companySlug;
        impl ::cynic::schema::Field for companySlug {
            type Type = super::super::String;
            const NAME: &'static str = "companySlug";
        }
        impl ::cynic::schema::HasInputField<companySlug, super::super::String> for super::super::JobInput {}
        pub struct jobSlug;
        impl ::cynic::schema::Field for jobSlug {
            type Type = super::super::String;
            const NAME: &'static str = "jobSlug";
        }
        impl ::cynic::schema::HasInputField<jobSlug, super::super::String> for super::super::JobInput {}
    }
    pub mod JobWhereInput {
        pub struct id;
        impl ::cynic::schema::Field for id {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id";
        }
        impl ::cynic::schema::HasInputField<id, Option<super::super::ID>> for super::super::JobWhereInput {}
        pub struct id_not;
        impl ::cynic::schema::Field for id_not {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_not";
        }
        impl ::cynic::schema::HasInputField<id_not, Option<super::super::ID>>
            for super::super::JobWhereInput
        {
        }
        pub struct id_in;
        impl ::cynic::schema::Field for id_in {
            type Type = Option<Vec<super::super::ID>>;
            const NAME: &'static str = "id_in";
        }
        impl ::cynic::schema::HasInputField<id_in, Option<Vec<super::super::ID>>>
            for super::super::JobWhereInput
        {
        }
        pub struct id_not_in;
        impl ::cynic::schema::Field for id_not_in {
            type Type = Option<Vec<super::super::ID>>;
            const NAME: &'static str = "id_not_in";
        }
        impl ::cynic::schema::HasInputField<id_not_in, Option<Vec<super::super::ID>>>
            for super::super::JobWhereInput
        {
        }
        pub struct id_lt;
        impl ::cynic::schema::Field for id_lt {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_lt";
        }
        impl ::cynic::schema::HasInputField<id_lt, Option<super::super::ID>>
            for super::super::JobWhereInput
        {
        }
        pub struct id_lte;
        impl ::cynic::schema::Field for id_lte {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_lte";
        }
        impl ::cynic::schema::HasInputField<id_lte, Option<super::super::ID>>
            for super::super::JobWhereInput
        {
        }
        pub struct id_gt;
        impl ::cynic::schema::Field for id_gt {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_gt";
        }
        impl ::cynic::schema::HasInputField<id_gt, Option<super::super::ID>>
            for super::super::JobWhereInput
        {
        }
        pub struct id_gte;
        impl ::cynic::schema::Field for id_gte {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_gte";
        }
        impl ::cynic::schema::HasInputField<id_gte, Option<super::super::ID>>
            for super::super::JobWhereInput
        {
        }
        pub struct id_contains;
        impl ::cynic::schema::Field for id_contains {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_contains";
        }
        impl ::cynic::schema::HasInputField<id_contains, Option<super::super::ID>>
            for super::super::JobWhereInput
        {
        }
        pub struct id_not_contains;
        impl ::cynic::schema::Field for id_not_contains {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_not_contains";
        }
        impl ::cynic::schema::HasInputField<id_not_contains, Option<super::super::ID>>
            for super::super::JobWhereInput
        {
        }
        pub struct id_starts_with;
        impl ::cynic::schema::Field for id_starts_with {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_starts_with";
        }
        impl ::cynic::schema::HasInputField<id_starts_with, Option<super::super::ID>>
            for super::super::JobWhereInput
        {
        }
        pub struct id_not_starts_with;
        impl ::cynic::schema::Field for id_not_starts_with {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_not_starts_with";
        }
        impl ::cynic::schema::HasInputField<id_not_starts_with, Option<super::super::ID>>
            for super::super::JobWhereInput
        {
        }
        pub struct id_ends_with;
        impl ::cynic::schema::Field for id_ends_with {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_ends_with";
        }
        impl ::cynic::schema::HasInputField<id_ends_with, Option<super::super::ID>>
            for super::super::JobWhereInput
        {
        }
        pub struct id_not_ends_with;
        impl ::cynic::schema::Field for id_not_ends_with {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_not_ends_with";
        }
        impl ::cynic::schema::HasInputField<id_not_ends_with, Option<super::super::ID>>
            for super::super::JobWhereInput
        {
        }
        pub struct title;
        impl ::cynic::schema::Field for title {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "title";
        }
        impl ::cynic::schema::HasInputField<title, Option<super::super::String>>
            for super::super::JobWhereInput
        {
        }
        pub struct title_not;
        impl ::cynic::schema::Field for title_not {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "title_not";
        }
        impl ::cynic::schema::HasInputField<title_not, Option<super::super::String>>
            for super::super::JobWhereInput
        {
        }
        pub struct title_in;
        impl ::cynic::schema::Field for title_in {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "title_in";
        }
        impl ::cynic::schema::HasInputField<title_in, Option<Vec<super::super::String>>>
            for super::super::JobWhereInput
        {
        }
        pub struct title_not_in;
        impl ::cynic::schema::Field for title_not_in {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "title_not_in";
        }
        impl ::cynic::schema::HasInputField<title_not_in, Option<Vec<super::super::String>>>
            for super::super::JobWhereInput
        {
        }
        pub struct title_lt;
        impl ::cynic::schema::Field for title_lt {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "title_lt";
        }
        impl ::cynic::schema::HasInputField<title_lt, Option<super::super::String>>
            for super::super::JobWhereInput
        {
        }
        pub struct title_lte;
        impl ::cynic::schema::Field for title_lte {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "title_lte";
        }
        impl ::cynic::schema::HasInputField<title_lte, Option<super::super::String>>
            for super::super::JobWhereInput
        {
        }
        pub struct title_gt;
        impl ::cynic::schema::Field for title_gt {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "title_gt";
        }
        impl ::cynic::schema::HasInputField<title_gt, Option<super::super::String>>
            for super::super::JobWhereInput
        {
        }
        pub struct title_gte;
        impl ::cynic::schema::Field for title_gte {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "title_gte";
        }
        impl ::cynic::schema::HasInputField<title_gte, Option<super::super::String>>
            for super::super::JobWhereInput
        {
        }
        pub struct title_contains;
        impl ::cynic::schema::Field for title_contains {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "title_contains";
        }
        impl ::cynic::schema::HasInputField<title_contains, Option<super::super::String>>
            for super::super::JobWhereInput
        {
        }
        pub struct title_not_contains;
        impl ::cynic::schema::Field for title_not_contains {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "title_not_contains";
        }
        impl ::cynic::schema::HasInputField<title_not_contains, Option<super::super::String>>
            for super::super::JobWhereInput
        {
        }
        pub struct title_starts_with;
        impl ::cynic::schema::Field for title_starts_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "title_starts_with";
        }
        impl ::cynic::schema::HasInputField<title_starts_with, Option<super::super::String>>
            for super::super::JobWhereInput
        {
        }
        pub struct title_not_starts_with;
        impl ::cynic::schema::Field for title_not_starts_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "title_not_starts_with";
        }
        impl ::cynic::schema::HasInputField<title_not_starts_with, Option<super::super::String>>
            for super::super::JobWhereInput
        {
        }
        pub struct title_ends_with;
        impl ::cynic::schema::Field for title_ends_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "title_ends_with";
        }
        impl ::cynic::schema::HasInputField<title_ends_with, Option<super::super::String>>
            for super::super::JobWhereInput
        {
        }
        pub struct title_not_ends_with;
        impl ::cynic::schema::Field for title_not_ends_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "title_not_ends_with";
        }
        impl ::cynic::schema::HasInputField<title_not_ends_with, Option<super::super::String>>
            for super::super::JobWhereInput
        {
        }
        pub struct slug;
        impl ::cynic::schema::Field for slug {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug";
        }
        impl ::cynic::schema::HasInputField<slug, Option<super::super::String>>
            for super::super::JobWhereInput
        {
        }
        pub struct slug_not;
        impl ::cynic::schema::Field for slug_not {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_not";
        }
        impl ::cynic::schema::HasInputField<slug_not, Option<super::super::String>>
            for super::super::JobWhereInput
        {
        }
        pub struct slug_in;
        impl ::cynic::schema::Field for slug_in {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "slug_in";
        }
        impl ::cynic::schema::HasInputField<slug_in, Option<Vec<super::super::String>>>
            for super::super::JobWhereInput
        {
        }
        pub struct slug_not_in;
        impl ::cynic::schema::Field for slug_not_in {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "slug_not_in";
        }
        impl ::cynic::schema::HasInputField<slug_not_in, Option<Vec<super::super::String>>>
            for super::super::JobWhereInput
        {
        }
        pub struct slug_lt;
        impl ::cynic::schema::Field for slug_lt {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_lt";
        }
        impl ::cynic::schema::HasInputField<slug_lt, Option<super::super::String>>
            for super::super::JobWhereInput
        {
        }
        pub struct slug_lte;
        impl ::cynic::schema::Field for slug_lte {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_lte";
        }
        impl ::cynic::schema::HasInputField<slug_lte, Option<super::super::String>>
            for super::super::JobWhereInput
        {
        }
        pub struct slug_gt;
        impl ::cynic::schema::Field for slug_gt {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_gt";
        }
        impl ::cynic::schema::HasInputField<slug_gt, Option<super::super::String>>
            for super::super::JobWhereInput
        {
        }
        pub struct slug_gte;
        impl ::cynic::schema::Field for slug_gte {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_gte";
        }
        impl ::cynic::schema::HasInputField<slug_gte, Option<super::super::String>>
            for super::super::JobWhereInput
        {
        }
        pub struct slug_contains;
        impl ::cynic::schema::Field for slug_contains {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_contains";
        }
        impl ::cynic::schema::HasInputField<slug_contains, Option<super::super::String>>
            for super::super::JobWhereInput
        {
        }
        pub struct slug_not_contains;
        impl ::cynic::schema::Field for slug_not_contains {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_not_contains";
        }
        impl ::cynic::schema::HasInputField<slug_not_contains, Option<super::super::String>>
            for super::super::JobWhereInput
        {
        }
        pub struct slug_starts_with;
        impl ::cynic::schema::Field for slug_starts_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_starts_with";
        }
        impl ::cynic::schema::HasInputField<slug_starts_with, Option<super::super::String>>
            for super::super::JobWhereInput
        {
        }
        pub struct slug_not_starts_with;
        impl ::cynic::schema::Field for slug_not_starts_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_not_starts_with";
        }
        impl ::cynic::schema::HasInputField<slug_not_starts_with, Option<super::super::String>>
            for super::super::JobWhereInput
        {
        }
        pub struct slug_ends_with;
        impl ::cynic::schema::Field for slug_ends_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_ends_with";
        }
        impl ::cynic::schema::HasInputField<slug_ends_with, Option<super::super::String>>
            for super::super::JobWhereInput
        {
        }
        pub struct slug_not_ends_with;
        impl ::cynic::schema::Field for slug_not_ends_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_not_ends_with";
        }
        impl ::cynic::schema::HasInputField<slug_not_ends_with, Option<super::super::String>>
            for super::super::JobWhereInput
        {
        }
        pub struct commitment;
        impl ::cynic::schema::Field for commitment {
            type Type = Option<super::super::CommitmentWhereInput>;
            const NAME: &'static str = "commitment";
        }
        impl ::cynic::schema::HasInputField<commitment, Option<super::super::CommitmentWhereInput>>
            for super::super::JobWhereInput
        {
        }
        pub struct cities_every;
        impl ::cynic::schema::Field for cities_every {
            type Type = Option<super::super::CityWhereInput>;
            const NAME: &'static str = "cities_every";
        }
        impl ::cynic::schema::HasInputField<cities_every, Option<super::super::CityWhereInput>>
            for super::super::JobWhereInput
        {
        }
        pub struct cities_some;
        impl ::cynic::schema::Field for cities_some {
            type Type = Option<super::super::CityWhereInput>;
            const NAME: &'static str = "cities_some";
        }
        impl ::cynic::schema::HasInputField<cities_some, Option<super::super::CityWhereInput>>
            for super::super::JobWhereInput
        {
        }
        pub struct cities_none;
        impl ::cynic::schema::Field for cities_none {
            type Type = Option<super::super::CityWhereInput>;
            const NAME: &'static str = "cities_none";
        }
        impl ::cynic::schema::HasInputField<cities_none, Option<super::super::CityWhereInput>>
            for super::super::JobWhereInput
        {
        }
        pub struct countries_every;
        impl ::cynic::schema::Field for countries_every {
            type Type = Option<super::super::CountryWhereInput>;
            const NAME: &'static str = "countries_every";
        }
        impl
            ::cynic::schema::HasInputField<countries_every, Option<super::super::CountryWhereInput>>
            for super::super::JobWhereInput
        {
        }
        pub struct countries_some;
        impl ::cynic::schema::Field for countries_some {
            type Type = Option<super::super::CountryWhereInput>;
            const NAME: &'static str = "countries_some";
        }
        impl ::cynic::schema::HasInputField<countries_some, Option<super::super::CountryWhereInput>>
            for super::super::JobWhereInput
        {
        }
        pub struct countries_none;
        impl ::cynic::schema::Field for countries_none {
            type Type = Option<super::super::CountryWhereInput>;
            const NAME: &'static str = "countries_none";
        }
        impl ::cynic::schema::HasInputField<countries_none, Option<super::super::CountryWhereInput>>
            for super::super::JobWhereInput
        {
        }
        pub struct remotes_every;
        impl ::cynic::schema::Field for remotes_every {
            type Type = Option<super::super::RemoteWhereInput>;
            const NAME: &'static str = "remotes_every";
        }
        impl ::cynic::schema::HasInputField<remotes_every, Option<super::super::RemoteWhereInput>>
            for super::super::JobWhereInput
        {
        }
        pub struct remotes_some;
        impl ::cynic::schema::Field for remotes_some {
            type Type = Option<super::super::RemoteWhereInput>;
            const NAME: &'static str = "remotes_some";
        }
        impl ::cynic::schema::HasInputField<remotes_some, Option<super::super::RemoteWhereInput>>
            for super::super::JobWhereInput
        {
        }
        pub struct remotes_none;
        impl ::cynic::schema::Field for remotes_none {
            type Type = Option<super::super::RemoteWhereInput>;
            const NAME: &'static str = "remotes_none";
        }
        impl ::cynic::schema::HasInputField<remotes_none, Option<super::super::RemoteWhereInput>>
            for super::super::JobWhereInput
        {
        }
        pub struct description;
        impl ::cynic::schema::Field for description {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "description";
        }
        impl ::cynic::schema::HasInputField<description, Option<super::super::String>>
            for super::super::JobWhereInput
        {
        }
        pub struct description_not;
        impl ::cynic::schema::Field for description_not {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "description_not";
        }
        impl ::cynic::schema::HasInputField<description_not, Option<super::super::String>>
            for super::super::JobWhereInput
        {
        }
        pub struct description_in;
        impl ::cynic::schema::Field for description_in {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "description_in";
        }
        impl ::cynic::schema::HasInputField<description_in, Option<Vec<super::super::String>>>
            for super::super::JobWhereInput
        {
        }
        pub struct description_not_in;
        impl ::cynic::schema::Field for description_not_in {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "description_not_in";
        }
        impl ::cynic::schema::HasInputField<description_not_in, Option<Vec<super::super::String>>>
            for super::super::JobWhereInput
        {
        }
        pub struct description_lt;
        impl ::cynic::schema::Field for description_lt {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "description_lt";
        }
        impl ::cynic::schema::HasInputField<description_lt, Option<super::super::String>>
            for super::super::JobWhereInput
        {
        }
        pub struct description_lte;
        impl ::cynic::schema::Field for description_lte {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "description_lte";
        }
        impl ::cynic::schema::HasInputField<description_lte, Option<super::super::String>>
            for super::super::JobWhereInput
        {
        }
        pub struct description_gt;
        impl ::cynic::schema::Field for description_gt {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "description_gt";
        }
        impl ::cynic::schema::HasInputField<description_gt, Option<super::super::String>>
            for super::super::JobWhereInput
        {
        }
        pub struct description_gte;
        impl ::cynic::schema::Field for description_gte {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "description_gte";
        }
        impl ::cynic::schema::HasInputField<description_gte, Option<super::super::String>>
            for super::super::JobWhereInput
        {
        }
        pub struct description_contains;
        impl ::cynic::schema::Field for description_contains {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "description_contains";
        }
        impl ::cynic::schema::HasInputField<description_contains, Option<super::super::String>>
            for super::super::JobWhereInput
        {
        }
        pub struct description_not_contains;
        impl ::cynic::schema::Field for description_not_contains {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "description_not_contains";
        }
        impl ::cynic::schema::HasInputField<description_not_contains, Option<super::super::String>>
            for super::super::JobWhereInput
        {
        }
        pub struct description_starts_with;
        impl ::cynic::schema::Field for description_starts_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "description_starts_with";
        }
        impl ::cynic::schema::HasInputField<description_starts_with, Option<super::super::String>>
            for super::super::JobWhereInput
        {
        }
        pub struct description_not_starts_with;
        impl ::cynic::schema::Field for description_not_starts_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "description_not_starts_with";
        }
        impl
            ::cynic::schema::HasInputField<
                description_not_starts_with,
                Option<super::super::String>,
            > for super::super::JobWhereInput
        {
        }
        pub struct description_ends_with;
        impl ::cynic::schema::Field for description_ends_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "description_ends_with";
        }
        impl ::cynic::schema::HasInputField<description_ends_with, Option<super::super::String>>
            for super::super::JobWhereInput
        {
        }
        pub struct description_not_ends_with;
        impl ::cynic::schema::Field for description_not_ends_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "description_not_ends_with";
        }
        impl ::cynic::schema::HasInputField<description_not_ends_with, Option<super::super::String>>
            for super::super::JobWhereInput
        {
        }
        pub struct applyUrl;
        impl ::cynic::schema::Field for applyUrl {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "applyUrl";
        }
        impl ::cynic::schema::HasInputField<applyUrl, Option<super::super::String>>
            for super::super::JobWhereInput
        {
        }
        pub struct applyUrl_not;
        impl ::cynic::schema::Field for applyUrl_not {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "applyUrl_not";
        }
        impl ::cynic::schema::HasInputField<applyUrl_not, Option<super::super::String>>
            for super::super::JobWhereInput
        {
        }
        pub struct applyUrl_in;
        impl ::cynic::schema::Field for applyUrl_in {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "applyUrl_in";
        }
        impl ::cynic::schema::HasInputField<applyUrl_in, Option<Vec<super::super::String>>>
            for super::super::JobWhereInput
        {
        }
        pub struct applyUrl_not_in;
        impl ::cynic::schema::Field for applyUrl_not_in {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "applyUrl_not_in";
        }
        impl ::cynic::schema::HasInputField<applyUrl_not_in, Option<Vec<super::super::String>>>
            for super::super::JobWhereInput
        {
        }
        pub struct applyUrl_lt;
        impl ::cynic::schema::Field for applyUrl_lt {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "applyUrl_lt";
        }
        impl ::cynic::schema::HasInputField<applyUrl_lt, Option<super::super::String>>
            for super::super::JobWhereInput
        {
        }
        pub struct applyUrl_lte;
        impl ::cynic::schema::Field for applyUrl_lte {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "applyUrl_lte";
        }
        impl ::cynic::schema::HasInputField<applyUrl_lte, Option<super::super::String>>
            for super::super::JobWhereInput
        {
        }
        pub struct applyUrl_gt;
        impl ::cynic::schema::Field for applyUrl_gt {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "applyUrl_gt";
        }
        impl ::cynic::schema::HasInputField<applyUrl_gt, Option<super::super::String>>
            for super::super::JobWhereInput
        {
        }
        pub struct applyUrl_gte;
        impl ::cynic::schema::Field for applyUrl_gte {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "applyUrl_gte";
        }
        impl ::cynic::schema::HasInputField<applyUrl_gte, Option<super::super::String>>
            for super::super::JobWhereInput
        {
        }
        pub struct applyUrl_contains;
        impl ::cynic::schema::Field for applyUrl_contains {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "applyUrl_contains";
        }
        impl ::cynic::schema::HasInputField<applyUrl_contains, Option<super::super::String>>
            for super::super::JobWhereInput
        {
        }
        pub struct applyUrl_not_contains;
        impl ::cynic::schema::Field for applyUrl_not_contains {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "applyUrl_not_contains";
        }
        impl ::cynic::schema::HasInputField<applyUrl_not_contains, Option<super::super::String>>
            for super::super::JobWhereInput
        {
        }
        pub struct applyUrl_starts_with;
        impl ::cynic::schema::Field for applyUrl_starts_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "applyUrl_starts_with";
        }
        impl ::cynic::schema::HasInputField<applyUrl_starts_with, Option<super::super::String>>
            for super::super::JobWhereInput
        {
        }
        pub struct applyUrl_not_starts_with;
        impl ::cynic::schema::Field for applyUrl_not_starts_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "applyUrl_not_starts_with";
        }
        impl ::cynic::schema::HasInputField<applyUrl_not_starts_with, Option<super::super::String>>
            for super::super::JobWhereInput
        {
        }
        pub struct applyUrl_ends_with;
        impl ::cynic::schema::Field for applyUrl_ends_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "applyUrl_ends_with";
        }
        impl ::cynic::schema::HasInputField<applyUrl_ends_with, Option<super::super::String>>
            for super::super::JobWhereInput
        {
        }
        pub struct applyUrl_not_ends_with;
        impl ::cynic::schema::Field for applyUrl_not_ends_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "applyUrl_not_ends_with";
        }
        impl ::cynic::schema::HasInputField<applyUrl_not_ends_with, Option<super::super::String>>
            for super::super::JobWhereInput
        {
        }
        pub struct company;
        impl ::cynic::schema::Field for company {
            type Type = Option<super::super::CompanyWhereInput>;
            const NAME: &'static str = "company";
        }
        impl ::cynic::schema::HasInputField<company, Option<super::super::CompanyWhereInput>>
            for super::super::JobWhereInput
        {
        }
        pub struct tags_every;
        impl ::cynic::schema::Field for tags_every {
            type Type = Option<super::super::TagWhereInput>;
            const NAME: &'static str = "tags_every";
        }
        impl ::cynic::schema::HasInputField<tags_every, Option<super::super::TagWhereInput>>
            for super::super::JobWhereInput
        {
        }
        pub struct tags_some;
        impl ::cynic::schema::Field for tags_some {
            type Type = Option<super::super::TagWhereInput>;
            const NAME: &'static str = "tags_some";
        }
        impl ::cynic::schema::HasInputField<tags_some, Option<super::super::TagWhereInput>>
            for super::super::JobWhereInput
        {
        }
        pub struct tags_none;
        impl ::cynic::schema::Field for tags_none {
            type Type = Option<super::super::TagWhereInput>;
            const NAME: &'static str = "tags_none";
        }
        impl ::cynic::schema::HasInputField<tags_none, Option<super::super::TagWhereInput>>
            for super::super::JobWhereInput
        {
        }
        pub struct isPublished;
        impl ::cynic::schema::Field for isPublished {
            type Type = Option<super::super::Boolean>;
            const NAME: &'static str = "isPublished";
        }
        impl ::cynic::schema::HasInputField<isPublished, Option<super::super::Boolean>>
            for super::super::JobWhereInput
        {
        }
        pub struct isPublished_not;
        impl ::cynic::schema::Field for isPublished_not {
            type Type = Option<super::super::Boolean>;
            const NAME: &'static str = "isPublished_not";
        }
        impl ::cynic::schema::HasInputField<isPublished_not, Option<super::super::Boolean>>
            for super::super::JobWhereInput
        {
        }
        pub struct isFeatured;
        impl ::cynic::schema::Field for isFeatured {
            type Type = Option<super::super::Boolean>;
            const NAME: &'static str = "isFeatured";
        }
        impl ::cynic::schema::HasInputField<isFeatured, Option<super::super::Boolean>>
            for super::super::JobWhereInput
        {
        }
        pub struct isFeatured_not;
        impl ::cynic::schema::Field for isFeatured_not {
            type Type = Option<super::super::Boolean>;
            const NAME: &'static str = "isFeatured_not";
        }
        impl ::cynic::schema::HasInputField<isFeatured_not, Option<super::super::Boolean>>
            for super::super::JobWhereInput
        {
        }
        pub struct locationNames;
        impl ::cynic::schema::Field for locationNames {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "locationNames";
        }
        impl ::cynic::schema::HasInputField<locationNames, Option<super::super::String>>
            for super::super::JobWhereInput
        {
        }
        pub struct locationNames_not;
        impl ::cynic::schema::Field for locationNames_not {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "locationNames_not";
        }
        impl ::cynic::schema::HasInputField<locationNames_not, Option<super::super::String>>
            for super::super::JobWhereInput
        {
        }
        pub struct locationNames_in;
        impl ::cynic::schema::Field for locationNames_in {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "locationNames_in";
        }
        impl ::cynic::schema::HasInputField<locationNames_in, Option<Vec<super::super::String>>>
            for super::super::JobWhereInput
        {
        }
        pub struct locationNames_not_in;
        impl ::cynic::schema::Field for locationNames_not_in {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "locationNames_not_in";
        }
        impl ::cynic::schema::HasInputField<locationNames_not_in, Option<Vec<super::super::String>>>
            for super::super::JobWhereInput
        {
        }
        pub struct locationNames_lt;
        impl ::cynic::schema::Field for locationNames_lt {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "locationNames_lt";
        }
        impl ::cynic::schema::HasInputField<locationNames_lt, Option<super::super::String>>
            for super::super::JobWhereInput
        {
        }
        pub struct locationNames_lte;
        impl ::cynic::schema::Field for locationNames_lte {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "locationNames_lte";
        }
        impl ::cynic::schema::HasInputField<locationNames_lte, Option<super::super::String>>
            for super::super::JobWhereInput
        {
        }
        pub struct locationNames_gt;
        impl ::cynic::schema::Field for locationNames_gt {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "locationNames_gt";
        }
        impl ::cynic::schema::HasInputField<locationNames_gt, Option<super::super::String>>
            for super::super::JobWhereInput
        {
        }
        pub struct locationNames_gte;
        impl ::cynic::schema::Field for locationNames_gte {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "locationNames_gte";
        }
        impl ::cynic::schema::HasInputField<locationNames_gte, Option<super::super::String>>
            for super::super::JobWhereInput
        {
        }
        pub struct locationNames_contains;
        impl ::cynic::schema::Field for locationNames_contains {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "locationNames_contains";
        }
        impl ::cynic::schema::HasInputField<locationNames_contains, Option<super::super::String>>
            for super::super::JobWhereInput
        {
        }
        pub struct locationNames_not_contains;
        impl ::cynic::schema::Field for locationNames_not_contains {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "locationNames_not_contains";
        }
        impl
            ::cynic::schema::HasInputField<locationNames_not_contains, Option<super::super::String>>
            for super::super::JobWhereInput
        {
        }
        pub struct locationNames_starts_with;
        impl ::cynic::schema::Field for locationNames_starts_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "locationNames_starts_with";
        }
        impl ::cynic::schema::HasInputField<locationNames_starts_with, Option<super::super::String>>
            for super::super::JobWhereInput
        {
        }
        pub struct locationNames_not_starts_with;
        impl ::cynic::schema::Field for locationNames_not_starts_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "locationNames_not_starts_with";
        }
        impl
            ::cynic::schema::HasInputField<
                locationNames_not_starts_with,
                Option<super::super::String>,
            > for super::super::JobWhereInput
        {
        }
        pub struct locationNames_ends_with;
        impl ::cynic::schema::Field for locationNames_ends_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "locationNames_ends_with";
        }
        impl ::cynic::schema::HasInputField<locationNames_ends_with, Option<super::super::String>>
            for super::super::JobWhereInput
        {
        }
        pub struct locationNames_not_ends_with;
        impl ::cynic::schema::Field for locationNames_not_ends_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "locationNames_not_ends_with";
        }
        impl
            ::cynic::schema::HasInputField<
                locationNames_not_ends_with,
                Option<super::super::String>,
            > for super::super::JobWhereInput
        {
        }
        pub struct userEmail;
        impl ::cynic::schema::Field for userEmail {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "userEmail";
        }
        impl ::cynic::schema::HasInputField<userEmail, Option<super::super::String>>
            for super::super::JobWhereInput
        {
        }
        pub struct userEmail_not;
        impl ::cynic::schema::Field for userEmail_not {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "userEmail_not";
        }
        impl ::cynic::schema::HasInputField<userEmail_not, Option<super::super::String>>
            for super::super::JobWhereInput
        {
        }
        pub struct userEmail_in;
        impl ::cynic::schema::Field for userEmail_in {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "userEmail_in";
        }
        impl ::cynic::schema::HasInputField<userEmail_in, Option<Vec<super::super::String>>>
            for super::super::JobWhereInput
        {
        }
        pub struct userEmail_not_in;
        impl ::cynic::schema::Field for userEmail_not_in {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "userEmail_not_in";
        }
        impl ::cynic::schema::HasInputField<userEmail_not_in, Option<Vec<super::super::String>>>
            for super::super::JobWhereInput
        {
        }
        pub struct userEmail_lt;
        impl ::cynic::schema::Field for userEmail_lt {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "userEmail_lt";
        }
        impl ::cynic::schema::HasInputField<userEmail_lt, Option<super::super::String>>
            for super::super::JobWhereInput
        {
        }
        pub struct userEmail_lte;
        impl ::cynic::schema::Field for userEmail_lte {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "userEmail_lte";
        }
        impl ::cynic::schema::HasInputField<userEmail_lte, Option<super::super::String>>
            for super::super::JobWhereInput
        {
        }
        pub struct userEmail_gt;
        impl ::cynic::schema::Field for userEmail_gt {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "userEmail_gt";
        }
        impl ::cynic::schema::HasInputField<userEmail_gt, Option<super::super::String>>
            for super::super::JobWhereInput
        {
        }
        pub struct userEmail_gte;
        impl ::cynic::schema::Field for userEmail_gte {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "userEmail_gte";
        }
        impl ::cynic::schema::HasInputField<userEmail_gte, Option<super::super::String>>
            for super::super::JobWhereInput
        {
        }
        pub struct userEmail_contains;
        impl ::cynic::schema::Field for userEmail_contains {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "userEmail_contains";
        }
        impl ::cynic::schema::HasInputField<userEmail_contains, Option<super::super::String>>
            for super::super::JobWhereInput
        {
        }
        pub struct userEmail_not_contains;
        impl ::cynic::schema::Field for userEmail_not_contains {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "userEmail_not_contains";
        }
        impl ::cynic::schema::HasInputField<userEmail_not_contains, Option<super::super::String>>
            for super::super::JobWhereInput
        {
        }
        pub struct userEmail_starts_with;
        impl ::cynic::schema::Field for userEmail_starts_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "userEmail_starts_with";
        }
        impl ::cynic::schema::HasInputField<userEmail_starts_with, Option<super::super::String>>
            for super::super::JobWhereInput
        {
        }
        pub struct userEmail_not_starts_with;
        impl ::cynic::schema::Field for userEmail_not_starts_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "userEmail_not_starts_with";
        }
        impl ::cynic::schema::HasInputField<userEmail_not_starts_with, Option<super::super::String>>
            for super::super::JobWhereInput
        {
        }
        pub struct userEmail_ends_with;
        impl ::cynic::schema::Field for userEmail_ends_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "userEmail_ends_with";
        }
        impl ::cynic::schema::HasInputField<userEmail_ends_with, Option<super::super::String>>
            for super::super::JobWhereInput
        {
        }
        pub struct userEmail_not_ends_with;
        impl ::cynic::schema::Field for userEmail_not_ends_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "userEmail_not_ends_with";
        }
        impl ::cynic::schema::HasInputField<userEmail_not_ends_with, Option<super::super::String>>
            for super::super::JobWhereInput
        {
        }
        pub struct postedAt;
        impl ::cynic::schema::Field for postedAt {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "postedAt";
        }
        impl ::cynic::schema::HasInputField<postedAt, Option<super::super::DateTime>>
            for super::super::JobWhereInput
        {
        }
        pub struct postedAt_not;
        impl ::cynic::schema::Field for postedAt_not {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "postedAt_not";
        }
        impl ::cynic::schema::HasInputField<postedAt_not, Option<super::super::DateTime>>
            for super::super::JobWhereInput
        {
        }
        pub struct postedAt_in;
        impl ::cynic::schema::Field for postedAt_in {
            type Type = Option<Vec<super::super::DateTime>>;
            const NAME: &'static str = "postedAt_in";
        }
        impl ::cynic::schema::HasInputField<postedAt_in, Option<Vec<super::super::DateTime>>>
            for super::super::JobWhereInput
        {
        }
        pub struct postedAt_not_in;
        impl ::cynic::schema::Field for postedAt_not_in {
            type Type = Option<Vec<super::super::DateTime>>;
            const NAME: &'static str = "postedAt_not_in";
        }
        impl ::cynic::schema::HasInputField<postedAt_not_in, Option<Vec<super::super::DateTime>>>
            for super::super::JobWhereInput
        {
        }
        pub struct postedAt_lt;
        impl ::cynic::schema::Field for postedAt_lt {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "postedAt_lt";
        }
        impl ::cynic::schema::HasInputField<postedAt_lt, Option<super::super::DateTime>>
            for super::super::JobWhereInput
        {
        }
        pub struct postedAt_lte;
        impl ::cynic::schema::Field for postedAt_lte {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "postedAt_lte";
        }
        impl ::cynic::schema::HasInputField<postedAt_lte, Option<super::super::DateTime>>
            for super::super::JobWhereInput
        {
        }
        pub struct postedAt_gt;
        impl ::cynic::schema::Field for postedAt_gt {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "postedAt_gt";
        }
        impl ::cynic::schema::HasInputField<postedAt_gt, Option<super::super::DateTime>>
            for super::super::JobWhereInput
        {
        }
        pub struct postedAt_gte;
        impl ::cynic::schema::Field for postedAt_gte {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "postedAt_gte";
        }
        impl ::cynic::schema::HasInputField<postedAt_gte, Option<super::super::DateTime>>
            for super::super::JobWhereInput
        {
        }
        pub struct createdAt;
        impl ::cynic::schema::Field for createdAt {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt";
        }
        impl ::cynic::schema::HasInputField<createdAt, Option<super::super::DateTime>>
            for super::super::JobWhereInput
        {
        }
        pub struct createdAt_not;
        impl ::cynic::schema::Field for createdAt_not {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt_not";
        }
        impl ::cynic::schema::HasInputField<createdAt_not, Option<super::super::DateTime>>
            for super::super::JobWhereInput
        {
        }
        pub struct createdAt_in;
        impl ::cynic::schema::Field for createdAt_in {
            type Type = Option<Vec<super::super::DateTime>>;
            const NAME: &'static str = "createdAt_in";
        }
        impl ::cynic::schema::HasInputField<createdAt_in, Option<Vec<super::super::DateTime>>>
            for super::super::JobWhereInput
        {
        }
        pub struct createdAt_not_in;
        impl ::cynic::schema::Field for createdAt_not_in {
            type Type = Option<Vec<super::super::DateTime>>;
            const NAME: &'static str = "createdAt_not_in";
        }
        impl ::cynic::schema::HasInputField<createdAt_not_in, Option<Vec<super::super::DateTime>>>
            for super::super::JobWhereInput
        {
        }
        pub struct createdAt_lt;
        impl ::cynic::schema::Field for createdAt_lt {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt_lt";
        }
        impl ::cynic::schema::HasInputField<createdAt_lt, Option<super::super::DateTime>>
            for super::super::JobWhereInput
        {
        }
        pub struct createdAt_lte;
        impl ::cynic::schema::Field for createdAt_lte {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt_lte";
        }
        impl ::cynic::schema::HasInputField<createdAt_lte, Option<super::super::DateTime>>
            for super::super::JobWhereInput
        {
        }
        pub struct createdAt_gt;
        impl ::cynic::schema::Field for createdAt_gt {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt_gt";
        }
        impl ::cynic::schema::HasInputField<createdAt_gt, Option<super::super::DateTime>>
            for super::super::JobWhereInput
        {
        }
        pub struct createdAt_gte;
        impl ::cynic::schema::Field for createdAt_gte {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt_gte";
        }
        impl ::cynic::schema::HasInputField<createdAt_gte, Option<super::super::DateTime>>
            for super::super::JobWhereInput
        {
        }
        pub struct updatedAt;
        impl ::cynic::schema::Field for updatedAt {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt";
        }
        impl ::cynic::schema::HasInputField<updatedAt, Option<super::super::DateTime>>
            for super::super::JobWhereInput
        {
        }
        pub struct updatedAt_not;
        impl ::cynic::schema::Field for updatedAt_not {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt_not";
        }
        impl ::cynic::schema::HasInputField<updatedAt_not, Option<super::super::DateTime>>
            for super::super::JobWhereInput
        {
        }
        pub struct updatedAt_in;
        impl ::cynic::schema::Field for updatedAt_in {
            type Type = Option<Vec<super::super::DateTime>>;
            const NAME: &'static str = "updatedAt_in";
        }
        impl ::cynic::schema::HasInputField<updatedAt_in, Option<Vec<super::super::DateTime>>>
            for super::super::JobWhereInput
        {
        }
        pub struct updatedAt_not_in;
        impl ::cynic::schema::Field for updatedAt_not_in {
            type Type = Option<Vec<super::super::DateTime>>;
            const NAME: &'static str = "updatedAt_not_in";
        }
        impl ::cynic::schema::HasInputField<updatedAt_not_in, Option<Vec<super::super::DateTime>>>
            for super::super::JobWhereInput
        {
        }
        pub struct updatedAt_lt;
        impl ::cynic::schema::Field for updatedAt_lt {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt_lt";
        }
        impl ::cynic::schema::HasInputField<updatedAt_lt, Option<super::super::DateTime>>
            for super::super::JobWhereInput
        {
        }
        pub struct updatedAt_lte;
        impl ::cynic::schema::Field for updatedAt_lte {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt_lte";
        }
        impl ::cynic::schema::HasInputField<updatedAt_lte, Option<super::super::DateTime>>
            for super::super::JobWhereInput
        {
        }
        pub struct updatedAt_gt;
        impl ::cynic::schema::Field for updatedAt_gt {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt_gt";
        }
        impl ::cynic::schema::HasInputField<updatedAt_gt, Option<super::super::DateTime>>
            for super::super::JobWhereInput
        {
        }
        pub struct updatedAt_gte;
        impl ::cynic::schema::Field for updatedAt_gte {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt_gte";
        }
        impl ::cynic::schema::HasInputField<updatedAt_gte, Option<super::super::DateTime>>
            for super::super::JobWhereInput
        {
        }
        pub struct AND;
        impl ::cynic::schema::Field for AND {
            type Type = Option<Vec<super::super::JobWhereInput>>;
            const NAME: &'static str = "AND";
        }
        impl ::cynic::schema::HasInputField<AND, Option<Vec<super::super::JobWhereInput>>>
            for super::super::JobWhereInput
        {
        }
        pub struct OR;
        impl ::cynic::schema::Field for OR {
            type Type = Option<Vec<super::super::JobWhereInput>>;
            const NAME: &'static str = "OR";
        }
        impl ::cynic::schema::HasInputField<OR, Option<Vec<super::super::JobWhereInput>>>
            for super::super::JobWhereInput
        {
        }
        pub struct NOT;
        impl ::cynic::schema::Field for NOT {
            type Type = Option<Vec<super::super::JobWhereInput>>;
            const NAME: &'static str = "NOT";
        }
        impl ::cynic::schema::HasInputField<NOT, Option<Vec<super::super::JobWhereInput>>>
            for super::super::JobWhereInput
        {
        }
    }
    pub mod JobsInput {
        pub struct r#type;
        impl ::cynic::schema::Field for r#type {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type";
        }
        impl ::cynic::schema::HasInputField<r#type, Option<super::super::String>>
            for super::super::JobsInput
        {
        }
        pub struct slug;
        impl ::cynic::schema::Field for slug {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug";
        }
        impl ::cynic::schema::HasInputField<slug, Option<super::super::String>>
            for super::super::JobsInput
        {
        }
    }
    pub mod Location {
        pub struct id;
        impl ::cynic::schema::Field for id {
            type Type = super::super::ID;
            const NAME: &'static str = "id";
        }
        impl ::cynic::schema::HasField<id> for super::super::Location {
            type Type = super::super::ID;
        }
        pub struct slug;
        impl ::cynic::schema::Field for slug {
            type Type = super::super::String;
            const NAME: &'static str = "slug";
        }
        impl ::cynic::schema::HasField<slug> for super::super::Location {
            type Type = super::super::String;
        }
        pub struct name;
        impl ::cynic::schema::Field for name {
            type Type = super::super::String;
            const NAME: &'static str = "name";
        }
        impl ::cynic::schema::HasField<name> for super::super::Location {
            type Type = super::super::String;
        }
        pub struct r#type;
        impl ::cynic::schema::Field for r#type {
            type Type = super::super::String;
            const NAME: &'static str = "type";
        }
        impl ::cynic::schema::HasField<r#type> for super::super::Location {
            type Type = super::super::String;
        }
        pub struct __typename;
        impl ::cynic::schema::Field for __typename {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
        impl ::cynic::schema::HasField<__typename> for super::super::Location {
            type Type = super::super::String;
        }
    }
    pub mod LocationInput {
        pub struct slug;
        impl ::cynic::schema::Field for slug {
            type Type = super::super::String;
            const NAME: &'static str = "slug";
        }
        impl ::cynic::schema::HasInputField<slug, super::super::String> for super::super::LocationInput {}
    }
    pub mod LocationsInput {
        pub struct value;
        impl ::cynic::schema::Field for value {
            type Type = super::super::String;
            const NAME: &'static str = "value";
        }
        impl ::cynic::schema::HasInputField<value, super::super::String> for super::super::LocationsInput {}
    }
    pub mod Mutation {
        pub struct subscribe;
        impl ::cynic::schema::Field for subscribe {
            type Type = super::super::User;
            const NAME: &'static str = "subscribe";
        }
        impl ::cynic::schema::HasField<subscribe> for super::super::Mutation {
            type Type = super::super::User;
        }
        pub mod _subscribe_arguments {
            pub struct input;
            impl ::cynic::schema::HasArgument<input> for super::subscribe {
                type ArgumentType = super::super::super::SubscribeInput;
                const NAME: &'static str = "input";
            }
        }
        pub struct postJob;
        impl ::cynic::schema::Field for postJob {
            type Type = super::super::Job;
            const NAME: &'static str = "postJob";
        }
        impl ::cynic::schema::HasField<postJob> for super::super::Mutation {
            type Type = super::super::Job;
        }
        pub mod _post_job_arguments {
            pub struct input;
            impl ::cynic::schema::HasArgument<input> for super::postJob {
                type ArgumentType = super::super::super::PostJobInput;
                const NAME: &'static str = "input";
            }
        }
        pub struct updateJob;
        impl ::cynic::schema::Field for updateJob {
            type Type = super::super::Job;
            const NAME: &'static str = "updateJob";
        }
        impl ::cynic::schema::HasField<updateJob> for super::super::Mutation {
            type Type = super::super::Job;
        }
        pub mod _update_job_arguments {
            pub struct input;
            impl ::cynic::schema::HasArgument<input> for super::updateJob {
                type ArgumentType = super::super::super::UpdateJobInput;
                const NAME: &'static str = "input";
            }
            pub struct adminSecret;
            impl ::cynic::schema::HasArgument<adminSecret> for super::updateJob {
                type ArgumentType = super::super::super::String;
                const NAME: &'static str = "adminSecret";
            }
        }
        pub struct updateCompany;
        impl ::cynic::schema::Field for updateCompany {
            type Type = super::super::Company;
            const NAME: &'static str = "updateCompany";
        }
        impl ::cynic::schema::HasField<updateCompany> for super::super::Mutation {
            type Type = super::super::Company;
        }
        pub mod _update_company_arguments {
            pub struct input;
            impl ::cynic::schema::HasArgument<input> for super::updateCompany {
                type ArgumentType = super::super::super::UpdateCompanyInput;
                const NAME: &'static str = "input";
            }
            pub struct adminSecret;
            impl ::cynic::schema::HasArgument<adminSecret> for super::updateCompany {
                type ArgumentType = super::super::super::String;
                const NAME: &'static str = "adminSecret";
            }
        }
        pub struct __typename;
        impl ::cynic::schema::Field for __typename {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
        impl ::cynic::schema::HasField<__typename> for super::super::Mutation {
            type Type = super::super::String;
        }
    }
    pub mod PostJobInput {
        pub struct title;
        impl ::cynic::schema::Field for title {
            type Type = super::super::String;
            const NAME: &'static str = "title";
        }
        impl ::cynic::schema::HasInputField<title, super::super::String> for super::super::PostJobInput {}
        pub struct commitmentId;
        impl ::cynic::schema::Field for commitmentId {
            type Type = super::super::ID;
            const NAME: &'static str = "commitmentId";
        }
        impl ::cynic::schema::HasInputField<commitmentId, super::super::ID> for super::super::PostJobInput {}
        pub struct companyName;
        impl ::cynic::schema::Field for companyName {
            type Type = super::super::String;
            const NAME: &'static str = "companyName";
        }
        impl ::cynic::schema::HasInputField<companyName, super::super::String>
            for super::super::PostJobInput
        {
        }
        pub struct locationNames;
        impl ::cynic::schema::Field for locationNames {
            type Type = super::super::String;
            const NAME: &'static str = "locationNames";
        }
        impl ::cynic::schema::HasInputField<locationNames, super::super::String>
            for super::super::PostJobInput
        {
        }
        pub struct userEmail;
        impl ::cynic::schema::Field for userEmail {
            type Type = super::super::String;
            const NAME: &'static str = "userEmail";
        }
        impl ::cynic::schema::HasInputField<userEmail, super::super::String>
            for super::super::PostJobInput
        {
        }
        pub struct description;
        impl ::cynic::schema::Field for description {
            type Type = super::super::String;
            const NAME: &'static str = "description";
        }
        impl ::cynic::schema::HasInputField<description, super::super::String>
            for super::super::PostJobInput
        {
        }
        pub struct applyUrl;
        impl ::cynic::schema::Field for applyUrl {
            type Type = super::super::String;
            const NAME: &'static str = "applyUrl";
        }
        impl ::cynic::schema::HasInputField<applyUrl, super::super::String> for super::super::PostJobInput {}
    }
    pub mod Query {
        pub struct jobs;
        impl ::cynic::schema::Field for jobs {
            type Type = Vec<super::super::Job>;
            const NAME: &'static str = "jobs";
        }
        impl ::cynic::schema::HasField<jobs> for super::super::Query {
            type Type = Vec<super::super::Job>;
        }
        pub mod _jobs_arguments {
            pub struct input;
            impl ::cynic::schema::HasArgument<input> for super::jobs {
                type ArgumentType = Option<super::super::super::JobsInput>;
                const NAME: &'static str = "input";
            }
        }
        pub struct job;
        impl ::cynic::schema::Field for job {
            type Type = super::super::Job;
            const NAME: &'static str = "job";
        }
        impl ::cynic::schema::HasField<job> for super::super::Query {
            type Type = super::super::Job;
        }
        pub mod _job_arguments {
            pub struct input;
            impl ::cynic::schema::HasArgument<input> for super::job {
                type ArgumentType = super::super::super::JobInput;
                const NAME: &'static str = "input";
            }
        }
        pub struct locations;
        impl ::cynic::schema::Field for locations {
            type Type = Vec<super::super::Location>;
            const NAME: &'static str = "locations";
        }
        impl ::cynic::schema::HasField<locations> for super::super::Query {
            type Type = Vec<super::super::Location>;
        }
        pub mod _locations_arguments {
            pub struct input;
            impl ::cynic::schema::HasArgument<input> for super::locations {
                type ArgumentType = super::super::super::LocationsInput;
                const NAME: &'static str = "input";
            }
        }
        pub struct city;
        impl ::cynic::schema::Field for city {
            type Type = super::super::City;
            const NAME: &'static str = "city";
        }
        impl ::cynic::schema::HasField<city> for super::super::Query {
            type Type = super::super::City;
        }
        pub mod _city_arguments {
            pub struct input;
            impl ::cynic::schema::HasArgument<input> for super::city {
                type ArgumentType = super::super::super::LocationInput;
                const NAME: &'static str = "input";
            }
        }
        pub struct country;
        impl ::cynic::schema::Field for country {
            type Type = super::super::Country;
            const NAME: &'static str = "country";
        }
        impl ::cynic::schema::HasField<country> for super::super::Query {
            type Type = super::super::Country;
        }
        pub mod _country_arguments {
            pub struct input;
            impl ::cynic::schema::HasArgument<input> for super::country {
                type ArgumentType = super::super::super::LocationInput;
                const NAME: &'static str = "input";
            }
        }
        pub struct remote;
        impl ::cynic::schema::Field for remote {
            type Type = super::super::Remote;
            const NAME: &'static str = "remote";
        }
        impl ::cynic::schema::HasField<remote> for super::super::Query {
            type Type = super::super::Remote;
        }
        pub mod _remote_arguments {
            pub struct input;
            impl ::cynic::schema::HasArgument<input> for super::remote {
                type ArgumentType = super::super::super::LocationInput;
                const NAME: &'static str = "input";
            }
        }
        pub struct commitments;
        impl ::cynic::schema::Field for commitments {
            type Type = Vec<super::super::Commitment>;
            const NAME: &'static str = "commitments";
        }
        impl ::cynic::schema::HasField<commitments> for super::super::Query {
            type Type = Vec<super::super::Commitment>;
        }
        pub struct cities;
        impl ::cynic::schema::Field for cities {
            type Type = Vec<super::super::City>;
            const NAME: &'static str = "cities";
        }
        impl ::cynic::schema::HasField<cities> for super::super::Query {
            type Type = Vec<super::super::City>;
        }
        pub struct countries;
        impl ::cynic::schema::Field for countries {
            type Type = Vec<super::super::Country>;
            const NAME: &'static str = "countries";
        }
        impl ::cynic::schema::HasField<countries> for super::super::Query {
            type Type = Vec<super::super::Country>;
        }
        pub struct remotes;
        impl ::cynic::schema::Field for remotes {
            type Type = Vec<super::super::Remote>;
            const NAME: &'static str = "remotes";
        }
        impl ::cynic::schema::HasField<remotes> for super::super::Query {
            type Type = Vec<super::super::Remote>;
        }
        pub struct companies;
        impl ::cynic::schema::Field for companies {
            type Type = Vec<super::super::Company>;
            const NAME: &'static str = "companies";
        }
        impl ::cynic::schema::HasField<companies> for super::super::Query {
            type Type = Vec<super::super::Company>;
        }
        pub struct __typename;
        impl ::cynic::schema::Field for __typename {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
        impl ::cynic::schema::HasField<__typename> for super::super::Query {
            type Type = super::super::String;
        }
    }
    pub mod Remote {
        pub struct id;
        impl ::cynic::schema::Field for id {
            type Type = super::super::ID;
            const NAME: &'static str = "id";
        }
        impl ::cynic::schema::HasField<id> for super::super::Remote {
            type Type = super::super::ID;
        }
        pub struct name;
        impl ::cynic::schema::Field for name {
            type Type = super::super::String;
            const NAME: &'static str = "name";
        }
        impl ::cynic::schema::HasField<name> for super::super::Remote {
            type Type = super::super::String;
        }
        pub struct slug;
        impl ::cynic::schema::Field for slug {
            type Type = super::super::String;
            const NAME: &'static str = "slug";
        }
        impl ::cynic::schema::HasField<slug> for super::super::Remote {
            type Type = super::super::String;
        }
        pub struct r#type;
        impl ::cynic::schema::Field for r#type {
            type Type = super::super::String;
            const NAME: &'static str = "type";
        }
        impl ::cynic::schema::HasField<r#type> for super::super::Remote {
            type Type = super::super::String;
        }
        pub struct jobs;
        impl ::cynic::schema::Field for jobs {
            type Type = Option<Vec<super::super::Job>>;
            const NAME: &'static str = "jobs";
        }
        impl ::cynic::schema::HasField<jobs> for super::super::Remote {
            type Type = Option<Vec<super::super::Job>>;
        }
        pub mod _jobs_arguments {
            pub struct r#where;
            impl ::cynic::schema::HasArgument<r#where> for super::jobs {
                type ArgumentType = Option<super::super::super::JobWhereInput>;
                const NAME: &'static str = "where";
            }
            pub struct orderBy;
            impl ::cynic::schema::HasArgument<orderBy> for super::jobs {
                type ArgumentType = Option<super::super::super::JobOrderByInput>;
                const NAME: &'static str = "orderBy";
            }
            pub struct skip;
            impl ::cynic::schema::HasArgument<skip> for super::jobs {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "skip";
            }
            pub struct after;
            impl ::cynic::schema::HasArgument<after> for super::jobs {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "after";
            }
            pub struct before;
            impl ::cynic::schema::HasArgument<before> for super::jobs {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "before";
            }
            pub struct first;
            impl ::cynic::schema::HasArgument<first> for super::jobs {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "first";
            }
            pub struct last;
            impl ::cynic::schema::HasArgument<last> for super::jobs {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "last";
            }
        }
        pub struct createdAt;
        impl ::cynic::schema::Field for createdAt {
            type Type = super::super::DateTime;
            const NAME: &'static str = "createdAt";
        }
        impl ::cynic::schema::HasField<createdAt> for super::super::Remote {
            type Type = super::super::DateTime;
        }
        pub struct updatedAt;
        impl ::cynic::schema::Field for updatedAt {
            type Type = super::super::DateTime;
            const NAME: &'static str = "updatedAt";
        }
        impl ::cynic::schema::HasField<updatedAt> for super::super::Remote {
            type Type = super::super::DateTime;
        }
        pub struct __typename;
        impl ::cynic::schema::Field for __typename {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
        impl ::cynic::schema::HasField<__typename> for super::super::Remote {
            type Type = super::super::String;
        }
    }
    pub mod RemoteWhereInput {
        pub struct id;
        impl ::cynic::schema::Field for id {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id";
        }
        impl ::cynic::schema::HasInputField<id, Option<super::super::ID>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct id_not;
        impl ::cynic::schema::Field for id_not {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_not";
        }
        impl ::cynic::schema::HasInputField<id_not, Option<super::super::ID>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct id_in;
        impl ::cynic::schema::Field for id_in {
            type Type = Option<Vec<super::super::ID>>;
            const NAME: &'static str = "id_in";
        }
        impl ::cynic::schema::HasInputField<id_in, Option<Vec<super::super::ID>>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct id_not_in;
        impl ::cynic::schema::Field for id_not_in {
            type Type = Option<Vec<super::super::ID>>;
            const NAME: &'static str = "id_not_in";
        }
        impl ::cynic::schema::HasInputField<id_not_in, Option<Vec<super::super::ID>>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct id_lt;
        impl ::cynic::schema::Field for id_lt {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_lt";
        }
        impl ::cynic::schema::HasInputField<id_lt, Option<super::super::ID>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct id_lte;
        impl ::cynic::schema::Field for id_lte {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_lte";
        }
        impl ::cynic::schema::HasInputField<id_lte, Option<super::super::ID>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct id_gt;
        impl ::cynic::schema::Field for id_gt {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_gt";
        }
        impl ::cynic::schema::HasInputField<id_gt, Option<super::super::ID>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct id_gte;
        impl ::cynic::schema::Field for id_gte {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_gte";
        }
        impl ::cynic::schema::HasInputField<id_gte, Option<super::super::ID>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct id_contains;
        impl ::cynic::schema::Field for id_contains {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_contains";
        }
        impl ::cynic::schema::HasInputField<id_contains, Option<super::super::ID>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct id_not_contains;
        impl ::cynic::schema::Field for id_not_contains {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_not_contains";
        }
        impl ::cynic::schema::HasInputField<id_not_contains, Option<super::super::ID>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct id_starts_with;
        impl ::cynic::schema::Field for id_starts_with {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_starts_with";
        }
        impl ::cynic::schema::HasInputField<id_starts_with, Option<super::super::ID>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct id_not_starts_with;
        impl ::cynic::schema::Field for id_not_starts_with {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_not_starts_with";
        }
        impl ::cynic::schema::HasInputField<id_not_starts_with, Option<super::super::ID>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct id_ends_with;
        impl ::cynic::schema::Field for id_ends_with {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_ends_with";
        }
        impl ::cynic::schema::HasInputField<id_ends_with, Option<super::super::ID>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct id_not_ends_with;
        impl ::cynic::schema::Field for id_not_ends_with {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_not_ends_with";
        }
        impl ::cynic::schema::HasInputField<id_not_ends_with, Option<super::super::ID>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct name;
        impl ::cynic::schema::Field for name {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name";
        }
        impl ::cynic::schema::HasInputField<name, Option<super::super::String>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct name_not;
        impl ::cynic::schema::Field for name_not {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_not";
        }
        impl ::cynic::schema::HasInputField<name_not, Option<super::super::String>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct name_in;
        impl ::cynic::schema::Field for name_in {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "name_in";
        }
        impl ::cynic::schema::HasInputField<name_in, Option<Vec<super::super::String>>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct name_not_in;
        impl ::cynic::schema::Field for name_not_in {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "name_not_in";
        }
        impl ::cynic::schema::HasInputField<name_not_in, Option<Vec<super::super::String>>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct name_lt;
        impl ::cynic::schema::Field for name_lt {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_lt";
        }
        impl ::cynic::schema::HasInputField<name_lt, Option<super::super::String>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct name_lte;
        impl ::cynic::schema::Field for name_lte {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_lte";
        }
        impl ::cynic::schema::HasInputField<name_lte, Option<super::super::String>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct name_gt;
        impl ::cynic::schema::Field for name_gt {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_gt";
        }
        impl ::cynic::schema::HasInputField<name_gt, Option<super::super::String>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct name_gte;
        impl ::cynic::schema::Field for name_gte {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_gte";
        }
        impl ::cynic::schema::HasInputField<name_gte, Option<super::super::String>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct name_contains;
        impl ::cynic::schema::Field for name_contains {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_contains";
        }
        impl ::cynic::schema::HasInputField<name_contains, Option<super::super::String>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct name_not_contains;
        impl ::cynic::schema::Field for name_not_contains {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_not_contains";
        }
        impl ::cynic::schema::HasInputField<name_not_contains, Option<super::super::String>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct name_starts_with;
        impl ::cynic::schema::Field for name_starts_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_starts_with";
        }
        impl ::cynic::schema::HasInputField<name_starts_with, Option<super::super::String>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct name_not_starts_with;
        impl ::cynic::schema::Field for name_not_starts_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_not_starts_with";
        }
        impl ::cynic::schema::HasInputField<name_not_starts_with, Option<super::super::String>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct name_ends_with;
        impl ::cynic::schema::Field for name_ends_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_ends_with";
        }
        impl ::cynic::schema::HasInputField<name_ends_with, Option<super::super::String>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct name_not_ends_with;
        impl ::cynic::schema::Field for name_not_ends_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_not_ends_with";
        }
        impl ::cynic::schema::HasInputField<name_not_ends_with, Option<super::super::String>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct slug;
        impl ::cynic::schema::Field for slug {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug";
        }
        impl ::cynic::schema::HasInputField<slug, Option<super::super::String>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct slug_not;
        impl ::cynic::schema::Field for slug_not {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_not";
        }
        impl ::cynic::schema::HasInputField<slug_not, Option<super::super::String>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct slug_in;
        impl ::cynic::schema::Field for slug_in {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "slug_in";
        }
        impl ::cynic::schema::HasInputField<slug_in, Option<Vec<super::super::String>>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct slug_not_in;
        impl ::cynic::schema::Field for slug_not_in {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "slug_not_in";
        }
        impl ::cynic::schema::HasInputField<slug_not_in, Option<Vec<super::super::String>>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct slug_lt;
        impl ::cynic::schema::Field for slug_lt {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_lt";
        }
        impl ::cynic::schema::HasInputField<slug_lt, Option<super::super::String>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct slug_lte;
        impl ::cynic::schema::Field for slug_lte {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_lte";
        }
        impl ::cynic::schema::HasInputField<slug_lte, Option<super::super::String>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct slug_gt;
        impl ::cynic::schema::Field for slug_gt {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_gt";
        }
        impl ::cynic::schema::HasInputField<slug_gt, Option<super::super::String>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct slug_gte;
        impl ::cynic::schema::Field for slug_gte {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_gte";
        }
        impl ::cynic::schema::HasInputField<slug_gte, Option<super::super::String>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct slug_contains;
        impl ::cynic::schema::Field for slug_contains {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_contains";
        }
        impl ::cynic::schema::HasInputField<slug_contains, Option<super::super::String>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct slug_not_contains;
        impl ::cynic::schema::Field for slug_not_contains {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_not_contains";
        }
        impl ::cynic::schema::HasInputField<slug_not_contains, Option<super::super::String>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct slug_starts_with;
        impl ::cynic::schema::Field for slug_starts_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_starts_with";
        }
        impl ::cynic::schema::HasInputField<slug_starts_with, Option<super::super::String>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct slug_not_starts_with;
        impl ::cynic::schema::Field for slug_not_starts_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_not_starts_with";
        }
        impl ::cynic::schema::HasInputField<slug_not_starts_with, Option<super::super::String>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct slug_ends_with;
        impl ::cynic::schema::Field for slug_ends_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_ends_with";
        }
        impl ::cynic::schema::HasInputField<slug_ends_with, Option<super::super::String>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct slug_not_ends_with;
        impl ::cynic::schema::Field for slug_not_ends_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_not_ends_with";
        }
        impl ::cynic::schema::HasInputField<slug_not_ends_with, Option<super::super::String>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct r#type;
        impl ::cynic::schema::Field for r#type {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type";
        }
        impl ::cynic::schema::HasInputField<r#type, Option<super::super::String>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct type_not;
        impl ::cynic::schema::Field for type_not {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type_not";
        }
        impl ::cynic::schema::HasInputField<type_not, Option<super::super::String>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct type_in;
        impl ::cynic::schema::Field for type_in {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "type_in";
        }
        impl ::cynic::schema::HasInputField<type_in, Option<Vec<super::super::String>>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct type_not_in;
        impl ::cynic::schema::Field for type_not_in {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "type_not_in";
        }
        impl ::cynic::schema::HasInputField<type_not_in, Option<Vec<super::super::String>>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct type_lt;
        impl ::cynic::schema::Field for type_lt {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type_lt";
        }
        impl ::cynic::schema::HasInputField<type_lt, Option<super::super::String>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct type_lte;
        impl ::cynic::schema::Field for type_lte {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type_lte";
        }
        impl ::cynic::schema::HasInputField<type_lte, Option<super::super::String>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct type_gt;
        impl ::cynic::schema::Field for type_gt {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type_gt";
        }
        impl ::cynic::schema::HasInputField<type_gt, Option<super::super::String>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct type_gte;
        impl ::cynic::schema::Field for type_gte {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type_gte";
        }
        impl ::cynic::schema::HasInputField<type_gte, Option<super::super::String>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct type_contains;
        impl ::cynic::schema::Field for type_contains {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type_contains";
        }
        impl ::cynic::schema::HasInputField<type_contains, Option<super::super::String>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct type_not_contains;
        impl ::cynic::schema::Field for type_not_contains {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type_not_contains";
        }
        impl ::cynic::schema::HasInputField<type_not_contains, Option<super::super::String>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct type_starts_with;
        impl ::cynic::schema::Field for type_starts_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type_starts_with";
        }
        impl ::cynic::schema::HasInputField<type_starts_with, Option<super::super::String>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct type_not_starts_with;
        impl ::cynic::schema::Field for type_not_starts_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type_not_starts_with";
        }
        impl ::cynic::schema::HasInputField<type_not_starts_with, Option<super::super::String>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct type_ends_with;
        impl ::cynic::schema::Field for type_ends_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type_ends_with";
        }
        impl ::cynic::schema::HasInputField<type_ends_with, Option<super::super::String>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct type_not_ends_with;
        impl ::cynic::schema::Field for type_not_ends_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type_not_ends_with";
        }
        impl ::cynic::schema::HasInputField<type_not_ends_with, Option<super::super::String>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct jobs_every;
        impl ::cynic::schema::Field for jobs_every {
            type Type = Option<super::super::JobWhereInput>;
            const NAME: &'static str = "jobs_every";
        }
        impl ::cynic::schema::HasInputField<jobs_every, Option<super::super::JobWhereInput>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct jobs_some;
        impl ::cynic::schema::Field for jobs_some {
            type Type = Option<super::super::JobWhereInput>;
            const NAME: &'static str = "jobs_some";
        }
        impl ::cynic::schema::HasInputField<jobs_some, Option<super::super::JobWhereInput>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct jobs_none;
        impl ::cynic::schema::Field for jobs_none {
            type Type = Option<super::super::JobWhereInput>;
            const NAME: &'static str = "jobs_none";
        }
        impl ::cynic::schema::HasInputField<jobs_none, Option<super::super::JobWhereInput>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct createdAt;
        impl ::cynic::schema::Field for createdAt {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt";
        }
        impl ::cynic::schema::HasInputField<createdAt, Option<super::super::DateTime>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct createdAt_not;
        impl ::cynic::schema::Field for createdAt_not {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt_not";
        }
        impl ::cynic::schema::HasInputField<createdAt_not, Option<super::super::DateTime>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct createdAt_in;
        impl ::cynic::schema::Field for createdAt_in {
            type Type = Option<Vec<super::super::DateTime>>;
            const NAME: &'static str = "createdAt_in";
        }
        impl ::cynic::schema::HasInputField<createdAt_in, Option<Vec<super::super::DateTime>>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct createdAt_not_in;
        impl ::cynic::schema::Field for createdAt_not_in {
            type Type = Option<Vec<super::super::DateTime>>;
            const NAME: &'static str = "createdAt_not_in";
        }
        impl ::cynic::schema::HasInputField<createdAt_not_in, Option<Vec<super::super::DateTime>>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct createdAt_lt;
        impl ::cynic::schema::Field for createdAt_lt {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt_lt";
        }
        impl ::cynic::schema::HasInputField<createdAt_lt, Option<super::super::DateTime>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct createdAt_lte;
        impl ::cynic::schema::Field for createdAt_lte {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt_lte";
        }
        impl ::cynic::schema::HasInputField<createdAt_lte, Option<super::super::DateTime>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct createdAt_gt;
        impl ::cynic::schema::Field for createdAt_gt {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt_gt";
        }
        impl ::cynic::schema::HasInputField<createdAt_gt, Option<super::super::DateTime>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct createdAt_gte;
        impl ::cynic::schema::Field for createdAt_gte {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt_gte";
        }
        impl ::cynic::schema::HasInputField<createdAt_gte, Option<super::super::DateTime>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct updatedAt;
        impl ::cynic::schema::Field for updatedAt {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt";
        }
        impl ::cynic::schema::HasInputField<updatedAt, Option<super::super::DateTime>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct updatedAt_not;
        impl ::cynic::schema::Field for updatedAt_not {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt_not";
        }
        impl ::cynic::schema::HasInputField<updatedAt_not, Option<super::super::DateTime>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct updatedAt_in;
        impl ::cynic::schema::Field for updatedAt_in {
            type Type = Option<Vec<super::super::DateTime>>;
            const NAME: &'static str = "updatedAt_in";
        }
        impl ::cynic::schema::HasInputField<updatedAt_in, Option<Vec<super::super::DateTime>>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct updatedAt_not_in;
        impl ::cynic::schema::Field for updatedAt_not_in {
            type Type = Option<Vec<super::super::DateTime>>;
            const NAME: &'static str = "updatedAt_not_in";
        }
        impl ::cynic::schema::HasInputField<updatedAt_not_in, Option<Vec<super::super::DateTime>>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct updatedAt_lt;
        impl ::cynic::schema::Field for updatedAt_lt {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt_lt";
        }
        impl ::cynic::schema::HasInputField<updatedAt_lt, Option<super::super::DateTime>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct updatedAt_lte;
        impl ::cynic::schema::Field for updatedAt_lte {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt_lte";
        }
        impl ::cynic::schema::HasInputField<updatedAt_lte, Option<super::super::DateTime>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct updatedAt_gt;
        impl ::cynic::schema::Field for updatedAt_gt {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt_gt";
        }
        impl ::cynic::schema::HasInputField<updatedAt_gt, Option<super::super::DateTime>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct updatedAt_gte;
        impl ::cynic::schema::Field for updatedAt_gte {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt_gte";
        }
        impl ::cynic::schema::HasInputField<updatedAt_gte, Option<super::super::DateTime>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct AND;
        impl ::cynic::schema::Field for AND {
            type Type = Option<Vec<super::super::RemoteWhereInput>>;
            const NAME: &'static str = "AND";
        }
        impl ::cynic::schema::HasInputField<AND, Option<Vec<super::super::RemoteWhereInput>>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct OR;
        impl ::cynic::schema::Field for OR {
            type Type = Option<Vec<super::super::RemoteWhereInput>>;
            const NAME: &'static str = "OR";
        }
        impl ::cynic::schema::HasInputField<OR, Option<Vec<super::super::RemoteWhereInput>>>
            for super::super::RemoteWhereInput
        {
        }
        pub struct NOT;
        impl ::cynic::schema::Field for NOT {
            type Type = Option<Vec<super::super::RemoteWhereInput>>;
            const NAME: &'static str = "NOT";
        }
        impl ::cynic::schema::HasInputField<NOT, Option<Vec<super::super::RemoteWhereInput>>>
            for super::super::RemoteWhereInput
        {
        }
    }
    pub mod SubscribeInput {
        pub struct name;
        impl ::cynic::schema::Field for name {
            type Type = super::super::String;
            const NAME: &'static str = "name";
        }
        impl ::cynic::schema::HasInputField<name, super::super::String> for super::super::SubscribeInput {}
        pub struct email;
        impl ::cynic::schema::Field for email {
            type Type = super::super::String;
            const NAME: &'static str = "email";
        }
        impl ::cynic::schema::HasInputField<email, super::super::String> for super::super::SubscribeInput {}
    }
    pub mod Tag {
        pub struct id;
        impl ::cynic::schema::Field for id {
            type Type = super::super::ID;
            const NAME: &'static str = "id";
        }
        impl ::cynic::schema::HasField<id> for super::super::Tag {
            type Type = super::super::ID;
        }
        pub struct name;
        impl ::cynic::schema::Field for name {
            type Type = super::super::String;
            const NAME: &'static str = "name";
        }
        impl ::cynic::schema::HasField<name> for super::super::Tag {
            type Type = super::super::String;
        }
        pub struct slug;
        impl ::cynic::schema::Field for slug {
            type Type = super::super::String;
            const NAME: &'static str = "slug";
        }
        impl ::cynic::schema::HasField<slug> for super::super::Tag {
            type Type = super::super::String;
        }
        pub struct jobs;
        impl ::cynic::schema::Field for jobs {
            type Type = Option<Vec<super::super::Job>>;
            const NAME: &'static str = "jobs";
        }
        impl ::cynic::schema::HasField<jobs> for super::super::Tag {
            type Type = Option<Vec<super::super::Job>>;
        }
        pub mod _jobs_arguments {
            pub struct r#where;
            impl ::cynic::schema::HasArgument<r#where> for super::jobs {
                type ArgumentType = Option<super::super::super::JobWhereInput>;
                const NAME: &'static str = "where";
            }
            pub struct orderBy;
            impl ::cynic::schema::HasArgument<orderBy> for super::jobs {
                type ArgumentType = Option<super::super::super::JobOrderByInput>;
                const NAME: &'static str = "orderBy";
            }
            pub struct skip;
            impl ::cynic::schema::HasArgument<skip> for super::jobs {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "skip";
            }
            pub struct after;
            impl ::cynic::schema::HasArgument<after> for super::jobs {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "after";
            }
            pub struct before;
            impl ::cynic::schema::HasArgument<before> for super::jobs {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "before";
            }
            pub struct first;
            impl ::cynic::schema::HasArgument<first> for super::jobs {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "first";
            }
            pub struct last;
            impl ::cynic::schema::HasArgument<last> for super::jobs {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "last";
            }
        }
        pub struct createdAt;
        impl ::cynic::schema::Field for createdAt {
            type Type = super::super::DateTime;
            const NAME: &'static str = "createdAt";
        }
        impl ::cynic::schema::HasField<createdAt> for super::super::Tag {
            type Type = super::super::DateTime;
        }
        pub struct updatedAt;
        impl ::cynic::schema::Field for updatedAt {
            type Type = super::super::DateTime;
            const NAME: &'static str = "updatedAt";
        }
        impl ::cynic::schema::HasField<updatedAt> for super::super::Tag {
            type Type = super::super::DateTime;
        }
        pub struct __typename;
        impl ::cynic::schema::Field for __typename {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
        impl ::cynic::schema::HasField<__typename> for super::super::Tag {
            type Type = super::super::String;
        }
    }
    pub mod TagWhereInput {
        pub struct id;
        impl ::cynic::schema::Field for id {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id";
        }
        impl ::cynic::schema::HasInputField<id, Option<super::super::ID>> for super::super::TagWhereInput {}
        pub struct id_not;
        impl ::cynic::schema::Field for id_not {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_not";
        }
        impl ::cynic::schema::HasInputField<id_not, Option<super::super::ID>>
            for super::super::TagWhereInput
        {
        }
        pub struct id_in;
        impl ::cynic::schema::Field for id_in {
            type Type = Option<Vec<super::super::ID>>;
            const NAME: &'static str = "id_in";
        }
        impl ::cynic::schema::HasInputField<id_in, Option<Vec<super::super::ID>>>
            for super::super::TagWhereInput
        {
        }
        pub struct id_not_in;
        impl ::cynic::schema::Field for id_not_in {
            type Type = Option<Vec<super::super::ID>>;
            const NAME: &'static str = "id_not_in";
        }
        impl ::cynic::schema::HasInputField<id_not_in, Option<Vec<super::super::ID>>>
            for super::super::TagWhereInput
        {
        }
        pub struct id_lt;
        impl ::cynic::schema::Field for id_lt {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_lt";
        }
        impl ::cynic::schema::HasInputField<id_lt, Option<super::super::ID>>
            for super::super::TagWhereInput
        {
        }
        pub struct id_lte;
        impl ::cynic::schema::Field for id_lte {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_lte";
        }
        impl ::cynic::schema::HasInputField<id_lte, Option<super::super::ID>>
            for super::super::TagWhereInput
        {
        }
        pub struct id_gt;
        impl ::cynic::schema::Field for id_gt {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_gt";
        }
        impl ::cynic::schema::HasInputField<id_gt, Option<super::super::ID>>
            for super::super::TagWhereInput
        {
        }
        pub struct id_gte;
        impl ::cynic::schema::Field for id_gte {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_gte";
        }
        impl ::cynic::schema::HasInputField<id_gte, Option<super::super::ID>>
            for super::super::TagWhereInput
        {
        }
        pub struct id_contains;
        impl ::cynic::schema::Field for id_contains {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_contains";
        }
        impl ::cynic::schema::HasInputField<id_contains, Option<super::super::ID>>
            for super::super::TagWhereInput
        {
        }
        pub struct id_not_contains;
        impl ::cynic::schema::Field for id_not_contains {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_not_contains";
        }
        impl ::cynic::schema::HasInputField<id_not_contains, Option<super::super::ID>>
            for super::super::TagWhereInput
        {
        }
        pub struct id_starts_with;
        impl ::cynic::schema::Field for id_starts_with {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_starts_with";
        }
        impl ::cynic::schema::HasInputField<id_starts_with, Option<super::super::ID>>
            for super::super::TagWhereInput
        {
        }
        pub struct id_not_starts_with;
        impl ::cynic::schema::Field for id_not_starts_with {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_not_starts_with";
        }
        impl ::cynic::schema::HasInputField<id_not_starts_with, Option<super::super::ID>>
            for super::super::TagWhereInput
        {
        }
        pub struct id_ends_with;
        impl ::cynic::schema::Field for id_ends_with {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_ends_with";
        }
        impl ::cynic::schema::HasInputField<id_ends_with, Option<super::super::ID>>
            for super::super::TagWhereInput
        {
        }
        pub struct id_not_ends_with;
        impl ::cynic::schema::Field for id_not_ends_with {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_not_ends_with";
        }
        impl ::cynic::schema::HasInputField<id_not_ends_with, Option<super::super::ID>>
            for super::super::TagWhereInput
        {
        }
        pub struct name;
        impl ::cynic::schema::Field for name {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name";
        }
        impl ::cynic::schema::HasInputField<name, Option<super::super::String>>
            for super::super::TagWhereInput
        {
        }
        pub struct name_not;
        impl ::cynic::schema::Field for name_not {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_not";
        }
        impl ::cynic::schema::HasInputField<name_not, Option<super::super::String>>
            for super::super::TagWhereInput
        {
        }
        pub struct name_in;
        impl ::cynic::schema::Field for name_in {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "name_in";
        }
        impl ::cynic::schema::HasInputField<name_in, Option<Vec<super::super::String>>>
            for super::super::TagWhereInput
        {
        }
        pub struct name_not_in;
        impl ::cynic::schema::Field for name_not_in {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "name_not_in";
        }
        impl ::cynic::schema::HasInputField<name_not_in, Option<Vec<super::super::String>>>
            for super::super::TagWhereInput
        {
        }
        pub struct name_lt;
        impl ::cynic::schema::Field for name_lt {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_lt";
        }
        impl ::cynic::schema::HasInputField<name_lt, Option<super::super::String>>
            for super::super::TagWhereInput
        {
        }
        pub struct name_lte;
        impl ::cynic::schema::Field for name_lte {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_lte";
        }
        impl ::cynic::schema::HasInputField<name_lte, Option<super::super::String>>
            for super::super::TagWhereInput
        {
        }
        pub struct name_gt;
        impl ::cynic::schema::Field for name_gt {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_gt";
        }
        impl ::cynic::schema::HasInputField<name_gt, Option<super::super::String>>
            for super::super::TagWhereInput
        {
        }
        pub struct name_gte;
        impl ::cynic::schema::Field for name_gte {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_gte";
        }
        impl ::cynic::schema::HasInputField<name_gte, Option<super::super::String>>
            for super::super::TagWhereInput
        {
        }
        pub struct name_contains;
        impl ::cynic::schema::Field for name_contains {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_contains";
        }
        impl ::cynic::schema::HasInputField<name_contains, Option<super::super::String>>
            for super::super::TagWhereInput
        {
        }
        pub struct name_not_contains;
        impl ::cynic::schema::Field for name_not_contains {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_not_contains";
        }
        impl ::cynic::schema::HasInputField<name_not_contains, Option<super::super::String>>
            for super::super::TagWhereInput
        {
        }
        pub struct name_starts_with;
        impl ::cynic::schema::Field for name_starts_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_starts_with";
        }
        impl ::cynic::schema::HasInputField<name_starts_with, Option<super::super::String>>
            for super::super::TagWhereInput
        {
        }
        pub struct name_not_starts_with;
        impl ::cynic::schema::Field for name_not_starts_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_not_starts_with";
        }
        impl ::cynic::schema::HasInputField<name_not_starts_with, Option<super::super::String>>
            for super::super::TagWhereInput
        {
        }
        pub struct name_ends_with;
        impl ::cynic::schema::Field for name_ends_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_ends_with";
        }
        impl ::cynic::schema::HasInputField<name_ends_with, Option<super::super::String>>
            for super::super::TagWhereInput
        {
        }
        pub struct name_not_ends_with;
        impl ::cynic::schema::Field for name_not_ends_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_not_ends_with";
        }
        impl ::cynic::schema::HasInputField<name_not_ends_with, Option<super::super::String>>
            for super::super::TagWhereInput
        {
        }
        pub struct slug;
        impl ::cynic::schema::Field for slug {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug";
        }
        impl ::cynic::schema::HasInputField<slug, Option<super::super::String>>
            for super::super::TagWhereInput
        {
        }
        pub struct slug_not;
        impl ::cynic::schema::Field for slug_not {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_not";
        }
        impl ::cynic::schema::HasInputField<slug_not, Option<super::super::String>>
            for super::super::TagWhereInput
        {
        }
        pub struct slug_in;
        impl ::cynic::schema::Field for slug_in {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "slug_in";
        }
        impl ::cynic::schema::HasInputField<slug_in, Option<Vec<super::super::String>>>
            for super::super::TagWhereInput
        {
        }
        pub struct slug_not_in;
        impl ::cynic::schema::Field for slug_not_in {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "slug_not_in";
        }
        impl ::cynic::schema::HasInputField<slug_not_in, Option<Vec<super::super::String>>>
            for super::super::TagWhereInput
        {
        }
        pub struct slug_lt;
        impl ::cynic::schema::Field for slug_lt {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_lt";
        }
        impl ::cynic::schema::HasInputField<slug_lt, Option<super::super::String>>
            for super::super::TagWhereInput
        {
        }
        pub struct slug_lte;
        impl ::cynic::schema::Field for slug_lte {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_lte";
        }
        impl ::cynic::schema::HasInputField<slug_lte, Option<super::super::String>>
            for super::super::TagWhereInput
        {
        }
        pub struct slug_gt;
        impl ::cynic::schema::Field for slug_gt {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_gt";
        }
        impl ::cynic::schema::HasInputField<slug_gt, Option<super::super::String>>
            for super::super::TagWhereInput
        {
        }
        pub struct slug_gte;
        impl ::cynic::schema::Field for slug_gte {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_gte";
        }
        impl ::cynic::schema::HasInputField<slug_gte, Option<super::super::String>>
            for super::super::TagWhereInput
        {
        }
        pub struct slug_contains;
        impl ::cynic::schema::Field for slug_contains {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_contains";
        }
        impl ::cynic::schema::HasInputField<slug_contains, Option<super::super::String>>
            for super::super::TagWhereInput
        {
        }
        pub struct slug_not_contains;
        impl ::cynic::schema::Field for slug_not_contains {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_not_contains";
        }
        impl ::cynic::schema::HasInputField<slug_not_contains, Option<super::super::String>>
            for super::super::TagWhereInput
        {
        }
        pub struct slug_starts_with;
        impl ::cynic::schema::Field for slug_starts_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_starts_with";
        }
        impl ::cynic::schema::HasInputField<slug_starts_with, Option<super::super::String>>
            for super::super::TagWhereInput
        {
        }
        pub struct slug_not_starts_with;
        impl ::cynic::schema::Field for slug_not_starts_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_not_starts_with";
        }
        impl ::cynic::schema::HasInputField<slug_not_starts_with, Option<super::super::String>>
            for super::super::TagWhereInput
        {
        }
        pub struct slug_ends_with;
        impl ::cynic::schema::Field for slug_ends_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_ends_with";
        }
        impl ::cynic::schema::HasInputField<slug_ends_with, Option<super::super::String>>
            for super::super::TagWhereInput
        {
        }
        pub struct slug_not_ends_with;
        impl ::cynic::schema::Field for slug_not_ends_with {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_not_ends_with";
        }
        impl ::cynic::schema::HasInputField<slug_not_ends_with, Option<super::super::String>>
            for super::super::TagWhereInput
        {
        }
        pub struct jobs_every;
        impl ::cynic::schema::Field for jobs_every {
            type Type = Option<super::super::JobWhereInput>;
            const NAME: &'static str = "jobs_every";
        }
        impl ::cynic::schema::HasInputField<jobs_every, Option<super::super::JobWhereInput>>
            for super::super::TagWhereInput
        {
        }
        pub struct jobs_some;
        impl ::cynic::schema::Field for jobs_some {
            type Type = Option<super::super::JobWhereInput>;
            const NAME: &'static str = "jobs_some";
        }
        impl ::cynic::schema::HasInputField<jobs_some, Option<super::super::JobWhereInput>>
            for super::super::TagWhereInput
        {
        }
        pub struct jobs_none;
        impl ::cynic::schema::Field for jobs_none {
            type Type = Option<super::super::JobWhereInput>;
            const NAME: &'static str = "jobs_none";
        }
        impl ::cynic::schema::HasInputField<jobs_none, Option<super::super::JobWhereInput>>
            for super::super::TagWhereInput
        {
        }
        pub struct createdAt;
        impl ::cynic::schema::Field for createdAt {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt";
        }
        impl ::cynic::schema::HasInputField<createdAt, Option<super::super::DateTime>>
            for super::super::TagWhereInput
        {
        }
        pub struct createdAt_not;
        impl ::cynic::schema::Field for createdAt_not {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt_not";
        }
        impl ::cynic::schema::HasInputField<createdAt_not, Option<super::super::DateTime>>
            for super::super::TagWhereInput
        {
        }
        pub struct createdAt_in;
        impl ::cynic::schema::Field for createdAt_in {
            type Type = Option<Vec<super::super::DateTime>>;
            const NAME: &'static str = "createdAt_in";
        }
        impl ::cynic::schema::HasInputField<createdAt_in, Option<Vec<super::super::DateTime>>>
            for super::super::TagWhereInput
        {
        }
        pub struct createdAt_not_in;
        impl ::cynic::schema::Field for createdAt_not_in {
            type Type = Option<Vec<super::super::DateTime>>;
            const NAME: &'static str = "createdAt_not_in";
        }
        impl ::cynic::schema::HasInputField<createdAt_not_in, Option<Vec<super::super::DateTime>>>
            for super::super::TagWhereInput
        {
        }
        pub struct createdAt_lt;
        impl ::cynic::schema::Field for createdAt_lt {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt_lt";
        }
        impl ::cynic::schema::HasInputField<createdAt_lt, Option<super::super::DateTime>>
            for super::super::TagWhereInput
        {
        }
        pub struct createdAt_lte;
        impl ::cynic::schema::Field for createdAt_lte {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt_lte";
        }
        impl ::cynic::schema::HasInputField<createdAt_lte, Option<super::super::DateTime>>
            for super::super::TagWhereInput
        {
        }
        pub struct createdAt_gt;
        impl ::cynic::schema::Field for createdAt_gt {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt_gt";
        }
        impl ::cynic::schema::HasInputField<createdAt_gt, Option<super::super::DateTime>>
            for super::super::TagWhereInput
        {
        }
        pub struct createdAt_gte;
        impl ::cynic::schema::Field for createdAt_gte {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt_gte";
        }
        impl ::cynic::schema::HasInputField<createdAt_gte, Option<super::super::DateTime>>
            for super::super::TagWhereInput
        {
        }
        pub struct updatedAt;
        impl ::cynic::schema::Field for updatedAt {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt";
        }
        impl ::cynic::schema::HasInputField<updatedAt, Option<super::super::DateTime>>
            for super::super::TagWhereInput
        {
        }
        pub struct updatedAt_not;
        impl ::cynic::schema::Field for updatedAt_not {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt_not";
        }
        impl ::cynic::schema::HasInputField<updatedAt_not, Option<super::super::DateTime>>
            for super::super::TagWhereInput
        {
        }
        pub struct updatedAt_in;
        impl ::cynic::schema::Field for updatedAt_in {
            type Type = Option<Vec<super::super::DateTime>>;
            const NAME: &'static str = "updatedAt_in";
        }
        impl ::cynic::schema::HasInputField<updatedAt_in, Option<Vec<super::super::DateTime>>>
            for super::super::TagWhereInput
        {
        }
        pub struct updatedAt_not_in;
        impl ::cynic::schema::Field for updatedAt_not_in {
            type Type = Option<Vec<super::super::DateTime>>;
            const NAME: &'static str = "updatedAt_not_in";
        }
        impl ::cynic::schema::HasInputField<updatedAt_not_in, Option<Vec<super::super::DateTime>>>
            for super::super::TagWhereInput
        {
        }
        pub struct updatedAt_lt;
        impl ::cynic::schema::Field for updatedAt_lt {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt_lt";
        }
        impl ::cynic::schema::HasInputField<updatedAt_lt, Option<super::super::DateTime>>
            for super::super::TagWhereInput
        {
        }
        pub struct updatedAt_lte;
        impl ::cynic::schema::Field for updatedAt_lte {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt_lte";
        }
        impl ::cynic::schema::HasInputField<updatedAt_lte, Option<super::super::DateTime>>
            for super::super::TagWhereInput
        {
        }
        pub struct updatedAt_gt;
        impl ::cynic::schema::Field for updatedAt_gt {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt_gt";
        }
        impl ::cynic::schema::HasInputField<updatedAt_gt, Option<super::super::DateTime>>
            for super::super::TagWhereInput
        {
        }
        pub struct updatedAt_gte;
        impl ::cynic::schema::Field for updatedAt_gte {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt_gte";
        }
        impl ::cynic::schema::HasInputField<updatedAt_gte, Option<super::super::DateTime>>
            for super::super::TagWhereInput
        {
        }
        pub struct AND;
        impl ::cynic::schema::Field for AND {
            type Type = Option<Vec<super::super::TagWhereInput>>;
            const NAME: &'static str = "AND";
        }
        impl ::cynic::schema::HasInputField<AND, Option<Vec<super::super::TagWhereInput>>>
            for super::super::TagWhereInput
        {
        }
        pub struct OR;
        impl ::cynic::schema::Field for OR {
            type Type = Option<Vec<super::super::TagWhereInput>>;
            const NAME: &'static str = "OR";
        }
        impl ::cynic::schema::HasInputField<OR, Option<Vec<super::super::TagWhereInput>>>
            for super::super::TagWhereInput
        {
        }
        pub struct NOT;
        impl ::cynic::schema::Field for NOT {
            type Type = Option<Vec<super::super::TagWhereInput>>;
            const NAME: &'static str = "NOT";
        }
        impl ::cynic::schema::HasInputField<NOT, Option<Vec<super::super::TagWhereInput>>>
            for super::super::TagWhereInput
        {
        }
    }
    pub mod UpdateCompanyInput {
        pub struct id;
        impl ::cynic::schema::Field for id {
            type Type = super::super::ID;
            const NAME: &'static str = "id";
        }
        impl ::cynic::schema::HasInputField<id, super::super::ID> for super::super::UpdateCompanyInput {}
        pub struct logoUrl;
        impl ::cynic::schema::Field for logoUrl {
            type Type = super::super::String;
            const NAME: &'static str = "logoUrl";
        }
        impl ::cynic::schema::HasInputField<logoUrl, super::super::String>
            for super::super::UpdateCompanyInput
        {
        }
    }
    pub mod UpdateJobInput {
        pub struct id;
        impl ::cynic::schema::Field for id {
            type Type = super::super::ID;
            const NAME: &'static str = "id";
        }
        impl ::cynic::schema::HasInputField<id, super::super::ID> for super::super::UpdateJobInput {}
        pub struct description;
        impl ::cynic::schema::Field for description {
            type Type = super::super::String;
            const NAME: &'static str = "description";
        }
        impl ::cynic::schema::HasInputField<description, super::super::String>
            for super::super::UpdateJobInput
        {
        }
    }
    pub mod User {
        pub struct id;
        impl ::cynic::schema::Field for id {
            type Type = super::super::ID;
            const NAME: &'static str = "id";
        }
        impl ::cynic::schema::HasField<id> for super::super::User {
            type Type = super::super::ID;
        }
        pub struct name;
        impl ::cynic::schema::Field for name {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name";
        }
        impl ::cynic::schema::HasField<name> for super::super::User {
            type Type = Option<super::super::String>;
        }
        pub struct email;
        impl ::cynic::schema::Field for email {
            type Type = super::super::String;
            const NAME: &'static str = "email";
        }
        impl ::cynic::schema::HasField<email> for super::super::User {
            type Type = super::super::String;
        }
        pub struct subscribe;
        impl ::cynic::schema::Field for subscribe {
            type Type = super::super::Boolean;
            const NAME: &'static str = "subscribe";
        }
        impl ::cynic::schema::HasField<subscribe> for super::super::User {
            type Type = super::super::Boolean;
        }
        pub struct createdAt;
        impl ::cynic::schema::Field for createdAt {
            type Type = super::super::DateTime;
            const NAME: &'static str = "createdAt";
        }
        impl ::cynic::schema::HasField<createdAt> for super::super::User {
            type Type = super::super::DateTime;
        }
        pub struct updatedAt;
        impl ::cynic::schema::Field for updatedAt {
            type Type = super::super::DateTime;
            const NAME: &'static str = "updatedAt";
        }
        impl ::cynic::schema::HasField<updatedAt> for super::super::User {
            type Type = super::super::DateTime;
        }
        pub struct __typename;
        impl ::cynic::schema::Field for __typename {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
        impl ::cynic::schema::HasField<__typename> for super::super::User {
            type Type = super::super::String;
        }
    }
}
pub type Boolean = bool;
pub type String = std::string::String;
pub type Float = f64;
pub type Int = i32;
pub type ID = ::cynic::Id;
pub mod variable {
    use cynic::variables::VariableType;
    #[doc = r" Used to determine the type of a given variable that"]
    #[doc = r" appears in an argument struct."]
    pub trait Variable {
        const TYPE: VariableType;
    }
    impl<T> Variable for &T
    where
        T: Variable,
    {
        const TYPE: VariableType = T::TYPE;
    }
    impl<T> Variable for Option<T>
    where
        T: Variable,
    {
        const TYPE: VariableType = VariableType::Nullable(&T::TYPE);
    }
    impl<T> Variable for Vec<T>
    where
        T: Variable,
    {
        const TYPE: VariableType = VariableType::List(&T::TYPE);
    }
    impl<T> Variable for Box<T>
    where
        T: Variable,
    {
        const TYPE: VariableType = T::TYPE;
    }
    impl<T> Variable for std::rc::Rc<T>
    where
        T: Variable,
    {
        const TYPE: VariableType = T::TYPE;
    }
    impl<T> Variable for std::sync::Arc<T>
    where
        T: Variable,
    {
        const TYPE: VariableType = T::TYPE;
    }
    impl Variable for bool {
        const TYPE: VariableType = VariableType::Named("Boolean");
    }
    impl Variable for String {
        const TYPE: VariableType = VariableType::Named("String");
    }
    impl Variable for f64 {
        const TYPE: VariableType = VariableType::Named("Float");
    }
    impl Variable for i32 {
        const TYPE: VariableType = VariableType::Named("Int");
    }
    impl Variable for ::cynic::Id {
        const TYPE: VariableType = VariableType::Named("ID");
    }
}

