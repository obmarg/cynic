---
source: cynic-codegen/tests/use-schema.rs
expression: "format_code(format!(\"{}\", tokens))"
---
impl cynic::schema::QueryRoot for Query {}
impl cynic::schema::MutationRoot for Mutation {}
pub struct City;
pub struct CityOrderByInput {}
pub struct CityWhereInput;
impl cynic::schema::InputObjectMarker for CityWhereInput {}
pub struct Commitment;
pub struct CommitmentWhereInput;
impl cynic::schema::InputObjectMarker for CommitmentWhereInput {}
pub struct Company;
pub struct CompanyWhereInput;
impl cynic::schema::InputObjectMarker for CompanyWhereInput {}
pub struct Country;
pub struct CountryOrderByInput {}
pub struct CountryWhereInput;
impl cynic::schema::InputObjectMarker for CountryWhereInput {}
pub struct DateTime {}
impl cynic::schema::NamedType for DateTime {
    const NAME: &'static str = "DateTime";
}
pub struct Job;
pub struct JobInput;
impl cynic::schema::InputObjectMarker for JobInput {}
pub struct JobOrderByInput {}
pub struct JobWhereInput;
impl cynic::schema::InputObjectMarker for JobWhereInput {}
pub struct JobsInput;
impl cynic::schema::InputObjectMarker for JobsInput {}
pub struct Location;
pub struct LocationInput;
impl cynic::schema::InputObjectMarker for LocationInput {}
pub struct LocationsInput;
impl cynic::schema::InputObjectMarker for LocationsInput {}
pub struct Mutation;
pub struct PostJobInput;
impl cynic::schema::InputObjectMarker for PostJobInput {}
pub struct Query;
pub struct Remote;
pub struct RemoteOrderByInput {}
pub struct RemoteWhereInput;
impl cynic::schema::InputObjectMarker for RemoteWhereInput {}
pub struct SubscribeInput;
impl cynic::schema::InputObjectMarker for SubscribeInput {}
pub struct Tag;
pub struct TagOrderByInput {}
pub struct TagWhereInput;
impl cynic::schema::InputObjectMarker for TagWhereInput {}
pub struct UpdateCompanyInput;
impl cynic::schema::InputObjectMarker for UpdateCompanyInput {}
pub struct UpdateJobInput;
impl cynic::schema::InputObjectMarker for UpdateJobInput {}
pub struct User;
impl cynic::schema::NamedType for City {
    const NAME: &'static str = "City";
}
impl cynic::schema::NamedType for Commitment {
    const NAME: &'static str = "Commitment";
}
impl cynic::schema::NamedType for Company {
    const NAME: &'static str = "Company";
}
impl cynic::schema::NamedType for Country {
    const NAME: &'static str = "Country";
}
impl cynic::schema::NamedType for Job {
    const NAME: &'static str = "Job";
}
impl cynic::schema::NamedType for Location {
    const NAME: &'static str = "Location";
}
impl cynic::schema::NamedType for Mutation {
    const NAME: &'static str = "Mutation";
}
impl cynic::schema::NamedType for Query {
    const NAME: &'static str = "Query";
}
impl cynic::schema::NamedType for Remote {
    const NAME: &'static str = "Remote";
}
impl cynic::schema::NamedType for Tag {
    const NAME: &'static str = "Tag";
}
impl cynic::schema::NamedType for User {
    const NAME: &'static str = "User";
}
#[allow(non_snake_case, non_camel_case_types)]
pub mod __fields {
    pub mod City {
        pub struct id;
        impl cynic::schema::HasField<id> for super::super::City {
            type Type = super::super::ID;
            const NAME: &'static str = "id";
        }
        pub struct name;
        impl cynic::schema::HasField<name> for super::super::City {
            type Type = super::super::String;
            const NAME: &'static str = "name";
        }
        pub struct slug;
        impl cynic::schema::HasField<slug> for super::super::City {
            type Type = super::super::String;
            const NAME: &'static str = "slug";
        }
        pub struct country;
        impl cynic::schema::HasField<country> for super::super::City {
            type Type = super::super::Country;
            const NAME: &'static str = "country";
        }
        pub struct r#type;
        impl cynic::schema::HasField<r#type> for super::super::City {
            type Type = super::super::String;
            const NAME: &'static str = "type";
        }
        pub struct jobs;
        impl cynic::schema::HasField<jobs> for super::super::City {
            type Type = Option<Vec<super::super::Job>>;
            const NAME: &'static str = "jobs";
        }
        pub mod _jobs_arguments {
            pub struct r#where;
            impl cynic::schema::HasArgument<r#where> for super::jobs {
                type ArgumentType = Option<super::super::super::JobWhereInput>;
                const NAME: &'static str = "where";
            }
            pub struct orderBy;
            impl cynic::schema::HasArgument<orderBy> for super::jobs {
                type ArgumentType = Option<super::super::super::JobOrderByInput>;
                const NAME: &'static str = "orderBy";
            }
            pub struct skip;
            impl cynic::schema::HasArgument<skip> for super::jobs {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "skip";
            }
            pub struct after;
            impl cynic::schema::HasArgument<after> for super::jobs {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "after";
            }
            pub struct before;
            impl cynic::schema::HasArgument<before> for super::jobs {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "before";
            }
            pub struct first;
            impl cynic::schema::HasArgument<first> for super::jobs {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "first";
            }
            pub struct last;
            impl cynic::schema::HasArgument<last> for super::jobs {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "last";
            }
        }
        pub struct createdAt;
        impl cynic::schema::HasField<createdAt> for super::super::City {
            type Type = super::super::DateTime;
            const NAME: &'static str = "createdAt";
        }
        pub struct updatedAt;
        impl cynic::schema::HasField<updatedAt> for super::super::City {
            type Type = super::super::DateTime;
            const NAME: &'static str = "updatedAt";
        }
        pub struct __typename;
        impl cynic::schema::HasField<__typename> for super::super::City {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
    }
    pub mod CityWhereInput {
        pub struct id;
        impl cynic::schema::HasInputField<id> for super::super::CityWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id";
        }
        pub struct id_not;
        impl cynic::schema::HasInputField<id_not> for super::super::CityWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_not";
        }
        pub struct id_in;
        impl cynic::schema::HasInputField<id_in> for super::super::CityWhereInput {
            type Type = Option<Vec<super::super::ID>>;
            const NAME: &'static str = "id_in";
        }
        pub struct id_not_in;
        impl cynic::schema::HasInputField<id_not_in> for super::super::CityWhereInput {
            type Type = Option<Vec<super::super::ID>>;
            const NAME: &'static str = "id_not_in";
        }
        pub struct id_lt;
        impl cynic::schema::HasInputField<id_lt> for super::super::CityWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_lt";
        }
        pub struct id_lte;
        impl cynic::schema::HasInputField<id_lte> for super::super::CityWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_lte";
        }
        pub struct id_gt;
        impl cynic::schema::HasInputField<id_gt> for super::super::CityWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_gt";
        }
        pub struct id_gte;
        impl cynic::schema::HasInputField<id_gte> for super::super::CityWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_gte";
        }
        pub struct id_contains;
        impl cynic::schema::HasInputField<id_contains> for super::super::CityWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_contains";
        }
        pub struct id_not_contains;
        impl cynic::schema::HasInputField<id_not_contains> for super::super::CityWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_not_contains";
        }
        pub struct id_starts_with;
        impl cynic::schema::HasInputField<id_starts_with> for super::super::CityWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_starts_with";
        }
        pub struct id_not_starts_with;
        impl cynic::schema::HasInputField<id_not_starts_with> for super::super::CityWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_not_starts_with";
        }
        pub struct id_ends_with;
        impl cynic::schema::HasInputField<id_ends_with> for super::super::CityWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_ends_with";
        }
        pub struct id_not_ends_with;
        impl cynic::schema::HasInputField<id_not_ends_with> for super::super::CityWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_not_ends_with";
        }
        pub struct name;
        impl cynic::schema::HasInputField<name> for super::super::CityWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name";
        }
        pub struct name_not;
        impl cynic::schema::HasInputField<name_not> for super::super::CityWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_not";
        }
        pub struct name_in;
        impl cynic::schema::HasInputField<name_in> for super::super::CityWhereInput {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "name_in";
        }
        pub struct name_not_in;
        impl cynic::schema::HasInputField<name_not_in> for super::super::CityWhereInput {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "name_not_in";
        }
        pub struct name_lt;
        impl cynic::schema::HasInputField<name_lt> for super::super::CityWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_lt";
        }
        pub struct name_lte;
        impl cynic::schema::HasInputField<name_lte> for super::super::CityWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_lte";
        }
        pub struct name_gt;
        impl cynic::schema::HasInputField<name_gt> for super::super::CityWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_gt";
        }
        pub struct name_gte;
        impl cynic::schema::HasInputField<name_gte> for super::super::CityWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_gte";
        }
        pub struct name_contains;
        impl cynic::schema::HasInputField<name_contains> for super::super::CityWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_contains";
        }
        pub struct name_not_contains;
        impl cynic::schema::HasInputField<name_not_contains> for super::super::CityWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_not_contains";
        }
        pub struct name_starts_with;
        impl cynic::schema::HasInputField<name_starts_with> for super::super::CityWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_starts_with";
        }
        pub struct name_not_starts_with;
        impl cynic::schema::HasInputField<name_not_starts_with> for super::super::CityWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_not_starts_with";
        }
        pub struct name_ends_with;
        impl cynic::schema::HasInputField<name_ends_with> for super::super::CityWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_ends_with";
        }
        pub struct name_not_ends_with;
        impl cynic::schema::HasInputField<name_not_ends_with> for super::super::CityWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_not_ends_with";
        }
        pub struct slug;
        impl cynic::schema::HasInputField<slug> for super::super::CityWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug";
        }
        pub struct slug_not;
        impl cynic::schema::HasInputField<slug_not> for super::super::CityWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_not";
        }
        pub struct slug_in;
        impl cynic::schema::HasInputField<slug_in> for super::super::CityWhereInput {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "slug_in";
        }
        pub struct slug_not_in;
        impl cynic::schema::HasInputField<slug_not_in> for super::super::CityWhereInput {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "slug_not_in";
        }
        pub struct slug_lt;
        impl cynic::schema::HasInputField<slug_lt> for super::super::CityWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_lt";
        }
        pub struct slug_lte;
        impl cynic::schema::HasInputField<slug_lte> for super::super::CityWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_lte";
        }
        pub struct slug_gt;
        impl cynic::schema::HasInputField<slug_gt> for super::super::CityWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_gt";
        }
        pub struct slug_gte;
        impl cynic::schema::HasInputField<slug_gte> for super::super::CityWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_gte";
        }
        pub struct slug_contains;
        impl cynic::schema::HasInputField<slug_contains> for super::super::CityWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_contains";
        }
        pub struct slug_not_contains;
        impl cynic::schema::HasInputField<slug_not_contains> for super::super::CityWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_not_contains";
        }
        pub struct slug_starts_with;
        impl cynic::schema::HasInputField<slug_starts_with> for super::super::CityWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_starts_with";
        }
        pub struct slug_not_starts_with;
        impl cynic::schema::HasInputField<slug_not_starts_with> for super::super::CityWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_not_starts_with";
        }
        pub struct slug_ends_with;
        impl cynic::schema::HasInputField<slug_ends_with> for super::super::CityWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_ends_with";
        }
        pub struct slug_not_ends_with;
        impl cynic::schema::HasInputField<slug_not_ends_with> for super::super::CityWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_not_ends_with";
        }
        pub struct country;
        impl cynic::schema::HasInputField<country> for super::super::CityWhereInput {
            type Type = Option<super::super::CountryWhereInput>;
            const NAME: &'static str = "country";
        }
        pub struct r#type;
        impl cynic::schema::HasInputField<r#type> for super::super::CityWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type";
        }
        pub struct type_not;
        impl cynic::schema::HasInputField<type_not> for super::super::CityWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type_not";
        }
        pub struct type_in;
        impl cynic::schema::HasInputField<type_in> for super::super::CityWhereInput {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "type_in";
        }
        pub struct type_not_in;
        impl cynic::schema::HasInputField<type_not_in> for super::super::CityWhereInput {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "type_not_in";
        }
        pub struct type_lt;
        impl cynic::schema::HasInputField<type_lt> for super::super::CityWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type_lt";
        }
        pub struct type_lte;
        impl cynic::schema::HasInputField<type_lte> for super::super::CityWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type_lte";
        }
        pub struct type_gt;
        impl cynic::schema::HasInputField<type_gt> for super::super::CityWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type_gt";
        }
        pub struct type_gte;
        impl cynic::schema::HasInputField<type_gte> for super::super::CityWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type_gte";
        }
        pub struct type_contains;
        impl cynic::schema::HasInputField<type_contains> for super::super::CityWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type_contains";
        }
        pub struct type_not_contains;
        impl cynic::schema::HasInputField<type_not_contains> for super::super::CityWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type_not_contains";
        }
        pub struct type_starts_with;
        impl cynic::schema::HasInputField<type_starts_with> for super::super::CityWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type_starts_with";
        }
        pub struct type_not_starts_with;
        impl cynic::schema::HasInputField<type_not_starts_with> for super::super::CityWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type_not_starts_with";
        }
        pub struct type_ends_with;
        impl cynic::schema::HasInputField<type_ends_with> for super::super::CityWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type_ends_with";
        }
        pub struct type_not_ends_with;
        impl cynic::schema::HasInputField<type_not_ends_with> for super::super::CityWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type_not_ends_with";
        }
        pub struct jobs_every;
        impl cynic::schema::HasInputField<jobs_every> for super::super::CityWhereInput {
            type Type = Option<super::super::JobWhereInput>;
            const NAME: &'static str = "jobs_every";
        }
        pub struct jobs_some;
        impl cynic::schema::HasInputField<jobs_some> for super::super::CityWhereInput {
            type Type = Option<super::super::JobWhereInput>;
            const NAME: &'static str = "jobs_some";
        }
        pub struct jobs_none;
        impl cynic::schema::HasInputField<jobs_none> for super::super::CityWhereInput {
            type Type = Option<super::super::JobWhereInput>;
            const NAME: &'static str = "jobs_none";
        }
        pub struct createdAt;
        impl cynic::schema::HasInputField<createdAt> for super::super::CityWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt";
        }
        pub struct createdAt_not;
        impl cynic::schema::HasInputField<createdAt_not> for super::super::CityWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt_not";
        }
        pub struct createdAt_in;
        impl cynic::schema::HasInputField<createdAt_in> for super::super::CityWhereInput {
            type Type = Option<Vec<super::super::DateTime>>;
            const NAME: &'static str = "createdAt_in";
        }
        pub struct createdAt_not_in;
        impl cynic::schema::HasInputField<createdAt_not_in> for super::super::CityWhereInput {
            type Type = Option<Vec<super::super::DateTime>>;
            const NAME: &'static str = "createdAt_not_in";
        }
        pub struct createdAt_lt;
        impl cynic::schema::HasInputField<createdAt_lt> for super::super::CityWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt_lt";
        }
        pub struct createdAt_lte;
        impl cynic::schema::HasInputField<createdAt_lte> for super::super::CityWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt_lte";
        }
        pub struct createdAt_gt;
        impl cynic::schema::HasInputField<createdAt_gt> for super::super::CityWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt_gt";
        }
        pub struct createdAt_gte;
        impl cynic::schema::HasInputField<createdAt_gte> for super::super::CityWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt_gte";
        }
        pub struct updatedAt;
        impl cynic::schema::HasInputField<updatedAt> for super::super::CityWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt";
        }
        pub struct updatedAt_not;
        impl cynic::schema::HasInputField<updatedAt_not> for super::super::CityWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt_not";
        }
        pub struct updatedAt_in;
        impl cynic::schema::HasInputField<updatedAt_in> for super::super::CityWhereInput {
            type Type = Option<Vec<super::super::DateTime>>;
            const NAME: &'static str = "updatedAt_in";
        }
        pub struct updatedAt_not_in;
        impl cynic::schema::HasInputField<updatedAt_not_in> for super::super::CityWhereInput {
            type Type = Option<Vec<super::super::DateTime>>;
            const NAME: &'static str = "updatedAt_not_in";
        }
        pub struct updatedAt_lt;
        impl cynic::schema::HasInputField<updatedAt_lt> for super::super::CityWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt_lt";
        }
        pub struct updatedAt_lte;
        impl cynic::schema::HasInputField<updatedAt_lte> for super::super::CityWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt_lte";
        }
        pub struct updatedAt_gt;
        impl cynic::schema::HasInputField<updatedAt_gt> for super::super::CityWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt_gt";
        }
        pub struct updatedAt_gte;
        impl cynic::schema::HasInputField<updatedAt_gte> for super::super::CityWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt_gte";
        }
        pub struct AND;
        impl cynic::schema::HasInputField<AND> for super::super::CityWhereInput {
            type Type = Option<Vec<super::super::CityWhereInput>>;
            const NAME: &'static str = "AND";
        }
        pub struct OR;
        impl cynic::schema::HasInputField<OR> for super::super::CityWhereInput {
            type Type = Option<Vec<super::super::CityWhereInput>>;
            const NAME: &'static str = "OR";
        }
        pub struct NOT;
        impl cynic::schema::HasInputField<NOT> for super::super::CityWhereInput {
            type Type = Option<Vec<super::super::CityWhereInput>>;
            const NAME: &'static str = "NOT";
        }
    }
    pub mod Commitment {
        pub struct id;
        impl cynic::schema::HasField<id> for super::super::Commitment {
            type Type = super::super::ID;
            const NAME: &'static str = "id";
        }
        pub struct title;
        impl cynic::schema::HasField<title> for super::super::Commitment {
            type Type = super::super::String;
            const NAME: &'static str = "title";
        }
        pub struct slug;
        impl cynic::schema::HasField<slug> for super::super::Commitment {
            type Type = super::super::String;
            const NAME: &'static str = "slug";
        }
        pub struct jobs;
        impl cynic::schema::HasField<jobs> for super::super::Commitment {
            type Type = Option<Vec<super::super::Job>>;
            const NAME: &'static str = "jobs";
        }
        pub mod _jobs_arguments {
            pub struct r#where;
            impl cynic::schema::HasArgument<r#where> for super::jobs {
                type ArgumentType = Option<super::super::super::JobWhereInput>;
                const NAME: &'static str = "where";
            }
            pub struct orderBy;
            impl cynic::schema::HasArgument<orderBy> for super::jobs {
                type ArgumentType = Option<super::super::super::JobOrderByInput>;
                const NAME: &'static str = "orderBy";
            }
            pub struct skip;
            impl cynic::schema::HasArgument<skip> for super::jobs {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "skip";
            }
            pub struct after;
            impl cynic::schema::HasArgument<after> for super::jobs {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "after";
            }
            pub struct before;
            impl cynic::schema::HasArgument<before> for super::jobs {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "before";
            }
            pub struct first;
            impl cynic::schema::HasArgument<first> for super::jobs {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "first";
            }
            pub struct last;
            impl cynic::schema::HasArgument<last> for super::jobs {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "last";
            }
        }
        pub struct createdAt;
        impl cynic::schema::HasField<createdAt> for super::super::Commitment {
            type Type = super::super::DateTime;
            const NAME: &'static str = "createdAt";
        }
        pub struct updatedAt;
        impl cynic::schema::HasField<updatedAt> for super::super::Commitment {
            type Type = super::super::DateTime;
            const NAME: &'static str = "updatedAt";
        }
        pub struct __typename;
        impl cynic::schema::HasField<__typename> for super::super::Commitment {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
    }
    pub mod CommitmentWhereInput {
        pub struct id;
        impl cynic::schema::HasInputField<id> for super::super::CommitmentWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id";
        }
        pub struct id_not;
        impl cynic::schema::HasInputField<id_not> for super::super::CommitmentWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_not";
        }
        pub struct id_in;
        impl cynic::schema::HasInputField<id_in> for super::super::CommitmentWhereInput {
            type Type = Option<Vec<super::super::ID>>;
            const NAME: &'static str = "id_in";
        }
        pub struct id_not_in;
        impl cynic::schema::HasInputField<id_not_in> for super::super::CommitmentWhereInput {
            type Type = Option<Vec<super::super::ID>>;
            const NAME: &'static str = "id_not_in";
        }
        pub struct id_lt;
        impl cynic::schema::HasInputField<id_lt> for super::super::CommitmentWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_lt";
        }
        pub struct id_lte;
        impl cynic::schema::HasInputField<id_lte> for super::super::CommitmentWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_lte";
        }
        pub struct id_gt;
        impl cynic::schema::HasInputField<id_gt> for super::super::CommitmentWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_gt";
        }
        pub struct id_gte;
        impl cynic::schema::HasInputField<id_gte> for super::super::CommitmentWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_gte";
        }
        pub struct id_contains;
        impl cynic::schema::HasInputField<id_contains> for super::super::CommitmentWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_contains";
        }
        pub struct id_not_contains;
        impl cynic::schema::HasInputField<id_not_contains> for super::super::CommitmentWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_not_contains";
        }
        pub struct id_starts_with;
        impl cynic::schema::HasInputField<id_starts_with> for super::super::CommitmentWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_starts_with";
        }
        pub struct id_not_starts_with;
        impl cynic::schema::HasInputField<id_not_starts_with> for super::super::CommitmentWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_not_starts_with";
        }
        pub struct id_ends_with;
        impl cynic::schema::HasInputField<id_ends_with> for super::super::CommitmentWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_ends_with";
        }
        pub struct id_not_ends_with;
        impl cynic::schema::HasInputField<id_not_ends_with> for super::super::CommitmentWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_not_ends_with";
        }
        pub struct title;
        impl cynic::schema::HasInputField<title> for super::super::CommitmentWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "title";
        }
        pub struct title_not;
        impl cynic::schema::HasInputField<title_not> for super::super::CommitmentWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "title_not";
        }
        pub struct title_in;
        impl cynic::schema::HasInputField<title_in> for super::super::CommitmentWhereInput {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "title_in";
        }
        pub struct title_not_in;
        impl cynic::schema::HasInputField<title_not_in> for super::super::CommitmentWhereInput {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "title_not_in";
        }
        pub struct title_lt;
        impl cynic::schema::HasInputField<title_lt> for super::super::CommitmentWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "title_lt";
        }
        pub struct title_lte;
        impl cynic::schema::HasInputField<title_lte> for super::super::CommitmentWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "title_lte";
        }
        pub struct title_gt;
        impl cynic::schema::HasInputField<title_gt> for super::super::CommitmentWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "title_gt";
        }
        pub struct title_gte;
        impl cynic::schema::HasInputField<title_gte> for super::super::CommitmentWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "title_gte";
        }
        pub struct title_contains;
        impl cynic::schema::HasInputField<title_contains> for super::super::CommitmentWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "title_contains";
        }
        pub struct title_not_contains;
        impl cynic::schema::HasInputField<title_not_contains> for super::super::CommitmentWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "title_not_contains";
        }
        pub struct title_starts_with;
        impl cynic::schema::HasInputField<title_starts_with> for super::super::CommitmentWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "title_starts_with";
        }
        pub struct title_not_starts_with;
        impl cynic::schema::HasInputField<title_not_starts_with> for super::super::CommitmentWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "title_not_starts_with";
        }
        pub struct title_ends_with;
        impl cynic::schema::HasInputField<title_ends_with> for super::super::CommitmentWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "title_ends_with";
        }
        pub struct title_not_ends_with;
        impl cynic::schema::HasInputField<title_not_ends_with> for super::super::CommitmentWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "title_not_ends_with";
        }
        pub struct slug;
        impl cynic::schema::HasInputField<slug> for super::super::CommitmentWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug";
        }
        pub struct slug_not;
        impl cynic::schema::HasInputField<slug_not> for super::super::CommitmentWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_not";
        }
        pub struct slug_in;
        impl cynic::schema::HasInputField<slug_in> for super::super::CommitmentWhereInput {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "slug_in";
        }
        pub struct slug_not_in;
        impl cynic::schema::HasInputField<slug_not_in> for super::super::CommitmentWhereInput {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "slug_not_in";
        }
        pub struct slug_lt;
        impl cynic::schema::HasInputField<slug_lt> for super::super::CommitmentWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_lt";
        }
        pub struct slug_lte;
        impl cynic::schema::HasInputField<slug_lte> for super::super::CommitmentWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_lte";
        }
        pub struct slug_gt;
        impl cynic::schema::HasInputField<slug_gt> for super::super::CommitmentWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_gt";
        }
        pub struct slug_gte;
        impl cynic::schema::HasInputField<slug_gte> for super::super::CommitmentWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_gte";
        }
        pub struct slug_contains;
        impl cynic::schema::HasInputField<slug_contains> for super::super::CommitmentWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_contains";
        }
        pub struct slug_not_contains;
        impl cynic::schema::HasInputField<slug_not_contains> for super::super::CommitmentWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_not_contains";
        }
        pub struct slug_starts_with;
        impl cynic::schema::HasInputField<slug_starts_with> for super::super::CommitmentWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_starts_with";
        }
        pub struct slug_not_starts_with;
        impl cynic::schema::HasInputField<slug_not_starts_with> for super::super::CommitmentWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_not_starts_with";
        }
        pub struct slug_ends_with;
        impl cynic::schema::HasInputField<slug_ends_with> for super::super::CommitmentWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_ends_with";
        }
        pub struct slug_not_ends_with;
        impl cynic::schema::HasInputField<slug_not_ends_with> for super::super::CommitmentWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_not_ends_with";
        }
        pub struct jobs_every;
        impl cynic::schema::HasInputField<jobs_every> for super::super::CommitmentWhereInput {
            type Type = Option<super::super::JobWhereInput>;
            const NAME: &'static str = "jobs_every";
        }
        pub struct jobs_some;
        impl cynic::schema::HasInputField<jobs_some> for super::super::CommitmentWhereInput {
            type Type = Option<super::super::JobWhereInput>;
            const NAME: &'static str = "jobs_some";
        }
        pub struct jobs_none;
        impl cynic::schema::HasInputField<jobs_none> for super::super::CommitmentWhereInput {
            type Type = Option<super::super::JobWhereInput>;
            const NAME: &'static str = "jobs_none";
        }
        pub struct createdAt;
        impl cynic::schema::HasInputField<createdAt> for super::super::CommitmentWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt";
        }
        pub struct createdAt_not;
        impl cynic::schema::HasInputField<createdAt_not> for super::super::CommitmentWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt_not";
        }
        pub struct createdAt_in;
        impl cynic::schema::HasInputField<createdAt_in> for super::super::CommitmentWhereInput {
            type Type = Option<Vec<super::super::DateTime>>;
            const NAME: &'static str = "createdAt_in";
        }
        pub struct createdAt_not_in;
        impl cynic::schema::HasInputField<createdAt_not_in> for super::super::CommitmentWhereInput {
            type Type = Option<Vec<super::super::DateTime>>;
            const NAME: &'static str = "createdAt_not_in";
        }
        pub struct createdAt_lt;
        impl cynic::schema::HasInputField<createdAt_lt> for super::super::CommitmentWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt_lt";
        }
        pub struct createdAt_lte;
        impl cynic::schema::HasInputField<createdAt_lte> for super::super::CommitmentWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt_lte";
        }
        pub struct createdAt_gt;
        impl cynic::schema::HasInputField<createdAt_gt> for super::super::CommitmentWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt_gt";
        }
        pub struct createdAt_gte;
        impl cynic::schema::HasInputField<createdAt_gte> for super::super::CommitmentWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt_gte";
        }
        pub struct updatedAt;
        impl cynic::schema::HasInputField<updatedAt> for super::super::CommitmentWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt";
        }
        pub struct updatedAt_not;
        impl cynic::schema::HasInputField<updatedAt_not> for super::super::CommitmentWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt_not";
        }
        pub struct updatedAt_in;
        impl cynic::schema::HasInputField<updatedAt_in> for super::super::CommitmentWhereInput {
            type Type = Option<Vec<super::super::DateTime>>;
            const NAME: &'static str = "updatedAt_in";
        }
        pub struct updatedAt_not_in;
        impl cynic::schema::HasInputField<updatedAt_not_in> for super::super::CommitmentWhereInput {
            type Type = Option<Vec<super::super::DateTime>>;
            const NAME: &'static str = "updatedAt_not_in";
        }
        pub struct updatedAt_lt;
        impl cynic::schema::HasInputField<updatedAt_lt> for super::super::CommitmentWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt_lt";
        }
        pub struct updatedAt_lte;
        impl cynic::schema::HasInputField<updatedAt_lte> for super::super::CommitmentWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt_lte";
        }
        pub struct updatedAt_gt;
        impl cynic::schema::HasInputField<updatedAt_gt> for super::super::CommitmentWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt_gt";
        }
        pub struct updatedAt_gte;
        impl cynic::schema::HasInputField<updatedAt_gte> for super::super::CommitmentWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt_gte";
        }
        pub struct AND;
        impl cynic::schema::HasInputField<AND> for super::super::CommitmentWhereInput {
            type Type = Option<Vec<super::super::CommitmentWhereInput>>;
            const NAME: &'static str = "AND";
        }
        pub struct OR;
        impl cynic::schema::HasInputField<OR> for super::super::CommitmentWhereInput {
            type Type = Option<Vec<super::super::CommitmentWhereInput>>;
            const NAME: &'static str = "OR";
        }
        pub struct NOT;
        impl cynic::schema::HasInputField<NOT> for super::super::CommitmentWhereInput {
            type Type = Option<Vec<super::super::CommitmentWhereInput>>;
            const NAME: &'static str = "NOT";
        }
    }
    pub mod Company {
        pub struct id;
        impl cynic::schema::HasField<id> for super::super::Company {
            type Type = super::super::ID;
            const NAME: &'static str = "id";
        }
        pub struct name;
        impl cynic::schema::HasField<name> for super::super::Company {
            type Type = super::super::String;
            const NAME: &'static str = "name";
        }
        pub struct slug;
        impl cynic::schema::HasField<slug> for super::super::Company {
            type Type = super::super::String;
            const NAME: &'static str = "slug";
        }
        pub struct websiteUrl;
        impl cynic::schema::HasField<websiteUrl> for super::super::Company {
            type Type = super::super::String;
            const NAME: &'static str = "websiteUrl";
        }
        pub struct logoUrl;
        impl cynic::schema::HasField<logoUrl> for super::super::Company {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "logoUrl";
        }
        pub struct jobs;
        impl cynic::schema::HasField<jobs> for super::super::Company {
            type Type = Option<Vec<super::super::Job>>;
            const NAME: &'static str = "jobs";
        }
        pub mod _jobs_arguments {
            pub struct r#where;
            impl cynic::schema::HasArgument<r#where> for super::jobs {
                type ArgumentType = Option<super::super::super::JobWhereInput>;
                const NAME: &'static str = "where";
            }
            pub struct orderBy;
            impl cynic::schema::HasArgument<orderBy> for super::jobs {
                type ArgumentType = Option<super::super::super::JobOrderByInput>;
                const NAME: &'static str = "orderBy";
            }
            pub struct skip;
            impl cynic::schema::HasArgument<skip> for super::jobs {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "skip";
            }
            pub struct after;
            impl cynic::schema::HasArgument<after> for super::jobs {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "after";
            }
            pub struct before;
            impl cynic::schema::HasArgument<before> for super::jobs {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "before";
            }
            pub struct first;
            impl cynic::schema::HasArgument<first> for super::jobs {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "first";
            }
            pub struct last;
            impl cynic::schema::HasArgument<last> for super::jobs {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "last";
            }
        }
        pub struct twitter;
        impl cynic::schema::HasField<twitter> for super::super::Company {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "twitter";
        }
        pub struct emailed;
        impl cynic::schema::HasField<emailed> for super::super::Company {
            type Type = Option<super::super::Boolean>;
            const NAME: &'static str = "emailed";
        }
        pub struct createdAt;
        impl cynic::schema::HasField<createdAt> for super::super::Company {
            type Type = super::super::DateTime;
            const NAME: &'static str = "createdAt";
        }
        pub struct updatedAt;
        impl cynic::schema::HasField<updatedAt> for super::super::Company {
            type Type = super::super::DateTime;
            const NAME: &'static str = "updatedAt";
        }
        pub struct __typename;
        impl cynic::schema::HasField<__typename> for super::super::Company {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
    }
    pub mod CompanyWhereInput {
        pub struct id;
        impl cynic::schema::HasInputField<id> for super::super::CompanyWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id";
        }
        pub struct id_not;
        impl cynic::schema::HasInputField<id_not> for super::super::CompanyWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_not";
        }
        pub struct id_in;
        impl cynic::schema::HasInputField<id_in> for super::super::CompanyWhereInput {
            type Type = Option<Vec<super::super::ID>>;
            const NAME: &'static str = "id_in";
        }
        pub struct id_not_in;
        impl cynic::schema::HasInputField<id_not_in> for super::super::CompanyWhereInput {
            type Type = Option<Vec<super::super::ID>>;
            const NAME: &'static str = "id_not_in";
        }
        pub struct id_lt;
        impl cynic::schema::HasInputField<id_lt> for super::super::CompanyWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_lt";
        }
        pub struct id_lte;
        impl cynic::schema::HasInputField<id_lte> for super::super::CompanyWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_lte";
        }
        pub struct id_gt;
        impl cynic::schema::HasInputField<id_gt> for super::super::CompanyWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_gt";
        }
        pub struct id_gte;
        impl cynic::schema::HasInputField<id_gte> for super::super::CompanyWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_gte";
        }
        pub struct id_contains;
        impl cynic::schema::HasInputField<id_contains> for super::super::CompanyWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_contains";
        }
        pub struct id_not_contains;
        impl cynic::schema::HasInputField<id_not_contains> for super::super::CompanyWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_not_contains";
        }
        pub struct id_starts_with;
        impl cynic::schema::HasInputField<id_starts_with> for super::super::CompanyWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_starts_with";
        }
        pub struct id_not_starts_with;
        impl cynic::schema::HasInputField<id_not_starts_with> for super::super::CompanyWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_not_starts_with";
        }
        pub struct id_ends_with;
        impl cynic::schema::HasInputField<id_ends_with> for super::super::CompanyWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_ends_with";
        }
        pub struct id_not_ends_with;
        impl cynic::schema::HasInputField<id_not_ends_with> for super::super::CompanyWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_not_ends_with";
        }
        pub struct name;
        impl cynic::schema::HasInputField<name> for super::super::CompanyWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name";
        }
        pub struct name_not;
        impl cynic::schema::HasInputField<name_not> for super::super::CompanyWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_not";
        }
        pub struct name_in;
        impl cynic::schema::HasInputField<name_in> for super::super::CompanyWhereInput {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "name_in";
        }
        pub struct name_not_in;
        impl cynic::schema::HasInputField<name_not_in> for super::super::CompanyWhereInput {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "name_not_in";
        }
        pub struct name_lt;
        impl cynic::schema::HasInputField<name_lt> for super::super::CompanyWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_lt";
        }
        pub struct name_lte;
        impl cynic::schema::HasInputField<name_lte> for super::super::CompanyWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_lte";
        }
        pub struct name_gt;
        impl cynic::schema::HasInputField<name_gt> for super::super::CompanyWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_gt";
        }
        pub struct name_gte;
        impl cynic::schema::HasInputField<name_gte> for super::super::CompanyWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_gte";
        }
        pub struct name_contains;
        impl cynic::schema::HasInputField<name_contains> for super::super::CompanyWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_contains";
        }
        pub struct name_not_contains;
        impl cynic::schema::HasInputField<name_not_contains> for super::super::CompanyWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_not_contains";
        }
        pub struct name_starts_with;
        impl cynic::schema::HasInputField<name_starts_with> for super::super::CompanyWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_starts_with";
        }
        pub struct name_not_starts_with;
        impl cynic::schema::HasInputField<name_not_starts_with> for super::super::CompanyWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_not_starts_with";
        }
        pub struct name_ends_with;
        impl cynic::schema::HasInputField<name_ends_with> for super::super::CompanyWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_ends_with";
        }
        pub struct name_not_ends_with;
        impl cynic::schema::HasInputField<name_not_ends_with> for super::super::CompanyWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_not_ends_with";
        }
        pub struct slug;
        impl cynic::schema::HasInputField<slug> for super::super::CompanyWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug";
        }
        pub struct slug_not;
        impl cynic::schema::HasInputField<slug_not> for super::super::CompanyWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_not";
        }
        pub struct slug_in;
        impl cynic::schema::HasInputField<slug_in> for super::super::CompanyWhereInput {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "slug_in";
        }
        pub struct slug_not_in;
        impl cynic::schema::HasInputField<slug_not_in> for super::super::CompanyWhereInput {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "slug_not_in";
        }
        pub struct slug_lt;
        impl cynic::schema::HasInputField<slug_lt> for super::super::CompanyWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_lt";
        }
        pub struct slug_lte;
        impl cynic::schema::HasInputField<slug_lte> for super::super::CompanyWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_lte";
        }
        pub struct slug_gt;
        impl cynic::schema::HasInputField<slug_gt> for super::super::CompanyWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_gt";
        }
        pub struct slug_gte;
        impl cynic::schema::HasInputField<slug_gte> for super::super::CompanyWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_gte";
        }
        pub struct slug_contains;
        impl cynic::schema::HasInputField<slug_contains> for super::super::CompanyWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_contains";
        }
        pub struct slug_not_contains;
        impl cynic::schema::HasInputField<slug_not_contains> for super::super::CompanyWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_not_contains";
        }
        pub struct slug_starts_with;
        impl cynic::schema::HasInputField<slug_starts_with> for super::super::CompanyWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_starts_with";
        }
        pub struct slug_not_starts_with;
        impl cynic::schema::HasInputField<slug_not_starts_with> for super::super::CompanyWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_not_starts_with";
        }
        pub struct slug_ends_with;
        impl cynic::schema::HasInputField<slug_ends_with> for super::super::CompanyWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_ends_with";
        }
        pub struct slug_not_ends_with;
        impl cynic::schema::HasInputField<slug_not_ends_with> for super::super::CompanyWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_not_ends_with";
        }
        pub struct websiteUrl;
        impl cynic::schema::HasInputField<websiteUrl> for super::super::CompanyWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "websiteUrl";
        }
        pub struct websiteUrl_not;
        impl cynic::schema::HasInputField<websiteUrl_not> for super::super::CompanyWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "websiteUrl_not";
        }
        pub struct websiteUrl_in;
        impl cynic::schema::HasInputField<websiteUrl_in> for super::super::CompanyWhereInput {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "websiteUrl_in";
        }
        pub struct websiteUrl_not_in;
        impl cynic::schema::HasInputField<websiteUrl_not_in> for super::super::CompanyWhereInput {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "websiteUrl_not_in";
        }
        pub struct websiteUrl_lt;
        impl cynic::schema::HasInputField<websiteUrl_lt> for super::super::CompanyWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "websiteUrl_lt";
        }
        pub struct websiteUrl_lte;
        impl cynic::schema::HasInputField<websiteUrl_lte> for super::super::CompanyWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "websiteUrl_lte";
        }
        pub struct websiteUrl_gt;
        impl cynic::schema::HasInputField<websiteUrl_gt> for super::super::CompanyWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "websiteUrl_gt";
        }
        pub struct websiteUrl_gte;
        impl cynic::schema::HasInputField<websiteUrl_gte> for super::super::CompanyWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "websiteUrl_gte";
        }
        pub struct websiteUrl_contains;
        impl cynic::schema::HasInputField<websiteUrl_contains> for super::super::CompanyWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "websiteUrl_contains";
        }
        pub struct websiteUrl_not_contains;
        impl cynic::schema::HasInputField<websiteUrl_not_contains> for super::super::CompanyWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "websiteUrl_not_contains";
        }
        pub struct websiteUrl_starts_with;
        impl cynic::schema::HasInputField<websiteUrl_starts_with> for super::super::CompanyWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "websiteUrl_starts_with";
        }
        pub struct websiteUrl_not_starts_with;
        impl cynic::schema::HasInputField<websiteUrl_not_starts_with> for super::super::CompanyWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "websiteUrl_not_starts_with";
        }
        pub struct websiteUrl_ends_with;
        impl cynic::schema::HasInputField<websiteUrl_ends_with> for super::super::CompanyWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "websiteUrl_ends_with";
        }
        pub struct websiteUrl_not_ends_with;
        impl cynic::schema::HasInputField<websiteUrl_not_ends_with> for super::super::CompanyWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "websiteUrl_not_ends_with";
        }
        pub struct logoUrl;
        impl cynic::schema::HasInputField<logoUrl> for super::super::CompanyWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "logoUrl";
        }
        pub struct logoUrl_not;
        impl cynic::schema::HasInputField<logoUrl_not> for super::super::CompanyWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "logoUrl_not";
        }
        pub struct logoUrl_in;
        impl cynic::schema::HasInputField<logoUrl_in> for super::super::CompanyWhereInput {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "logoUrl_in";
        }
        pub struct logoUrl_not_in;
        impl cynic::schema::HasInputField<logoUrl_not_in> for super::super::CompanyWhereInput {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "logoUrl_not_in";
        }
        pub struct logoUrl_lt;
        impl cynic::schema::HasInputField<logoUrl_lt> for super::super::CompanyWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "logoUrl_lt";
        }
        pub struct logoUrl_lte;
        impl cynic::schema::HasInputField<logoUrl_lte> for super::super::CompanyWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "logoUrl_lte";
        }
        pub struct logoUrl_gt;
        impl cynic::schema::HasInputField<logoUrl_gt> for super::super::CompanyWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "logoUrl_gt";
        }
        pub struct logoUrl_gte;
        impl cynic::schema::HasInputField<logoUrl_gte> for super::super::CompanyWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "logoUrl_gte";
        }
        pub struct logoUrl_contains;
        impl cynic::schema::HasInputField<logoUrl_contains> for super::super::CompanyWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "logoUrl_contains";
        }
        pub struct logoUrl_not_contains;
        impl cynic::schema::HasInputField<logoUrl_not_contains> for super::super::CompanyWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "logoUrl_not_contains";
        }
        pub struct logoUrl_starts_with;
        impl cynic::schema::HasInputField<logoUrl_starts_with> for super::super::CompanyWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "logoUrl_starts_with";
        }
        pub struct logoUrl_not_starts_with;
        impl cynic::schema::HasInputField<logoUrl_not_starts_with> for super::super::CompanyWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "logoUrl_not_starts_with";
        }
        pub struct logoUrl_ends_with;
        impl cynic::schema::HasInputField<logoUrl_ends_with> for super::super::CompanyWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "logoUrl_ends_with";
        }
        pub struct logoUrl_not_ends_with;
        impl cynic::schema::HasInputField<logoUrl_not_ends_with> for super::super::CompanyWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "logoUrl_not_ends_with";
        }
        pub struct jobs_every;
        impl cynic::schema::HasInputField<jobs_every> for super::super::CompanyWhereInput {
            type Type = Option<super::super::JobWhereInput>;
            const NAME: &'static str = "jobs_every";
        }
        pub struct jobs_some;
        impl cynic::schema::HasInputField<jobs_some> for super::super::CompanyWhereInput {
            type Type = Option<super::super::JobWhereInput>;
            const NAME: &'static str = "jobs_some";
        }
        pub struct jobs_none;
        impl cynic::schema::HasInputField<jobs_none> for super::super::CompanyWhereInput {
            type Type = Option<super::super::JobWhereInput>;
            const NAME: &'static str = "jobs_none";
        }
        pub struct twitter;
        impl cynic::schema::HasInputField<twitter> for super::super::CompanyWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "twitter";
        }
        pub struct twitter_not;
        impl cynic::schema::HasInputField<twitter_not> for super::super::CompanyWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "twitter_not";
        }
        pub struct twitter_in;
        impl cynic::schema::HasInputField<twitter_in> for super::super::CompanyWhereInput {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "twitter_in";
        }
        pub struct twitter_not_in;
        impl cynic::schema::HasInputField<twitter_not_in> for super::super::CompanyWhereInput {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "twitter_not_in";
        }
        pub struct twitter_lt;
        impl cynic::schema::HasInputField<twitter_lt> for super::super::CompanyWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "twitter_lt";
        }
        pub struct twitter_lte;
        impl cynic::schema::HasInputField<twitter_lte> for super::super::CompanyWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "twitter_lte";
        }
        pub struct twitter_gt;
        impl cynic::schema::HasInputField<twitter_gt> for super::super::CompanyWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "twitter_gt";
        }
        pub struct twitter_gte;
        impl cynic::schema::HasInputField<twitter_gte> for super::super::CompanyWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "twitter_gte";
        }
        pub struct twitter_contains;
        impl cynic::schema::HasInputField<twitter_contains> for super::super::CompanyWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "twitter_contains";
        }
        pub struct twitter_not_contains;
        impl cynic::schema::HasInputField<twitter_not_contains> for super::super::CompanyWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "twitter_not_contains";
        }
        pub struct twitter_starts_with;
        impl cynic::schema::HasInputField<twitter_starts_with> for super::super::CompanyWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "twitter_starts_with";
        }
        pub struct twitter_not_starts_with;
        impl cynic::schema::HasInputField<twitter_not_starts_with> for super::super::CompanyWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "twitter_not_starts_with";
        }
        pub struct twitter_ends_with;
        impl cynic::schema::HasInputField<twitter_ends_with> for super::super::CompanyWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "twitter_ends_with";
        }
        pub struct twitter_not_ends_with;
        impl cynic::schema::HasInputField<twitter_not_ends_with> for super::super::CompanyWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "twitter_not_ends_with";
        }
        pub struct emailed;
        impl cynic::schema::HasInputField<emailed> for super::super::CompanyWhereInput {
            type Type = Option<super::super::Boolean>;
            const NAME: &'static str = "emailed";
        }
        pub struct emailed_not;
        impl cynic::schema::HasInputField<emailed_not> for super::super::CompanyWhereInput {
            type Type = Option<super::super::Boolean>;
            const NAME: &'static str = "emailed_not";
        }
        pub struct createdAt;
        impl cynic::schema::HasInputField<createdAt> for super::super::CompanyWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt";
        }
        pub struct createdAt_not;
        impl cynic::schema::HasInputField<createdAt_not> for super::super::CompanyWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt_not";
        }
        pub struct createdAt_in;
        impl cynic::schema::HasInputField<createdAt_in> for super::super::CompanyWhereInput {
            type Type = Option<Vec<super::super::DateTime>>;
            const NAME: &'static str = "createdAt_in";
        }
        pub struct createdAt_not_in;
        impl cynic::schema::HasInputField<createdAt_not_in> for super::super::CompanyWhereInput {
            type Type = Option<Vec<super::super::DateTime>>;
            const NAME: &'static str = "createdAt_not_in";
        }
        pub struct createdAt_lt;
        impl cynic::schema::HasInputField<createdAt_lt> for super::super::CompanyWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt_lt";
        }
        pub struct createdAt_lte;
        impl cynic::schema::HasInputField<createdAt_lte> for super::super::CompanyWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt_lte";
        }
        pub struct createdAt_gt;
        impl cynic::schema::HasInputField<createdAt_gt> for super::super::CompanyWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt_gt";
        }
        pub struct createdAt_gte;
        impl cynic::schema::HasInputField<createdAt_gte> for super::super::CompanyWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt_gte";
        }
        pub struct updatedAt;
        impl cynic::schema::HasInputField<updatedAt> for super::super::CompanyWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt";
        }
        pub struct updatedAt_not;
        impl cynic::schema::HasInputField<updatedAt_not> for super::super::CompanyWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt_not";
        }
        pub struct updatedAt_in;
        impl cynic::schema::HasInputField<updatedAt_in> for super::super::CompanyWhereInput {
            type Type = Option<Vec<super::super::DateTime>>;
            const NAME: &'static str = "updatedAt_in";
        }
        pub struct updatedAt_not_in;
        impl cynic::schema::HasInputField<updatedAt_not_in> for super::super::CompanyWhereInput {
            type Type = Option<Vec<super::super::DateTime>>;
            const NAME: &'static str = "updatedAt_not_in";
        }
        pub struct updatedAt_lt;
        impl cynic::schema::HasInputField<updatedAt_lt> for super::super::CompanyWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt_lt";
        }
        pub struct updatedAt_lte;
        impl cynic::schema::HasInputField<updatedAt_lte> for super::super::CompanyWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt_lte";
        }
        pub struct updatedAt_gt;
        impl cynic::schema::HasInputField<updatedAt_gt> for super::super::CompanyWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt_gt";
        }
        pub struct updatedAt_gte;
        impl cynic::schema::HasInputField<updatedAt_gte> for super::super::CompanyWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt_gte";
        }
        pub struct AND;
        impl cynic::schema::HasInputField<AND> for super::super::CompanyWhereInput {
            type Type = Option<Vec<super::super::CompanyWhereInput>>;
            const NAME: &'static str = "AND";
        }
        pub struct OR;
        impl cynic::schema::HasInputField<OR> for super::super::CompanyWhereInput {
            type Type = Option<Vec<super::super::CompanyWhereInput>>;
            const NAME: &'static str = "OR";
        }
        pub struct NOT;
        impl cynic::schema::HasInputField<NOT> for super::super::CompanyWhereInput {
            type Type = Option<Vec<super::super::CompanyWhereInput>>;
            const NAME: &'static str = "NOT";
        }
    }
    pub mod Country {
        pub struct id;
        impl cynic::schema::HasField<id> for super::super::Country {
            type Type = super::super::ID;
            const NAME: &'static str = "id";
        }
        pub struct name;
        impl cynic::schema::HasField<name> for super::super::Country {
            type Type = super::super::String;
            const NAME: &'static str = "name";
        }
        pub struct slug;
        impl cynic::schema::HasField<slug> for super::super::Country {
            type Type = super::super::String;
            const NAME: &'static str = "slug";
        }
        pub struct r#type;
        impl cynic::schema::HasField<r#type> for super::super::Country {
            type Type = super::super::String;
            const NAME: &'static str = "type";
        }
        pub struct isoCode;
        impl cynic::schema::HasField<isoCode> for super::super::Country {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "isoCode";
        }
        pub struct cities;
        impl cynic::schema::HasField<cities> for super::super::Country {
            type Type = Option<Vec<super::super::City>>;
            const NAME: &'static str = "cities";
        }
        pub mod _cities_arguments {
            pub struct r#where;
            impl cynic::schema::HasArgument<r#where> for super::cities {
                type ArgumentType = Option<super::super::super::CityWhereInput>;
                const NAME: &'static str = "where";
            }
            pub struct orderBy;
            impl cynic::schema::HasArgument<orderBy> for super::cities {
                type ArgumentType = Option<super::super::super::CityOrderByInput>;
                const NAME: &'static str = "orderBy";
            }
            pub struct skip;
            impl cynic::schema::HasArgument<skip> for super::cities {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "skip";
            }
            pub struct after;
            impl cynic::schema::HasArgument<after> for super::cities {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "after";
            }
            pub struct before;
            impl cynic::schema::HasArgument<before> for super::cities {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "before";
            }
            pub struct first;
            impl cynic::schema::HasArgument<first> for super::cities {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "first";
            }
            pub struct last;
            impl cynic::schema::HasArgument<last> for super::cities {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "last";
            }
        }
        pub struct jobs;
        impl cynic::schema::HasField<jobs> for super::super::Country {
            type Type = Option<Vec<super::super::Job>>;
            const NAME: &'static str = "jobs";
        }
        pub mod _jobs_arguments {
            pub struct r#where;
            impl cynic::schema::HasArgument<r#where> for super::jobs {
                type ArgumentType = Option<super::super::super::JobWhereInput>;
                const NAME: &'static str = "where";
            }
            pub struct orderBy;
            impl cynic::schema::HasArgument<orderBy> for super::jobs {
                type ArgumentType = Option<super::super::super::JobOrderByInput>;
                const NAME: &'static str = "orderBy";
            }
            pub struct skip;
            impl cynic::schema::HasArgument<skip> for super::jobs {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "skip";
            }
            pub struct after;
            impl cynic::schema::HasArgument<after> for super::jobs {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "after";
            }
            pub struct before;
            impl cynic::schema::HasArgument<before> for super::jobs {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "before";
            }
            pub struct first;
            impl cynic::schema::HasArgument<first> for super::jobs {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "first";
            }
            pub struct last;
            impl cynic::schema::HasArgument<last> for super::jobs {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "last";
            }
        }
        pub struct createdAt;
        impl cynic::schema::HasField<createdAt> for super::super::Country {
            type Type = super::super::DateTime;
            const NAME: &'static str = "createdAt";
        }
        pub struct updatedAt;
        impl cynic::schema::HasField<updatedAt> for super::super::Country {
            type Type = super::super::DateTime;
            const NAME: &'static str = "updatedAt";
        }
        pub struct __typename;
        impl cynic::schema::HasField<__typename> for super::super::Country {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
    }
    pub mod CountryWhereInput {
        pub struct id;
        impl cynic::schema::HasInputField<id> for super::super::CountryWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id";
        }
        pub struct id_not;
        impl cynic::schema::HasInputField<id_not> for super::super::CountryWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_not";
        }
        pub struct id_in;
        impl cynic::schema::HasInputField<id_in> for super::super::CountryWhereInput {
            type Type = Option<Vec<super::super::ID>>;
            const NAME: &'static str = "id_in";
        }
        pub struct id_not_in;
        impl cynic::schema::HasInputField<id_not_in> for super::super::CountryWhereInput {
            type Type = Option<Vec<super::super::ID>>;
            const NAME: &'static str = "id_not_in";
        }
        pub struct id_lt;
        impl cynic::schema::HasInputField<id_lt> for super::super::CountryWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_lt";
        }
        pub struct id_lte;
        impl cynic::schema::HasInputField<id_lte> for super::super::CountryWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_lte";
        }
        pub struct id_gt;
        impl cynic::schema::HasInputField<id_gt> for super::super::CountryWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_gt";
        }
        pub struct id_gte;
        impl cynic::schema::HasInputField<id_gte> for super::super::CountryWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_gte";
        }
        pub struct id_contains;
        impl cynic::schema::HasInputField<id_contains> for super::super::CountryWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_contains";
        }
        pub struct id_not_contains;
        impl cynic::schema::HasInputField<id_not_contains> for super::super::CountryWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_not_contains";
        }
        pub struct id_starts_with;
        impl cynic::schema::HasInputField<id_starts_with> for super::super::CountryWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_starts_with";
        }
        pub struct id_not_starts_with;
        impl cynic::schema::HasInputField<id_not_starts_with> for super::super::CountryWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_not_starts_with";
        }
        pub struct id_ends_with;
        impl cynic::schema::HasInputField<id_ends_with> for super::super::CountryWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_ends_with";
        }
        pub struct id_not_ends_with;
        impl cynic::schema::HasInputField<id_not_ends_with> for super::super::CountryWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_not_ends_with";
        }
        pub struct name;
        impl cynic::schema::HasInputField<name> for super::super::CountryWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name";
        }
        pub struct name_not;
        impl cynic::schema::HasInputField<name_not> for super::super::CountryWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_not";
        }
        pub struct name_in;
        impl cynic::schema::HasInputField<name_in> for super::super::CountryWhereInput {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "name_in";
        }
        pub struct name_not_in;
        impl cynic::schema::HasInputField<name_not_in> for super::super::CountryWhereInput {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "name_not_in";
        }
        pub struct name_lt;
        impl cynic::schema::HasInputField<name_lt> for super::super::CountryWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_lt";
        }
        pub struct name_lte;
        impl cynic::schema::HasInputField<name_lte> for super::super::CountryWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_lte";
        }
        pub struct name_gt;
        impl cynic::schema::HasInputField<name_gt> for super::super::CountryWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_gt";
        }
        pub struct name_gte;
        impl cynic::schema::HasInputField<name_gte> for super::super::CountryWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_gte";
        }
        pub struct name_contains;
        impl cynic::schema::HasInputField<name_contains> for super::super::CountryWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_contains";
        }
        pub struct name_not_contains;
        impl cynic::schema::HasInputField<name_not_contains> for super::super::CountryWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_not_contains";
        }
        pub struct name_starts_with;
        impl cynic::schema::HasInputField<name_starts_with> for super::super::CountryWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_starts_with";
        }
        pub struct name_not_starts_with;
        impl cynic::schema::HasInputField<name_not_starts_with> for super::super::CountryWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_not_starts_with";
        }
        pub struct name_ends_with;
        impl cynic::schema::HasInputField<name_ends_with> for super::super::CountryWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_ends_with";
        }
        pub struct name_not_ends_with;
        impl cynic::schema::HasInputField<name_not_ends_with> for super::super::CountryWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_not_ends_with";
        }
        pub struct slug;
        impl cynic::schema::HasInputField<slug> for super::super::CountryWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug";
        }
        pub struct slug_not;
        impl cynic::schema::HasInputField<slug_not> for super::super::CountryWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_not";
        }
        pub struct slug_in;
        impl cynic::schema::HasInputField<slug_in> for super::super::CountryWhereInput {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "slug_in";
        }
        pub struct slug_not_in;
        impl cynic::schema::HasInputField<slug_not_in> for super::super::CountryWhereInput {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "slug_not_in";
        }
        pub struct slug_lt;
        impl cynic::schema::HasInputField<slug_lt> for super::super::CountryWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_lt";
        }
        pub struct slug_lte;
        impl cynic::schema::HasInputField<slug_lte> for super::super::CountryWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_lte";
        }
        pub struct slug_gt;
        impl cynic::schema::HasInputField<slug_gt> for super::super::CountryWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_gt";
        }
        pub struct slug_gte;
        impl cynic::schema::HasInputField<slug_gte> for super::super::CountryWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_gte";
        }
        pub struct slug_contains;
        impl cynic::schema::HasInputField<slug_contains> for super::super::CountryWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_contains";
        }
        pub struct slug_not_contains;
        impl cynic::schema::HasInputField<slug_not_contains> for super::super::CountryWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_not_contains";
        }
        pub struct slug_starts_with;
        impl cynic::schema::HasInputField<slug_starts_with> for super::super::CountryWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_starts_with";
        }
        pub struct slug_not_starts_with;
        impl cynic::schema::HasInputField<slug_not_starts_with> for super::super::CountryWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_not_starts_with";
        }
        pub struct slug_ends_with;
        impl cynic::schema::HasInputField<slug_ends_with> for super::super::CountryWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_ends_with";
        }
        pub struct slug_not_ends_with;
        impl cynic::schema::HasInputField<slug_not_ends_with> for super::super::CountryWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_not_ends_with";
        }
        pub struct r#type;
        impl cynic::schema::HasInputField<r#type> for super::super::CountryWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type";
        }
        pub struct type_not;
        impl cynic::schema::HasInputField<type_not> for super::super::CountryWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type_not";
        }
        pub struct type_in;
        impl cynic::schema::HasInputField<type_in> for super::super::CountryWhereInput {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "type_in";
        }
        pub struct type_not_in;
        impl cynic::schema::HasInputField<type_not_in> for super::super::CountryWhereInput {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "type_not_in";
        }
        pub struct type_lt;
        impl cynic::schema::HasInputField<type_lt> for super::super::CountryWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type_lt";
        }
        pub struct type_lte;
        impl cynic::schema::HasInputField<type_lte> for super::super::CountryWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type_lte";
        }
        pub struct type_gt;
        impl cynic::schema::HasInputField<type_gt> for super::super::CountryWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type_gt";
        }
        pub struct type_gte;
        impl cynic::schema::HasInputField<type_gte> for super::super::CountryWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type_gte";
        }
        pub struct type_contains;
        impl cynic::schema::HasInputField<type_contains> for super::super::CountryWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type_contains";
        }
        pub struct type_not_contains;
        impl cynic::schema::HasInputField<type_not_contains> for super::super::CountryWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type_not_contains";
        }
        pub struct type_starts_with;
        impl cynic::schema::HasInputField<type_starts_with> for super::super::CountryWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type_starts_with";
        }
        pub struct type_not_starts_with;
        impl cynic::schema::HasInputField<type_not_starts_with> for super::super::CountryWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type_not_starts_with";
        }
        pub struct type_ends_with;
        impl cynic::schema::HasInputField<type_ends_with> for super::super::CountryWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type_ends_with";
        }
        pub struct type_not_ends_with;
        impl cynic::schema::HasInputField<type_not_ends_with> for super::super::CountryWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type_not_ends_with";
        }
        pub struct isoCode;
        impl cynic::schema::HasInputField<isoCode> for super::super::CountryWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "isoCode";
        }
        pub struct isoCode_not;
        impl cynic::schema::HasInputField<isoCode_not> for super::super::CountryWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "isoCode_not";
        }
        pub struct isoCode_in;
        impl cynic::schema::HasInputField<isoCode_in> for super::super::CountryWhereInput {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "isoCode_in";
        }
        pub struct isoCode_not_in;
        impl cynic::schema::HasInputField<isoCode_not_in> for super::super::CountryWhereInput {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "isoCode_not_in";
        }
        pub struct isoCode_lt;
        impl cynic::schema::HasInputField<isoCode_lt> for super::super::CountryWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "isoCode_lt";
        }
        pub struct isoCode_lte;
        impl cynic::schema::HasInputField<isoCode_lte> for super::super::CountryWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "isoCode_lte";
        }
        pub struct isoCode_gt;
        impl cynic::schema::HasInputField<isoCode_gt> for super::super::CountryWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "isoCode_gt";
        }
        pub struct isoCode_gte;
        impl cynic::schema::HasInputField<isoCode_gte> for super::super::CountryWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "isoCode_gte";
        }
        pub struct isoCode_contains;
        impl cynic::schema::HasInputField<isoCode_contains> for super::super::CountryWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "isoCode_contains";
        }
        pub struct isoCode_not_contains;
        impl cynic::schema::HasInputField<isoCode_not_contains> for super::super::CountryWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "isoCode_not_contains";
        }
        pub struct isoCode_starts_with;
        impl cynic::schema::HasInputField<isoCode_starts_with> for super::super::CountryWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "isoCode_starts_with";
        }
        pub struct isoCode_not_starts_with;
        impl cynic::schema::HasInputField<isoCode_not_starts_with> for super::super::CountryWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "isoCode_not_starts_with";
        }
        pub struct isoCode_ends_with;
        impl cynic::schema::HasInputField<isoCode_ends_with> for super::super::CountryWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "isoCode_ends_with";
        }
        pub struct isoCode_not_ends_with;
        impl cynic::schema::HasInputField<isoCode_not_ends_with> for super::super::CountryWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "isoCode_not_ends_with";
        }
        pub struct cities_every;
        impl cynic::schema::HasInputField<cities_every> for super::super::CountryWhereInput {
            type Type = Option<super::super::CityWhereInput>;
            const NAME: &'static str = "cities_every";
        }
        pub struct cities_some;
        impl cynic::schema::HasInputField<cities_some> for super::super::CountryWhereInput {
            type Type = Option<super::super::CityWhereInput>;
            const NAME: &'static str = "cities_some";
        }
        pub struct cities_none;
        impl cynic::schema::HasInputField<cities_none> for super::super::CountryWhereInput {
            type Type = Option<super::super::CityWhereInput>;
            const NAME: &'static str = "cities_none";
        }
        pub struct jobs_every;
        impl cynic::schema::HasInputField<jobs_every> for super::super::CountryWhereInput {
            type Type = Option<super::super::JobWhereInput>;
            const NAME: &'static str = "jobs_every";
        }
        pub struct jobs_some;
        impl cynic::schema::HasInputField<jobs_some> for super::super::CountryWhereInput {
            type Type = Option<super::super::JobWhereInput>;
            const NAME: &'static str = "jobs_some";
        }
        pub struct jobs_none;
        impl cynic::schema::HasInputField<jobs_none> for super::super::CountryWhereInput {
            type Type = Option<super::super::JobWhereInput>;
            const NAME: &'static str = "jobs_none";
        }
        pub struct createdAt;
        impl cynic::schema::HasInputField<createdAt> for super::super::CountryWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt";
        }
        pub struct createdAt_not;
        impl cynic::schema::HasInputField<createdAt_not> for super::super::CountryWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt_not";
        }
        pub struct createdAt_in;
        impl cynic::schema::HasInputField<createdAt_in> for super::super::CountryWhereInput {
            type Type = Option<Vec<super::super::DateTime>>;
            const NAME: &'static str = "createdAt_in";
        }
        pub struct createdAt_not_in;
        impl cynic::schema::HasInputField<createdAt_not_in> for super::super::CountryWhereInput {
            type Type = Option<Vec<super::super::DateTime>>;
            const NAME: &'static str = "createdAt_not_in";
        }
        pub struct createdAt_lt;
        impl cynic::schema::HasInputField<createdAt_lt> for super::super::CountryWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt_lt";
        }
        pub struct createdAt_lte;
        impl cynic::schema::HasInputField<createdAt_lte> for super::super::CountryWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt_lte";
        }
        pub struct createdAt_gt;
        impl cynic::schema::HasInputField<createdAt_gt> for super::super::CountryWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt_gt";
        }
        pub struct createdAt_gte;
        impl cynic::schema::HasInputField<createdAt_gte> for super::super::CountryWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt_gte";
        }
        pub struct updatedAt;
        impl cynic::schema::HasInputField<updatedAt> for super::super::CountryWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt";
        }
        pub struct updatedAt_not;
        impl cynic::schema::HasInputField<updatedAt_not> for super::super::CountryWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt_not";
        }
        pub struct updatedAt_in;
        impl cynic::schema::HasInputField<updatedAt_in> for super::super::CountryWhereInput {
            type Type = Option<Vec<super::super::DateTime>>;
            const NAME: &'static str = "updatedAt_in";
        }
        pub struct updatedAt_not_in;
        impl cynic::schema::HasInputField<updatedAt_not_in> for super::super::CountryWhereInput {
            type Type = Option<Vec<super::super::DateTime>>;
            const NAME: &'static str = "updatedAt_not_in";
        }
        pub struct updatedAt_lt;
        impl cynic::schema::HasInputField<updatedAt_lt> for super::super::CountryWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt_lt";
        }
        pub struct updatedAt_lte;
        impl cynic::schema::HasInputField<updatedAt_lte> for super::super::CountryWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt_lte";
        }
        pub struct updatedAt_gt;
        impl cynic::schema::HasInputField<updatedAt_gt> for super::super::CountryWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt_gt";
        }
        pub struct updatedAt_gte;
        impl cynic::schema::HasInputField<updatedAt_gte> for super::super::CountryWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt_gte";
        }
        pub struct AND;
        impl cynic::schema::HasInputField<AND> for super::super::CountryWhereInput {
            type Type = Option<Vec<super::super::CountryWhereInput>>;
            const NAME: &'static str = "AND";
        }
        pub struct OR;
        impl cynic::schema::HasInputField<OR> for super::super::CountryWhereInput {
            type Type = Option<Vec<super::super::CountryWhereInput>>;
            const NAME: &'static str = "OR";
        }
        pub struct NOT;
        impl cynic::schema::HasInputField<NOT> for super::super::CountryWhereInput {
            type Type = Option<Vec<super::super::CountryWhereInput>>;
            const NAME: &'static str = "NOT";
        }
    }
    pub mod Job {
        pub struct id;
        impl cynic::schema::HasField<id> for super::super::Job {
            type Type = super::super::ID;
            const NAME: &'static str = "id";
        }
        pub struct title;
        impl cynic::schema::HasField<title> for super::super::Job {
            type Type = super::super::String;
            const NAME: &'static str = "title";
        }
        pub struct slug;
        impl cynic::schema::HasField<slug> for super::super::Job {
            type Type = super::super::String;
            const NAME: &'static str = "slug";
        }
        pub struct commitment;
        impl cynic::schema::HasField<commitment> for super::super::Job {
            type Type = super::super::Commitment;
            const NAME: &'static str = "commitment";
        }
        pub struct cities;
        impl cynic::schema::HasField<cities> for super::super::Job {
            type Type = Option<Vec<super::super::City>>;
            const NAME: &'static str = "cities";
        }
        pub mod _cities_arguments {
            pub struct r#where;
            impl cynic::schema::HasArgument<r#where> for super::cities {
                type ArgumentType = Option<super::super::super::CityWhereInput>;
                const NAME: &'static str = "where";
            }
            pub struct orderBy;
            impl cynic::schema::HasArgument<orderBy> for super::cities {
                type ArgumentType = Option<super::super::super::CityOrderByInput>;
                const NAME: &'static str = "orderBy";
            }
            pub struct skip;
            impl cynic::schema::HasArgument<skip> for super::cities {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "skip";
            }
            pub struct after;
            impl cynic::schema::HasArgument<after> for super::cities {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "after";
            }
            pub struct before;
            impl cynic::schema::HasArgument<before> for super::cities {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "before";
            }
            pub struct first;
            impl cynic::schema::HasArgument<first> for super::cities {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "first";
            }
            pub struct last;
            impl cynic::schema::HasArgument<last> for super::cities {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "last";
            }
        }
        pub struct countries;
        impl cynic::schema::HasField<countries> for super::super::Job {
            type Type = Option<Vec<super::super::Country>>;
            const NAME: &'static str = "countries";
        }
        pub mod _countries_arguments {
            pub struct r#where;
            impl cynic::schema::HasArgument<r#where> for super::countries {
                type ArgumentType = Option<super::super::super::CountryWhereInput>;
                const NAME: &'static str = "where";
            }
            pub struct orderBy;
            impl cynic::schema::HasArgument<orderBy> for super::countries {
                type ArgumentType = Option<super::super::super::CountryOrderByInput>;
                const NAME: &'static str = "orderBy";
            }
            pub struct skip;
            impl cynic::schema::HasArgument<skip> for super::countries {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "skip";
            }
            pub struct after;
            impl cynic::schema::HasArgument<after> for super::countries {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "after";
            }
            pub struct before;
            impl cynic::schema::HasArgument<before> for super::countries {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "before";
            }
            pub struct first;
            impl cynic::schema::HasArgument<first> for super::countries {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "first";
            }
            pub struct last;
            impl cynic::schema::HasArgument<last> for super::countries {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "last";
            }
        }
        pub struct remotes;
        impl cynic::schema::HasField<remotes> for super::super::Job {
            type Type = Option<Vec<super::super::Remote>>;
            const NAME: &'static str = "remotes";
        }
        pub mod _remotes_arguments {
            pub struct r#where;
            impl cynic::schema::HasArgument<r#where> for super::remotes {
                type ArgumentType = Option<super::super::super::RemoteWhereInput>;
                const NAME: &'static str = "where";
            }
            pub struct orderBy;
            impl cynic::schema::HasArgument<orderBy> for super::remotes {
                type ArgumentType = Option<super::super::super::RemoteOrderByInput>;
                const NAME: &'static str = "orderBy";
            }
            pub struct skip;
            impl cynic::schema::HasArgument<skip> for super::remotes {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "skip";
            }
            pub struct after;
            impl cynic::schema::HasArgument<after> for super::remotes {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "after";
            }
            pub struct before;
            impl cynic::schema::HasArgument<before> for super::remotes {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "before";
            }
            pub struct first;
            impl cynic::schema::HasArgument<first> for super::remotes {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "first";
            }
            pub struct last;
            impl cynic::schema::HasArgument<last> for super::remotes {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "last";
            }
        }
        pub struct description;
        impl cynic::schema::HasField<description> for super::super::Job {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "description";
        }
        pub struct applyUrl;
        impl cynic::schema::HasField<applyUrl> for super::super::Job {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "applyUrl";
        }
        pub struct company;
        impl cynic::schema::HasField<company> for super::super::Job {
            type Type = Option<super::super::Company>;
            const NAME: &'static str = "company";
        }
        pub struct tags;
        impl cynic::schema::HasField<tags> for super::super::Job {
            type Type = Option<Vec<super::super::Tag>>;
            const NAME: &'static str = "tags";
        }
        pub mod _tags_arguments {
            pub struct r#where;
            impl cynic::schema::HasArgument<r#where> for super::tags {
                type ArgumentType = Option<super::super::super::TagWhereInput>;
                const NAME: &'static str = "where";
            }
            pub struct orderBy;
            impl cynic::schema::HasArgument<orderBy> for super::tags {
                type ArgumentType = Option<super::super::super::TagOrderByInput>;
                const NAME: &'static str = "orderBy";
            }
            pub struct skip;
            impl cynic::schema::HasArgument<skip> for super::tags {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "skip";
            }
            pub struct after;
            impl cynic::schema::HasArgument<after> for super::tags {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "after";
            }
            pub struct before;
            impl cynic::schema::HasArgument<before> for super::tags {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "before";
            }
            pub struct first;
            impl cynic::schema::HasArgument<first> for super::tags {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "first";
            }
            pub struct last;
            impl cynic::schema::HasArgument<last> for super::tags {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "last";
            }
        }
        pub struct isPublished;
        impl cynic::schema::HasField<isPublished> for super::super::Job {
            type Type = Option<super::super::Boolean>;
            const NAME: &'static str = "isPublished";
        }
        pub struct isFeatured;
        impl cynic::schema::HasField<isFeatured> for super::super::Job {
            type Type = Option<super::super::Boolean>;
            const NAME: &'static str = "isFeatured";
        }
        pub struct locationNames;
        impl cynic::schema::HasField<locationNames> for super::super::Job {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "locationNames";
        }
        pub struct userEmail;
        impl cynic::schema::HasField<userEmail> for super::super::Job {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "userEmail";
        }
        pub struct postedAt;
        impl cynic::schema::HasField<postedAt> for super::super::Job {
            type Type = super::super::DateTime;
            const NAME: &'static str = "postedAt";
        }
        pub struct createdAt;
        impl cynic::schema::HasField<createdAt> for super::super::Job {
            type Type = super::super::DateTime;
            const NAME: &'static str = "createdAt";
        }
        pub struct updatedAt;
        impl cynic::schema::HasField<updatedAt> for super::super::Job {
            type Type = super::super::DateTime;
            const NAME: &'static str = "updatedAt";
        }
        pub struct __typename;
        impl cynic::schema::HasField<__typename> for super::super::Job {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
    }
    pub mod JobInput {
        pub struct companySlug;
        impl cynic::schema::HasInputField<companySlug> for super::super::JobInput {
            type Type = super::super::String;
            const NAME: &'static str = "companySlug";
        }
        pub struct jobSlug;
        impl cynic::schema::HasInputField<jobSlug> for super::super::JobInput {
            type Type = super::super::String;
            const NAME: &'static str = "jobSlug";
        }
    }
    pub mod JobWhereInput {
        pub struct id;
        impl cynic::schema::HasInputField<id> for super::super::JobWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id";
        }
        pub struct id_not;
        impl cynic::schema::HasInputField<id_not> for super::super::JobWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_not";
        }
        pub struct id_in;
        impl cynic::schema::HasInputField<id_in> for super::super::JobWhereInput {
            type Type = Option<Vec<super::super::ID>>;
            const NAME: &'static str = "id_in";
        }
        pub struct id_not_in;
        impl cynic::schema::HasInputField<id_not_in> for super::super::JobWhereInput {
            type Type = Option<Vec<super::super::ID>>;
            const NAME: &'static str = "id_not_in";
        }
        pub struct id_lt;
        impl cynic::schema::HasInputField<id_lt> for super::super::JobWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_lt";
        }
        pub struct id_lte;
        impl cynic::schema::HasInputField<id_lte> for super::super::JobWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_lte";
        }
        pub struct id_gt;
        impl cynic::schema::HasInputField<id_gt> for super::super::JobWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_gt";
        }
        pub struct id_gte;
        impl cynic::schema::HasInputField<id_gte> for super::super::JobWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_gte";
        }
        pub struct id_contains;
        impl cynic::schema::HasInputField<id_contains> for super::super::JobWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_contains";
        }
        pub struct id_not_contains;
        impl cynic::schema::HasInputField<id_not_contains> for super::super::JobWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_not_contains";
        }
        pub struct id_starts_with;
        impl cynic::schema::HasInputField<id_starts_with> for super::super::JobWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_starts_with";
        }
        pub struct id_not_starts_with;
        impl cynic::schema::HasInputField<id_not_starts_with> for super::super::JobWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_not_starts_with";
        }
        pub struct id_ends_with;
        impl cynic::schema::HasInputField<id_ends_with> for super::super::JobWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_ends_with";
        }
        pub struct id_not_ends_with;
        impl cynic::schema::HasInputField<id_not_ends_with> for super::super::JobWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_not_ends_with";
        }
        pub struct title;
        impl cynic::schema::HasInputField<title> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "title";
        }
        pub struct title_not;
        impl cynic::schema::HasInputField<title_not> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "title_not";
        }
        pub struct title_in;
        impl cynic::schema::HasInputField<title_in> for super::super::JobWhereInput {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "title_in";
        }
        pub struct title_not_in;
        impl cynic::schema::HasInputField<title_not_in> for super::super::JobWhereInput {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "title_not_in";
        }
        pub struct title_lt;
        impl cynic::schema::HasInputField<title_lt> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "title_lt";
        }
        pub struct title_lte;
        impl cynic::schema::HasInputField<title_lte> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "title_lte";
        }
        pub struct title_gt;
        impl cynic::schema::HasInputField<title_gt> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "title_gt";
        }
        pub struct title_gte;
        impl cynic::schema::HasInputField<title_gte> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "title_gte";
        }
        pub struct title_contains;
        impl cynic::schema::HasInputField<title_contains> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "title_contains";
        }
        pub struct title_not_contains;
        impl cynic::schema::HasInputField<title_not_contains> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "title_not_contains";
        }
        pub struct title_starts_with;
        impl cynic::schema::HasInputField<title_starts_with> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "title_starts_with";
        }
        pub struct title_not_starts_with;
        impl cynic::schema::HasInputField<title_not_starts_with> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "title_not_starts_with";
        }
        pub struct title_ends_with;
        impl cynic::schema::HasInputField<title_ends_with> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "title_ends_with";
        }
        pub struct title_not_ends_with;
        impl cynic::schema::HasInputField<title_not_ends_with> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "title_not_ends_with";
        }
        pub struct slug;
        impl cynic::schema::HasInputField<slug> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug";
        }
        pub struct slug_not;
        impl cynic::schema::HasInputField<slug_not> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_not";
        }
        pub struct slug_in;
        impl cynic::schema::HasInputField<slug_in> for super::super::JobWhereInput {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "slug_in";
        }
        pub struct slug_not_in;
        impl cynic::schema::HasInputField<slug_not_in> for super::super::JobWhereInput {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "slug_not_in";
        }
        pub struct slug_lt;
        impl cynic::schema::HasInputField<slug_lt> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_lt";
        }
        pub struct slug_lte;
        impl cynic::schema::HasInputField<slug_lte> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_lte";
        }
        pub struct slug_gt;
        impl cynic::schema::HasInputField<slug_gt> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_gt";
        }
        pub struct slug_gte;
        impl cynic::schema::HasInputField<slug_gte> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_gte";
        }
        pub struct slug_contains;
        impl cynic::schema::HasInputField<slug_contains> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_contains";
        }
        pub struct slug_not_contains;
        impl cynic::schema::HasInputField<slug_not_contains> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_not_contains";
        }
        pub struct slug_starts_with;
        impl cynic::schema::HasInputField<slug_starts_with> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_starts_with";
        }
        pub struct slug_not_starts_with;
        impl cynic::schema::HasInputField<slug_not_starts_with> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_not_starts_with";
        }
        pub struct slug_ends_with;
        impl cynic::schema::HasInputField<slug_ends_with> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_ends_with";
        }
        pub struct slug_not_ends_with;
        impl cynic::schema::HasInputField<slug_not_ends_with> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_not_ends_with";
        }
        pub struct commitment;
        impl cynic::schema::HasInputField<commitment> for super::super::JobWhereInput {
            type Type = Option<super::super::CommitmentWhereInput>;
            const NAME: &'static str = "commitment";
        }
        pub struct cities_every;
        impl cynic::schema::HasInputField<cities_every> for super::super::JobWhereInput {
            type Type = Option<super::super::CityWhereInput>;
            const NAME: &'static str = "cities_every";
        }
        pub struct cities_some;
        impl cynic::schema::HasInputField<cities_some> for super::super::JobWhereInput {
            type Type = Option<super::super::CityWhereInput>;
            const NAME: &'static str = "cities_some";
        }
        pub struct cities_none;
        impl cynic::schema::HasInputField<cities_none> for super::super::JobWhereInput {
            type Type = Option<super::super::CityWhereInput>;
            const NAME: &'static str = "cities_none";
        }
        pub struct countries_every;
        impl cynic::schema::HasInputField<countries_every> for super::super::JobWhereInput {
            type Type = Option<super::super::CountryWhereInput>;
            const NAME: &'static str = "countries_every";
        }
        pub struct countries_some;
        impl cynic::schema::HasInputField<countries_some> for super::super::JobWhereInput {
            type Type = Option<super::super::CountryWhereInput>;
            const NAME: &'static str = "countries_some";
        }
        pub struct countries_none;
        impl cynic::schema::HasInputField<countries_none> for super::super::JobWhereInput {
            type Type = Option<super::super::CountryWhereInput>;
            const NAME: &'static str = "countries_none";
        }
        pub struct remotes_every;
        impl cynic::schema::HasInputField<remotes_every> for super::super::JobWhereInput {
            type Type = Option<super::super::RemoteWhereInput>;
            const NAME: &'static str = "remotes_every";
        }
        pub struct remotes_some;
        impl cynic::schema::HasInputField<remotes_some> for super::super::JobWhereInput {
            type Type = Option<super::super::RemoteWhereInput>;
            const NAME: &'static str = "remotes_some";
        }
        pub struct remotes_none;
        impl cynic::schema::HasInputField<remotes_none> for super::super::JobWhereInput {
            type Type = Option<super::super::RemoteWhereInput>;
            const NAME: &'static str = "remotes_none";
        }
        pub struct description;
        impl cynic::schema::HasInputField<description> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "description";
        }
        pub struct description_not;
        impl cynic::schema::HasInputField<description_not> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "description_not";
        }
        pub struct description_in;
        impl cynic::schema::HasInputField<description_in> for super::super::JobWhereInput {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "description_in";
        }
        pub struct description_not_in;
        impl cynic::schema::HasInputField<description_not_in> for super::super::JobWhereInput {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "description_not_in";
        }
        pub struct description_lt;
        impl cynic::schema::HasInputField<description_lt> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "description_lt";
        }
        pub struct description_lte;
        impl cynic::schema::HasInputField<description_lte> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "description_lte";
        }
        pub struct description_gt;
        impl cynic::schema::HasInputField<description_gt> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "description_gt";
        }
        pub struct description_gte;
        impl cynic::schema::HasInputField<description_gte> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "description_gte";
        }
        pub struct description_contains;
        impl cynic::schema::HasInputField<description_contains> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "description_contains";
        }
        pub struct description_not_contains;
        impl cynic::schema::HasInputField<description_not_contains> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "description_not_contains";
        }
        pub struct description_starts_with;
        impl cynic::schema::HasInputField<description_starts_with> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "description_starts_with";
        }
        pub struct description_not_starts_with;
        impl cynic::schema::HasInputField<description_not_starts_with> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "description_not_starts_with";
        }
        pub struct description_ends_with;
        impl cynic::schema::HasInputField<description_ends_with> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "description_ends_with";
        }
        pub struct description_not_ends_with;
        impl cynic::schema::HasInputField<description_not_ends_with> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "description_not_ends_with";
        }
        pub struct applyUrl;
        impl cynic::schema::HasInputField<applyUrl> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "applyUrl";
        }
        pub struct applyUrl_not;
        impl cynic::schema::HasInputField<applyUrl_not> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "applyUrl_not";
        }
        pub struct applyUrl_in;
        impl cynic::schema::HasInputField<applyUrl_in> for super::super::JobWhereInput {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "applyUrl_in";
        }
        pub struct applyUrl_not_in;
        impl cynic::schema::HasInputField<applyUrl_not_in> for super::super::JobWhereInput {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "applyUrl_not_in";
        }
        pub struct applyUrl_lt;
        impl cynic::schema::HasInputField<applyUrl_lt> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "applyUrl_lt";
        }
        pub struct applyUrl_lte;
        impl cynic::schema::HasInputField<applyUrl_lte> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "applyUrl_lte";
        }
        pub struct applyUrl_gt;
        impl cynic::schema::HasInputField<applyUrl_gt> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "applyUrl_gt";
        }
        pub struct applyUrl_gte;
        impl cynic::schema::HasInputField<applyUrl_gte> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "applyUrl_gte";
        }
        pub struct applyUrl_contains;
        impl cynic::schema::HasInputField<applyUrl_contains> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "applyUrl_contains";
        }
        pub struct applyUrl_not_contains;
        impl cynic::schema::HasInputField<applyUrl_not_contains> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "applyUrl_not_contains";
        }
        pub struct applyUrl_starts_with;
        impl cynic::schema::HasInputField<applyUrl_starts_with> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "applyUrl_starts_with";
        }
        pub struct applyUrl_not_starts_with;
        impl cynic::schema::HasInputField<applyUrl_not_starts_with> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "applyUrl_not_starts_with";
        }
        pub struct applyUrl_ends_with;
        impl cynic::schema::HasInputField<applyUrl_ends_with> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "applyUrl_ends_with";
        }
        pub struct applyUrl_not_ends_with;
        impl cynic::schema::HasInputField<applyUrl_not_ends_with> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "applyUrl_not_ends_with";
        }
        pub struct company;
        impl cynic::schema::HasInputField<company> for super::super::JobWhereInput {
            type Type = Option<super::super::CompanyWhereInput>;
            const NAME: &'static str = "company";
        }
        pub struct tags_every;
        impl cynic::schema::HasInputField<tags_every> for super::super::JobWhereInput {
            type Type = Option<super::super::TagWhereInput>;
            const NAME: &'static str = "tags_every";
        }
        pub struct tags_some;
        impl cynic::schema::HasInputField<tags_some> for super::super::JobWhereInput {
            type Type = Option<super::super::TagWhereInput>;
            const NAME: &'static str = "tags_some";
        }
        pub struct tags_none;
        impl cynic::schema::HasInputField<tags_none> for super::super::JobWhereInput {
            type Type = Option<super::super::TagWhereInput>;
            const NAME: &'static str = "tags_none";
        }
        pub struct isPublished;
        impl cynic::schema::HasInputField<isPublished> for super::super::JobWhereInput {
            type Type = Option<super::super::Boolean>;
            const NAME: &'static str = "isPublished";
        }
        pub struct isPublished_not;
        impl cynic::schema::HasInputField<isPublished_not> for super::super::JobWhereInput {
            type Type = Option<super::super::Boolean>;
            const NAME: &'static str = "isPublished_not";
        }
        pub struct isFeatured;
        impl cynic::schema::HasInputField<isFeatured> for super::super::JobWhereInput {
            type Type = Option<super::super::Boolean>;
            const NAME: &'static str = "isFeatured";
        }
        pub struct isFeatured_not;
        impl cynic::schema::HasInputField<isFeatured_not> for super::super::JobWhereInput {
            type Type = Option<super::super::Boolean>;
            const NAME: &'static str = "isFeatured_not";
        }
        pub struct locationNames;
        impl cynic::schema::HasInputField<locationNames> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "locationNames";
        }
        pub struct locationNames_not;
        impl cynic::schema::HasInputField<locationNames_not> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "locationNames_not";
        }
        pub struct locationNames_in;
        impl cynic::schema::HasInputField<locationNames_in> for super::super::JobWhereInput {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "locationNames_in";
        }
        pub struct locationNames_not_in;
        impl cynic::schema::HasInputField<locationNames_not_in> for super::super::JobWhereInput {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "locationNames_not_in";
        }
        pub struct locationNames_lt;
        impl cynic::schema::HasInputField<locationNames_lt> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "locationNames_lt";
        }
        pub struct locationNames_lte;
        impl cynic::schema::HasInputField<locationNames_lte> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "locationNames_lte";
        }
        pub struct locationNames_gt;
        impl cynic::schema::HasInputField<locationNames_gt> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "locationNames_gt";
        }
        pub struct locationNames_gte;
        impl cynic::schema::HasInputField<locationNames_gte> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "locationNames_gte";
        }
        pub struct locationNames_contains;
        impl cynic::schema::HasInputField<locationNames_contains> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "locationNames_contains";
        }
        pub struct locationNames_not_contains;
        impl cynic::schema::HasInputField<locationNames_not_contains> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "locationNames_not_contains";
        }
        pub struct locationNames_starts_with;
        impl cynic::schema::HasInputField<locationNames_starts_with> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "locationNames_starts_with";
        }
        pub struct locationNames_not_starts_with;
        impl cynic::schema::HasInputField<locationNames_not_starts_with> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "locationNames_not_starts_with";
        }
        pub struct locationNames_ends_with;
        impl cynic::schema::HasInputField<locationNames_ends_with> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "locationNames_ends_with";
        }
        pub struct locationNames_not_ends_with;
        impl cynic::schema::HasInputField<locationNames_not_ends_with> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "locationNames_not_ends_with";
        }
        pub struct userEmail;
        impl cynic::schema::HasInputField<userEmail> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "userEmail";
        }
        pub struct userEmail_not;
        impl cynic::schema::HasInputField<userEmail_not> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "userEmail_not";
        }
        pub struct userEmail_in;
        impl cynic::schema::HasInputField<userEmail_in> for super::super::JobWhereInput {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "userEmail_in";
        }
        pub struct userEmail_not_in;
        impl cynic::schema::HasInputField<userEmail_not_in> for super::super::JobWhereInput {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "userEmail_not_in";
        }
        pub struct userEmail_lt;
        impl cynic::schema::HasInputField<userEmail_lt> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "userEmail_lt";
        }
        pub struct userEmail_lte;
        impl cynic::schema::HasInputField<userEmail_lte> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "userEmail_lte";
        }
        pub struct userEmail_gt;
        impl cynic::schema::HasInputField<userEmail_gt> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "userEmail_gt";
        }
        pub struct userEmail_gte;
        impl cynic::schema::HasInputField<userEmail_gte> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "userEmail_gte";
        }
        pub struct userEmail_contains;
        impl cynic::schema::HasInputField<userEmail_contains> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "userEmail_contains";
        }
        pub struct userEmail_not_contains;
        impl cynic::schema::HasInputField<userEmail_not_contains> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "userEmail_not_contains";
        }
        pub struct userEmail_starts_with;
        impl cynic::schema::HasInputField<userEmail_starts_with> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "userEmail_starts_with";
        }
        pub struct userEmail_not_starts_with;
        impl cynic::schema::HasInputField<userEmail_not_starts_with> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "userEmail_not_starts_with";
        }
        pub struct userEmail_ends_with;
        impl cynic::schema::HasInputField<userEmail_ends_with> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "userEmail_ends_with";
        }
        pub struct userEmail_not_ends_with;
        impl cynic::schema::HasInputField<userEmail_not_ends_with> for super::super::JobWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "userEmail_not_ends_with";
        }
        pub struct postedAt;
        impl cynic::schema::HasInputField<postedAt> for super::super::JobWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "postedAt";
        }
        pub struct postedAt_not;
        impl cynic::schema::HasInputField<postedAt_not> for super::super::JobWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "postedAt_not";
        }
        pub struct postedAt_in;
        impl cynic::schema::HasInputField<postedAt_in> for super::super::JobWhereInput {
            type Type = Option<Vec<super::super::DateTime>>;
            const NAME: &'static str = "postedAt_in";
        }
        pub struct postedAt_not_in;
        impl cynic::schema::HasInputField<postedAt_not_in> for super::super::JobWhereInput {
            type Type = Option<Vec<super::super::DateTime>>;
            const NAME: &'static str = "postedAt_not_in";
        }
        pub struct postedAt_lt;
        impl cynic::schema::HasInputField<postedAt_lt> for super::super::JobWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "postedAt_lt";
        }
        pub struct postedAt_lte;
        impl cynic::schema::HasInputField<postedAt_lte> for super::super::JobWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "postedAt_lte";
        }
        pub struct postedAt_gt;
        impl cynic::schema::HasInputField<postedAt_gt> for super::super::JobWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "postedAt_gt";
        }
        pub struct postedAt_gte;
        impl cynic::schema::HasInputField<postedAt_gte> for super::super::JobWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "postedAt_gte";
        }
        pub struct createdAt;
        impl cynic::schema::HasInputField<createdAt> for super::super::JobWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt";
        }
        pub struct createdAt_not;
        impl cynic::schema::HasInputField<createdAt_not> for super::super::JobWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt_not";
        }
        pub struct createdAt_in;
        impl cynic::schema::HasInputField<createdAt_in> for super::super::JobWhereInput {
            type Type = Option<Vec<super::super::DateTime>>;
            const NAME: &'static str = "createdAt_in";
        }
        pub struct createdAt_not_in;
        impl cynic::schema::HasInputField<createdAt_not_in> for super::super::JobWhereInput {
            type Type = Option<Vec<super::super::DateTime>>;
            const NAME: &'static str = "createdAt_not_in";
        }
        pub struct createdAt_lt;
        impl cynic::schema::HasInputField<createdAt_lt> for super::super::JobWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt_lt";
        }
        pub struct createdAt_lte;
        impl cynic::schema::HasInputField<createdAt_lte> for super::super::JobWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt_lte";
        }
        pub struct createdAt_gt;
        impl cynic::schema::HasInputField<createdAt_gt> for super::super::JobWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt_gt";
        }
        pub struct createdAt_gte;
        impl cynic::schema::HasInputField<createdAt_gte> for super::super::JobWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt_gte";
        }
        pub struct updatedAt;
        impl cynic::schema::HasInputField<updatedAt> for super::super::JobWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt";
        }
        pub struct updatedAt_not;
        impl cynic::schema::HasInputField<updatedAt_not> for super::super::JobWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt_not";
        }
        pub struct updatedAt_in;
        impl cynic::schema::HasInputField<updatedAt_in> for super::super::JobWhereInput {
            type Type = Option<Vec<super::super::DateTime>>;
            const NAME: &'static str = "updatedAt_in";
        }
        pub struct updatedAt_not_in;
        impl cynic::schema::HasInputField<updatedAt_not_in> for super::super::JobWhereInput {
            type Type = Option<Vec<super::super::DateTime>>;
            const NAME: &'static str = "updatedAt_not_in";
        }
        pub struct updatedAt_lt;
        impl cynic::schema::HasInputField<updatedAt_lt> for super::super::JobWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt_lt";
        }
        pub struct updatedAt_lte;
        impl cynic::schema::HasInputField<updatedAt_lte> for super::super::JobWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt_lte";
        }
        pub struct updatedAt_gt;
        impl cynic::schema::HasInputField<updatedAt_gt> for super::super::JobWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt_gt";
        }
        pub struct updatedAt_gte;
        impl cynic::schema::HasInputField<updatedAt_gte> for super::super::JobWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt_gte";
        }
        pub struct AND;
        impl cynic::schema::HasInputField<AND> for super::super::JobWhereInput {
            type Type = Option<Vec<super::super::JobWhereInput>>;
            const NAME: &'static str = "AND";
        }
        pub struct OR;
        impl cynic::schema::HasInputField<OR> for super::super::JobWhereInput {
            type Type = Option<Vec<super::super::JobWhereInput>>;
            const NAME: &'static str = "OR";
        }
        pub struct NOT;
        impl cynic::schema::HasInputField<NOT> for super::super::JobWhereInput {
            type Type = Option<Vec<super::super::JobWhereInput>>;
            const NAME: &'static str = "NOT";
        }
    }
    pub mod JobsInput {
        pub struct r#type;
        impl cynic::schema::HasInputField<r#type> for super::super::JobsInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type";
        }
        pub struct slug;
        impl cynic::schema::HasInputField<slug> for super::super::JobsInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug";
        }
    }
    pub mod Location {
        pub struct id;
        impl cynic::schema::HasField<id> for super::super::Location {
            type Type = super::super::ID;
            const NAME: &'static str = "id";
        }
        pub struct slug;
        impl cynic::schema::HasField<slug> for super::super::Location {
            type Type = super::super::String;
            const NAME: &'static str = "slug";
        }
        pub struct name;
        impl cynic::schema::HasField<name> for super::super::Location {
            type Type = super::super::String;
            const NAME: &'static str = "name";
        }
        pub struct r#type;
        impl cynic::schema::HasField<r#type> for super::super::Location {
            type Type = super::super::String;
            const NAME: &'static str = "type";
        }
        pub struct __typename;
        impl cynic::schema::HasField<__typename> for super::super::Location {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
    }
    pub mod LocationInput {
        pub struct slug;
        impl cynic::schema::HasInputField<slug> for super::super::LocationInput {
            type Type = super::super::String;
            const NAME: &'static str = "slug";
        }
    }
    pub mod LocationsInput {
        pub struct value;
        impl cynic::schema::HasInputField<value> for super::super::LocationsInput {
            type Type = super::super::String;
            const NAME: &'static str = "value";
        }
    }
    pub mod Mutation {
        pub struct subscribe;
        impl cynic::schema::HasField<subscribe> for super::super::Mutation {
            type Type = super::super::User;
            const NAME: &'static str = "subscribe";
        }
        pub mod _subscribe_arguments {
            pub struct input;
            impl cynic::schema::HasArgument<input> for super::subscribe {
                type ArgumentType = super::super::super::SubscribeInput;
                const NAME: &'static str = "input";
            }
        }
        pub struct postJob;
        impl cynic::schema::HasField<postJob> for super::super::Mutation {
            type Type = super::super::Job;
            const NAME: &'static str = "postJob";
        }
        pub mod _post_job_arguments {
            pub struct input;
            impl cynic::schema::HasArgument<input> for super::postJob {
                type ArgumentType = super::super::super::PostJobInput;
                const NAME: &'static str = "input";
            }
        }
        pub struct updateJob;
        impl cynic::schema::HasField<updateJob> for super::super::Mutation {
            type Type = super::super::Job;
            const NAME: &'static str = "updateJob";
        }
        pub mod _update_job_arguments {
            pub struct input;
            impl cynic::schema::HasArgument<input> for super::updateJob {
                type ArgumentType = super::super::super::UpdateJobInput;
                const NAME: &'static str = "input";
            }
            pub struct adminSecret;
            impl cynic::schema::HasArgument<adminSecret> for super::updateJob {
                type ArgumentType = super::super::super::String;
                const NAME: &'static str = "adminSecret";
            }
        }
        pub struct updateCompany;
        impl cynic::schema::HasField<updateCompany> for super::super::Mutation {
            type Type = super::super::Company;
            const NAME: &'static str = "updateCompany";
        }
        pub mod _update_company_arguments {
            pub struct input;
            impl cynic::schema::HasArgument<input> for super::updateCompany {
                type ArgumentType = super::super::super::UpdateCompanyInput;
                const NAME: &'static str = "input";
            }
            pub struct adminSecret;
            impl cynic::schema::HasArgument<adminSecret> for super::updateCompany {
                type ArgumentType = super::super::super::String;
                const NAME: &'static str = "adminSecret";
            }
        }
        pub struct __typename;
        impl cynic::schema::HasField<__typename> for super::super::Mutation {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
    }
    pub mod PostJobInput {
        pub struct title;
        impl cynic::schema::HasInputField<title> for super::super::PostJobInput {
            type Type = super::super::String;
            const NAME: &'static str = "title";
        }
        pub struct commitmentId;
        impl cynic::schema::HasInputField<commitmentId> for super::super::PostJobInput {
            type Type = super::super::ID;
            const NAME: &'static str = "commitmentId";
        }
        pub struct companyName;
        impl cynic::schema::HasInputField<companyName> for super::super::PostJobInput {
            type Type = super::super::String;
            const NAME: &'static str = "companyName";
        }
        pub struct locationNames;
        impl cynic::schema::HasInputField<locationNames> for super::super::PostJobInput {
            type Type = super::super::String;
            const NAME: &'static str = "locationNames";
        }
        pub struct userEmail;
        impl cynic::schema::HasInputField<userEmail> for super::super::PostJobInput {
            type Type = super::super::String;
            const NAME: &'static str = "userEmail";
        }
        pub struct description;
        impl cynic::schema::HasInputField<description> for super::super::PostJobInput {
            type Type = super::super::String;
            const NAME: &'static str = "description";
        }
        pub struct applyUrl;
        impl cynic::schema::HasInputField<applyUrl> for super::super::PostJobInput {
            type Type = super::super::String;
            const NAME: &'static str = "applyUrl";
        }
    }
    pub mod Query {
        pub struct jobs;
        impl cynic::schema::HasField<jobs> for super::super::Query {
            type Type = Vec<super::super::Job>;
            const NAME: &'static str = "jobs";
        }
        pub mod _jobs_arguments {
            pub struct input;
            impl cynic::schema::HasArgument<input> for super::jobs {
                type ArgumentType = Option<super::super::super::JobsInput>;
                const NAME: &'static str = "input";
            }
        }
        pub struct job;
        impl cynic::schema::HasField<job> for super::super::Query {
            type Type = super::super::Job;
            const NAME: &'static str = "job";
        }
        pub mod _job_arguments {
            pub struct input;
            impl cynic::schema::HasArgument<input> for super::job {
                type ArgumentType = super::super::super::JobInput;
                const NAME: &'static str = "input";
            }
        }
        pub struct locations;
        impl cynic::schema::HasField<locations> for super::super::Query {
            type Type = Vec<super::super::Location>;
            const NAME: &'static str = "locations";
        }
        pub mod _locations_arguments {
            pub struct input;
            impl cynic::schema::HasArgument<input> for super::locations {
                type ArgumentType = super::super::super::LocationsInput;
                const NAME: &'static str = "input";
            }
        }
        pub struct city;
        impl cynic::schema::HasField<city> for super::super::Query {
            type Type = super::super::City;
            const NAME: &'static str = "city";
        }
        pub mod _city_arguments {
            pub struct input;
            impl cynic::schema::HasArgument<input> for super::city {
                type ArgumentType = super::super::super::LocationInput;
                const NAME: &'static str = "input";
            }
        }
        pub struct country;
        impl cynic::schema::HasField<country> for super::super::Query {
            type Type = super::super::Country;
            const NAME: &'static str = "country";
        }
        pub mod _country_arguments {
            pub struct input;
            impl cynic::schema::HasArgument<input> for super::country {
                type ArgumentType = super::super::super::LocationInput;
                const NAME: &'static str = "input";
            }
        }
        pub struct remote;
        impl cynic::schema::HasField<remote> for super::super::Query {
            type Type = super::super::Remote;
            const NAME: &'static str = "remote";
        }
        pub mod _remote_arguments {
            pub struct input;
            impl cynic::schema::HasArgument<input> for super::remote {
                type ArgumentType = super::super::super::LocationInput;
                const NAME: &'static str = "input";
            }
        }
        pub struct commitments;
        impl cynic::schema::HasField<commitments> for super::super::Query {
            type Type = Vec<super::super::Commitment>;
            const NAME: &'static str = "commitments";
        }
        pub struct cities;
        impl cynic::schema::HasField<cities> for super::super::Query {
            type Type = Vec<super::super::City>;
            const NAME: &'static str = "cities";
        }
        pub struct countries;
        impl cynic::schema::HasField<countries> for super::super::Query {
            type Type = Vec<super::super::Country>;
            const NAME: &'static str = "countries";
        }
        pub struct remotes;
        impl cynic::schema::HasField<remotes> for super::super::Query {
            type Type = Vec<super::super::Remote>;
            const NAME: &'static str = "remotes";
        }
        pub struct companies;
        impl cynic::schema::HasField<companies> for super::super::Query {
            type Type = Vec<super::super::Company>;
            const NAME: &'static str = "companies";
        }
        pub struct __typename;
        impl cynic::schema::HasField<__typename> for super::super::Query {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
    }
    pub mod Remote {
        pub struct id;
        impl cynic::schema::HasField<id> for super::super::Remote {
            type Type = super::super::ID;
            const NAME: &'static str = "id";
        }
        pub struct name;
        impl cynic::schema::HasField<name> for super::super::Remote {
            type Type = super::super::String;
            const NAME: &'static str = "name";
        }
        pub struct slug;
        impl cynic::schema::HasField<slug> for super::super::Remote {
            type Type = super::super::String;
            const NAME: &'static str = "slug";
        }
        pub struct r#type;
        impl cynic::schema::HasField<r#type> for super::super::Remote {
            type Type = super::super::String;
            const NAME: &'static str = "type";
        }
        pub struct jobs;
        impl cynic::schema::HasField<jobs> for super::super::Remote {
            type Type = Option<Vec<super::super::Job>>;
            const NAME: &'static str = "jobs";
        }
        pub mod _jobs_arguments {
            pub struct r#where;
            impl cynic::schema::HasArgument<r#where> for super::jobs {
                type ArgumentType = Option<super::super::super::JobWhereInput>;
                const NAME: &'static str = "where";
            }
            pub struct orderBy;
            impl cynic::schema::HasArgument<orderBy> for super::jobs {
                type ArgumentType = Option<super::super::super::JobOrderByInput>;
                const NAME: &'static str = "orderBy";
            }
            pub struct skip;
            impl cynic::schema::HasArgument<skip> for super::jobs {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "skip";
            }
            pub struct after;
            impl cynic::schema::HasArgument<after> for super::jobs {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "after";
            }
            pub struct before;
            impl cynic::schema::HasArgument<before> for super::jobs {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "before";
            }
            pub struct first;
            impl cynic::schema::HasArgument<first> for super::jobs {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "first";
            }
            pub struct last;
            impl cynic::schema::HasArgument<last> for super::jobs {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "last";
            }
        }
        pub struct createdAt;
        impl cynic::schema::HasField<createdAt> for super::super::Remote {
            type Type = super::super::DateTime;
            const NAME: &'static str = "createdAt";
        }
        pub struct updatedAt;
        impl cynic::schema::HasField<updatedAt> for super::super::Remote {
            type Type = super::super::DateTime;
            const NAME: &'static str = "updatedAt";
        }
        pub struct __typename;
        impl cynic::schema::HasField<__typename> for super::super::Remote {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
    }
    pub mod RemoteWhereInput {
        pub struct id;
        impl cynic::schema::HasInputField<id> for super::super::RemoteWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id";
        }
        pub struct id_not;
        impl cynic::schema::HasInputField<id_not> for super::super::RemoteWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_not";
        }
        pub struct id_in;
        impl cynic::schema::HasInputField<id_in> for super::super::RemoteWhereInput {
            type Type = Option<Vec<super::super::ID>>;
            const NAME: &'static str = "id_in";
        }
        pub struct id_not_in;
        impl cynic::schema::HasInputField<id_not_in> for super::super::RemoteWhereInput {
            type Type = Option<Vec<super::super::ID>>;
            const NAME: &'static str = "id_not_in";
        }
        pub struct id_lt;
        impl cynic::schema::HasInputField<id_lt> for super::super::RemoteWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_lt";
        }
        pub struct id_lte;
        impl cynic::schema::HasInputField<id_lte> for super::super::RemoteWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_lte";
        }
        pub struct id_gt;
        impl cynic::schema::HasInputField<id_gt> for super::super::RemoteWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_gt";
        }
        pub struct id_gte;
        impl cynic::schema::HasInputField<id_gte> for super::super::RemoteWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_gte";
        }
        pub struct id_contains;
        impl cynic::schema::HasInputField<id_contains> for super::super::RemoteWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_contains";
        }
        pub struct id_not_contains;
        impl cynic::schema::HasInputField<id_not_contains> for super::super::RemoteWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_not_contains";
        }
        pub struct id_starts_with;
        impl cynic::schema::HasInputField<id_starts_with> for super::super::RemoteWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_starts_with";
        }
        pub struct id_not_starts_with;
        impl cynic::schema::HasInputField<id_not_starts_with> for super::super::RemoteWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_not_starts_with";
        }
        pub struct id_ends_with;
        impl cynic::schema::HasInputField<id_ends_with> for super::super::RemoteWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_ends_with";
        }
        pub struct id_not_ends_with;
        impl cynic::schema::HasInputField<id_not_ends_with> for super::super::RemoteWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_not_ends_with";
        }
        pub struct name;
        impl cynic::schema::HasInputField<name> for super::super::RemoteWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name";
        }
        pub struct name_not;
        impl cynic::schema::HasInputField<name_not> for super::super::RemoteWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_not";
        }
        pub struct name_in;
        impl cynic::schema::HasInputField<name_in> for super::super::RemoteWhereInput {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "name_in";
        }
        pub struct name_not_in;
        impl cynic::schema::HasInputField<name_not_in> for super::super::RemoteWhereInput {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "name_not_in";
        }
        pub struct name_lt;
        impl cynic::schema::HasInputField<name_lt> for super::super::RemoteWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_lt";
        }
        pub struct name_lte;
        impl cynic::schema::HasInputField<name_lte> for super::super::RemoteWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_lte";
        }
        pub struct name_gt;
        impl cynic::schema::HasInputField<name_gt> for super::super::RemoteWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_gt";
        }
        pub struct name_gte;
        impl cynic::schema::HasInputField<name_gte> for super::super::RemoteWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_gte";
        }
        pub struct name_contains;
        impl cynic::schema::HasInputField<name_contains> for super::super::RemoteWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_contains";
        }
        pub struct name_not_contains;
        impl cynic::schema::HasInputField<name_not_contains> for super::super::RemoteWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_not_contains";
        }
        pub struct name_starts_with;
        impl cynic::schema::HasInputField<name_starts_with> for super::super::RemoteWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_starts_with";
        }
        pub struct name_not_starts_with;
        impl cynic::schema::HasInputField<name_not_starts_with> for super::super::RemoteWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_not_starts_with";
        }
        pub struct name_ends_with;
        impl cynic::schema::HasInputField<name_ends_with> for super::super::RemoteWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_ends_with";
        }
        pub struct name_not_ends_with;
        impl cynic::schema::HasInputField<name_not_ends_with> for super::super::RemoteWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_not_ends_with";
        }
        pub struct slug;
        impl cynic::schema::HasInputField<slug> for super::super::RemoteWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug";
        }
        pub struct slug_not;
        impl cynic::schema::HasInputField<slug_not> for super::super::RemoteWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_not";
        }
        pub struct slug_in;
        impl cynic::schema::HasInputField<slug_in> for super::super::RemoteWhereInput {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "slug_in";
        }
        pub struct slug_not_in;
        impl cynic::schema::HasInputField<slug_not_in> for super::super::RemoteWhereInput {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "slug_not_in";
        }
        pub struct slug_lt;
        impl cynic::schema::HasInputField<slug_lt> for super::super::RemoteWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_lt";
        }
        pub struct slug_lte;
        impl cynic::schema::HasInputField<slug_lte> for super::super::RemoteWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_lte";
        }
        pub struct slug_gt;
        impl cynic::schema::HasInputField<slug_gt> for super::super::RemoteWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_gt";
        }
        pub struct slug_gte;
        impl cynic::schema::HasInputField<slug_gte> for super::super::RemoteWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_gte";
        }
        pub struct slug_contains;
        impl cynic::schema::HasInputField<slug_contains> for super::super::RemoteWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_contains";
        }
        pub struct slug_not_contains;
        impl cynic::schema::HasInputField<slug_not_contains> for super::super::RemoteWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_not_contains";
        }
        pub struct slug_starts_with;
        impl cynic::schema::HasInputField<slug_starts_with> for super::super::RemoteWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_starts_with";
        }
        pub struct slug_not_starts_with;
        impl cynic::schema::HasInputField<slug_not_starts_with> for super::super::RemoteWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_not_starts_with";
        }
        pub struct slug_ends_with;
        impl cynic::schema::HasInputField<slug_ends_with> for super::super::RemoteWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_ends_with";
        }
        pub struct slug_not_ends_with;
        impl cynic::schema::HasInputField<slug_not_ends_with> for super::super::RemoteWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_not_ends_with";
        }
        pub struct r#type;
        impl cynic::schema::HasInputField<r#type> for super::super::RemoteWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type";
        }
        pub struct type_not;
        impl cynic::schema::HasInputField<type_not> for super::super::RemoteWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type_not";
        }
        pub struct type_in;
        impl cynic::schema::HasInputField<type_in> for super::super::RemoteWhereInput {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "type_in";
        }
        pub struct type_not_in;
        impl cynic::schema::HasInputField<type_not_in> for super::super::RemoteWhereInput {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "type_not_in";
        }
        pub struct type_lt;
        impl cynic::schema::HasInputField<type_lt> for super::super::RemoteWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type_lt";
        }
        pub struct type_lte;
        impl cynic::schema::HasInputField<type_lte> for super::super::RemoteWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type_lte";
        }
        pub struct type_gt;
        impl cynic::schema::HasInputField<type_gt> for super::super::RemoteWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type_gt";
        }
        pub struct type_gte;
        impl cynic::schema::HasInputField<type_gte> for super::super::RemoteWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type_gte";
        }
        pub struct type_contains;
        impl cynic::schema::HasInputField<type_contains> for super::super::RemoteWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type_contains";
        }
        pub struct type_not_contains;
        impl cynic::schema::HasInputField<type_not_contains> for super::super::RemoteWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type_not_contains";
        }
        pub struct type_starts_with;
        impl cynic::schema::HasInputField<type_starts_with> for super::super::RemoteWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type_starts_with";
        }
        pub struct type_not_starts_with;
        impl cynic::schema::HasInputField<type_not_starts_with> for super::super::RemoteWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type_not_starts_with";
        }
        pub struct type_ends_with;
        impl cynic::schema::HasInputField<type_ends_with> for super::super::RemoteWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type_ends_with";
        }
        pub struct type_not_ends_with;
        impl cynic::schema::HasInputField<type_not_ends_with> for super::super::RemoteWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "type_not_ends_with";
        }
        pub struct jobs_every;
        impl cynic::schema::HasInputField<jobs_every> for super::super::RemoteWhereInput {
            type Type = Option<super::super::JobWhereInput>;
            const NAME: &'static str = "jobs_every";
        }
        pub struct jobs_some;
        impl cynic::schema::HasInputField<jobs_some> for super::super::RemoteWhereInput {
            type Type = Option<super::super::JobWhereInput>;
            const NAME: &'static str = "jobs_some";
        }
        pub struct jobs_none;
        impl cynic::schema::HasInputField<jobs_none> for super::super::RemoteWhereInput {
            type Type = Option<super::super::JobWhereInput>;
            const NAME: &'static str = "jobs_none";
        }
        pub struct createdAt;
        impl cynic::schema::HasInputField<createdAt> for super::super::RemoteWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt";
        }
        pub struct createdAt_not;
        impl cynic::schema::HasInputField<createdAt_not> for super::super::RemoteWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt_not";
        }
        pub struct createdAt_in;
        impl cynic::schema::HasInputField<createdAt_in> for super::super::RemoteWhereInput {
            type Type = Option<Vec<super::super::DateTime>>;
            const NAME: &'static str = "createdAt_in";
        }
        pub struct createdAt_not_in;
        impl cynic::schema::HasInputField<createdAt_not_in> for super::super::RemoteWhereInput {
            type Type = Option<Vec<super::super::DateTime>>;
            const NAME: &'static str = "createdAt_not_in";
        }
        pub struct createdAt_lt;
        impl cynic::schema::HasInputField<createdAt_lt> for super::super::RemoteWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt_lt";
        }
        pub struct createdAt_lte;
        impl cynic::schema::HasInputField<createdAt_lte> for super::super::RemoteWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt_lte";
        }
        pub struct createdAt_gt;
        impl cynic::schema::HasInputField<createdAt_gt> for super::super::RemoteWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt_gt";
        }
        pub struct createdAt_gte;
        impl cynic::schema::HasInputField<createdAt_gte> for super::super::RemoteWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt_gte";
        }
        pub struct updatedAt;
        impl cynic::schema::HasInputField<updatedAt> for super::super::RemoteWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt";
        }
        pub struct updatedAt_not;
        impl cynic::schema::HasInputField<updatedAt_not> for super::super::RemoteWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt_not";
        }
        pub struct updatedAt_in;
        impl cynic::schema::HasInputField<updatedAt_in> for super::super::RemoteWhereInput {
            type Type = Option<Vec<super::super::DateTime>>;
            const NAME: &'static str = "updatedAt_in";
        }
        pub struct updatedAt_not_in;
        impl cynic::schema::HasInputField<updatedAt_not_in> for super::super::RemoteWhereInput {
            type Type = Option<Vec<super::super::DateTime>>;
            const NAME: &'static str = "updatedAt_not_in";
        }
        pub struct updatedAt_lt;
        impl cynic::schema::HasInputField<updatedAt_lt> for super::super::RemoteWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt_lt";
        }
        pub struct updatedAt_lte;
        impl cynic::schema::HasInputField<updatedAt_lte> for super::super::RemoteWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt_lte";
        }
        pub struct updatedAt_gt;
        impl cynic::schema::HasInputField<updatedAt_gt> for super::super::RemoteWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt_gt";
        }
        pub struct updatedAt_gte;
        impl cynic::schema::HasInputField<updatedAt_gte> for super::super::RemoteWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt_gte";
        }
        pub struct AND;
        impl cynic::schema::HasInputField<AND> for super::super::RemoteWhereInput {
            type Type = Option<Vec<super::super::RemoteWhereInput>>;
            const NAME: &'static str = "AND";
        }
        pub struct OR;
        impl cynic::schema::HasInputField<OR> for super::super::RemoteWhereInput {
            type Type = Option<Vec<super::super::RemoteWhereInput>>;
            const NAME: &'static str = "OR";
        }
        pub struct NOT;
        impl cynic::schema::HasInputField<NOT> for super::super::RemoteWhereInput {
            type Type = Option<Vec<super::super::RemoteWhereInput>>;
            const NAME: &'static str = "NOT";
        }
    }
    pub mod SubscribeInput {
        pub struct name;
        impl cynic::schema::HasInputField<name> for super::super::SubscribeInput {
            type Type = super::super::String;
            const NAME: &'static str = "name";
        }
        pub struct email;
        impl cynic::schema::HasInputField<email> for super::super::SubscribeInput {
            type Type = super::super::String;
            const NAME: &'static str = "email";
        }
    }
    pub mod Tag {
        pub struct id;
        impl cynic::schema::HasField<id> for super::super::Tag {
            type Type = super::super::ID;
            const NAME: &'static str = "id";
        }
        pub struct name;
        impl cynic::schema::HasField<name> for super::super::Tag {
            type Type = super::super::String;
            const NAME: &'static str = "name";
        }
        pub struct slug;
        impl cynic::schema::HasField<slug> for super::super::Tag {
            type Type = super::super::String;
            const NAME: &'static str = "slug";
        }
        pub struct jobs;
        impl cynic::schema::HasField<jobs> for super::super::Tag {
            type Type = Option<Vec<super::super::Job>>;
            const NAME: &'static str = "jobs";
        }
        pub mod _jobs_arguments {
            pub struct r#where;
            impl cynic::schema::HasArgument<r#where> for super::jobs {
                type ArgumentType = Option<super::super::super::JobWhereInput>;
                const NAME: &'static str = "where";
            }
            pub struct orderBy;
            impl cynic::schema::HasArgument<orderBy> for super::jobs {
                type ArgumentType = Option<super::super::super::JobOrderByInput>;
                const NAME: &'static str = "orderBy";
            }
            pub struct skip;
            impl cynic::schema::HasArgument<skip> for super::jobs {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "skip";
            }
            pub struct after;
            impl cynic::schema::HasArgument<after> for super::jobs {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "after";
            }
            pub struct before;
            impl cynic::schema::HasArgument<before> for super::jobs {
                type ArgumentType = Option<super::super::super::String>;
                const NAME: &'static str = "before";
            }
            pub struct first;
            impl cynic::schema::HasArgument<first> for super::jobs {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "first";
            }
            pub struct last;
            impl cynic::schema::HasArgument<last> for super::jobs {
                type ArgumentType = Option<super::super::super::Int>;
                const NAME: &'static str = "last";
            }
        }
        pub struct createdAt;
        impl cynic::schema::HasField<createdAt> for super::super::Tag {
            type Type = super::super::DateTime;
            const NAME: &'static str = "createdAt";
        }
        pub struct updatedAt;
        impl cynic::schema::HasField<updatedAt> for super::super::Tag {
            type Type = super::super::DateTime;
            const NAME: &'static str = "updatedAt";
        }
        pub struct __typename;
        impl cynic::schema::HasField<__typename> for super::super::Tag {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
    }
    pub mod TagWhereInput {
        pub struct id;
        impl cynic::schema::HasInputField<id> for super::super::TagWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id";
        }
        pub struct id_not;
        impl cynic::schema::HasInputField<id_not> for super::super::TagWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_not";
        }
        pub struct id_in;
        impl cynic::schema::HasInputField<id_in> for super::super::TagWhereInput {
            type Type = Option<Vec<super::super::ID>>;
            const NAME: &'static str = "id_in";
        }
        pub struct id_not_in;
        impl cynic::schema::HasInputField<id_not_in> for super::super::TagWhereInput {
            type Type = Option<Vec<super::super::ID>>;
            const NAME: &'static str = "id_not_in";
        }
        pub struct id_lt;
        impl cynic::schema::HasInputField<id_lt> for super::super::TagWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_lt";
        }
        pub struct id_lte;
        impl cynic::schema::HasInputField<id_lte> for super::super::TagWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_lte";
        }
        pub struct id_gt;
        impl cynic::schema::HasInputField<id_gt> for super::super::TagWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_gt";
        }
        pub struct id_gte;
        impl cynic::schema::HasInputField<id_gte> for super::super::TagWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_gte";
        }
        pub struct id_contains;
        impl cynic::schema::HasInputField<id_contains> for super::super::TagWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_contains";
        }
        pub struct id_not_contains;
        impl cynic::schema::HasInputField<id_not_contains> for super::super::TagWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_not_contains";
        }
        pub struct id_starts_with;
        impl cynic::schema::HasInputField<id_starts_with> for super::super::TagWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_starts_with";
        }
        pub struct id_not_starts_with;
        impl cynic::schema::HasInputField<id_not_starts_with> for super::super::TagWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_not_starts_with";
        }
        pub struct id_ends_with;
        impl cynic::schema::HasInputField<id_ends_with> for super::super::TagWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_ends_with";
        }
        pub struct id_not_ends_with;
        impl cynic::schema::HasInputField<id_not_ends_with> for super::super::TagWhereInput {
            type Type = Option<super::super::ID>;
            const NAME: &'static str = "id_not_ends_with";
        }
        pub struct name;
        impl cynic::schema::HasInputField<name> for super::super::TagWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name";
        }
        pub struct name_not;
        impl cynic::schema::HasInputField<name_not> for super::super::TagWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_not";
        }
        pub struct name_in;
        impl cynic::schema::HasInputField<name_in> for super::super::TagWhereInput {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "name_in";
        }
        pub struct name_not_in;
        impl cynic::schema::HasInputField<name_not_in> for super::super::TagWhereInput {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "name_not_in";
        }
        pub struct name_lt;
        impl cynic::schema::HasInputField<name_lt> for super::super::TagWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_lt";
        }
        pub struct name_lte;
        impl cynic::schema::HasInputField<name_lte> for super::super::TagWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_lte";
        }
        pub struct name_gt;
        impl cynic::schema::HasInputField<name_gt> for super::super::TagWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_gt";
        }
        pub struct name_gte;
        impl cynic::schema::HasInputField<name_gte> for super::super::TagWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_gte";
        }
        pub struct name_contains;
        impl cynic::schema::HasInputField<name_contains> for super::super::TagWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_contains";
        }
        pub struct name_not_contains;
        impl cynic::schema::HasInputField<name_not_contains> for super::super::TagWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_not_contains";
        }
        pub struct name_starts_with;
        impl cynic::schema::HasInputField<name_starts_with> for super::super::TagWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_starts_with";
        }
        pub struct name_not_starts_with;
        impl cynic::schema::HasInputField<name_not_starts_with> for super::super::TagWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_not_starts_with";
        }
        pub struct name_ends_with;
        impl cynic::schema::HasInputField<name_ends_with> for super::super::TagWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_ends_with";
        }
        pub struct name_not_ends_with;
        impl cynic::schema::HasInputField<name_not_ends_with> for super::super::TagWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name_not_ends_with";
        }
        pub struct slug;
        impl cynic::schema::HasInputField<slug> for super::super::TagWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug";
        }
        pub struct slug_not;
        impl cynic::schema::HasInputField<slug_not> for super::super::TagWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_not";
        }
        pub struct slug_in;
        impl cynic::schema::HasInputField<slug_in> for super::super::TagWhereInput {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "slug_in";
        }
        pub struct slug_not_in;
        impl cynic::schema::HasInputField<slug_not_in> for super::super::TagWhereInput {
            type Type = Option<Vec<super::super::String>>;
            const NAME: &'static str = "slug_not_in";
        }
        pub struct slug_lt;
        impl cynic::schema::HasInputField<slug_lt> for super::super::TagWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_lt";
        }
        pub struct slug_lte;
        impl cynic::schema::HasInputField<slug_lte> for super::super::TagWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_lte";
        }
        pub struct slug_gt;
        impl cynic::schema::HasInputField<slug_gt> for super::super::TagWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_gt";
        }
        pub struct slug_gte;
        impl cynic::schema::HasInputField<slug_gte> for super::super::TagWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_gte";
        }
        pub struct slug_contains;
        impl cynic::schema::HasInputField<slug_contains> for super::super::TagWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_contains";
        }
        pub struct slug_not_contains;
        impl cynic::schema::HasInputField<slug_not_contains> for super::super::TagWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_not_contains";
        }
        pub struct slug_starts_with;
        impl cynic::schema::HasInputField<slug_starts_with> for super::super::TagWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_starts_with";
        }
        pub struct slug_not_starts_with;
        impl cynic::schema::HasInputField<slug_not_starts_with> for super::super::TagWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_not_starts_with";
        }
        pub struct slug_ends_with;
        impl cynic::schema::HasInputField<slug_ends_with> for super::super::TagWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_ends_with";
        }
        pub struct slug_not_ends_with;
        impl cynic::schema::HasInputField<slug_not_ends_with> for super::super::TagWhereInput {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "slug_not_ends_with";
        }
        pub struct jobs_every;
        impl cynic::schema::HasInputField<jobs_every> for super::super::TagWhereInput {
            type Type = Option<super::super::JobWhereInput>;
            const NAME: &'static str = "jobs_every";
        }
        pub struct jobs_some;
        impl cynic::schema::HasInputField<jobs_some> for super::super::TagWhereInput {
            type Type = Option<super::super::JobWhereInput>;
            const NAME: &'static str = "jobs_some";
        }
        pub struct jobs_none;
        impl cynic::schema::HasInputField<jobs_none> for super::super::TagWhereInput {
            type Type = Option<super::super::JobWhereInput>;
            const NAME: &'static str = "jobs_none";
        }
        pub struct createdAt;
        impl cynic::schema::HasInputField<createdAt> for super::super::TagWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt";
        }
        pub struct createdAt_not;
        impl cynic::schema::HasInputField<createdAt_not> for super::super::TagWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt_not";
        }
        pub struct createdAt_in;
        impl cynic::schema::HasInputField<createdAt_in> for super::super::TagWhereInput {
            type Type = Option<Vec<super::super::DateTime>>;
            const NAME: &'static str = "createdAt_in";
        }
        pub struct createdAt_not_in;
        impl cynic::schema::HasInputField<createdAt_not_in> for super::super::TagWhereInput {
            type Type = Option<Vec<super::super::DateTime>>;
            const NAME: &'static str = "createdAt_not_in";
        }
        pub struct createdAt_lt;
        impl cynic::schema::HasInputField<createdAt_lt> for super::super::TagWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt_lt";
        }
        pub struct createdAt_lte;
        impl cynic::schema::HasInputField<createdAt_lte> for super::super::TagWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt_lte";
        }
        pub struct createdAt_gt;
        impl cynic::schema::HasInputField<createdAt_gt> for super::super::TagWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt_gt";
        }
        pub struct createdAt_gte;
        impl cynic::schema::HasInputField<createdAt_gte> for super::super::TagWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "createdAt_gte";
        }
        pub struct updatedAt;
        impl cynic::schema::HasInputField<updatedAt> for super::super::TagWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt";
        }
        pub struct updatedAt_not;
        impl cynic::schema::HasInputField<updatedAt_not> for super::super::TagWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt_not";
        }
        pub struct updatedAt_in;
        impl cynic::schema::HasInputField<updatedAt_in> for super::super::TagWhereInput {
            type Type = Option<Vec<super::super::DateTime>>;
            const NAME: &'static str = "updatedAt_in";
        }
        pub struct updatedAt_not_in;
        impl cynic::schema::HasInputField<updatedAt_not_in> for super::super::TagWhereInput {
            type Type = Option<Vec<super::super::DateTime>>;
            const NAME: &'static str = "updatedAt_not_in";
        }
        pub struct updatedAt_lt;
        impl cynic::schema::HasInputField<updatedAt_lt> for super::super::TagWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt_lt";
        }
        pub struct updatedAt_lte;
        impl cynic::schema::HasInputField<updatedAt_lte> for super::super::TagWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt_lte";
        }
        pub struct updatedAt_gt;
        impl cynic::schema::HasInputField<updatedAt_gt> for super::super::TagWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt_gt";
        }
        pub struct updatedAt_gte;
        impl cynic::schema::HasInputField<updatedAt_gte> for super::super::TagWhereInput {
            type Type = Option<super::super::DateTime>;
            const NAME: &'static str = "updatedAt_gte";
        }
        pub struct AND;
        impl cynic::schema::HasInputField<AND> for super::super::TagWhereInput {
            type Type = Option<Vec<super::super::TagWhereInput>>;
            const NAME: &'static str = "AND";
        }
        pub struct OR;
        impl cynic::schema::HasInputField<OR> for super::super::TagWhereInput {
            type Type = Option<Vec<super::super::TagWhereInput>>;
            const NAME: &'static str = "OR";
        }
        pub struct NOT;
        impl cynic::schema::HasInputField<NOT> for super::super::TagWhereInput {
            type Type = Option<Vec<super::super::TagWhereInput>>;
            const NAME: &'static str = "NOT";
        }
    }
    pub mod UpdateCompanyInput {
        pub struct id;
        impl cynic::schema::HasInputField<id> for super::super::UpdateCompanyInput {
            type Type = super::super::ID;
            const NAME: &'static str = "id";
        }
        pub struct logoUrl;
        impl cynic::schema::HasInputField<logoUrl> for super::super::UpdateCompanyInput {
            type Type = super::super::String;
            const NAME: &'static str = "logoUrl";
        }
    }
    pub mod UpdateJobInput {
        pub struct id;
        impl cynic::schema::HasInputField<id> for super::super::UpdateJobInput {
            type Type = super::super::ID;
            const NAME: &'static str = "id";
        }
        pub struct description;
        impl cynic::schema::HasInputField<description> for super::super::UpdateJobInput {
            type Type = super::super::String;
            const NAME: &'static str = "description";
        }
    }
    pub mod User {
        pub struct id;
        impl cynic::schema::HasField<id> for super::super::User {
            type Type = super::super::ID;
            const NAME: &'static str = "id";
        }
        pub struct name;
        impl cynic::schema::HasField<name> for super::super::User {
            type Type = Option<super::super::String>;
            const NAME: &'static str = "name";
        }
        pub struct email;
        impl cynic::schema::HasField<email> for super::super::User {
            type Type = super::super::String;
            const NAME: &'static str = "email";
        }
        pub struct subscribe;
        impl cynic::schema::HasField<subscribe> for super::super::User {
            type Type = super::super::Boolean;
            const NAME: &'static str = "subscribe";
        }
        pub struct createdAt;
        impl cynic::schema::HasField<createdAt> for super::super::User {
            type Type = super::super::DateTime;
            const NAME: &'static str = "createdAt";
        }
        pub struct updatedAt;
        impl cynic::schema::HasField<updatedAt> for super::super::User {
            type Type = super::super::DateTime;
            const NAME: &'static str = "updatedAt";
        }
        pub struct __typename;
        impl cynic::schema::HasField<__typename> for super::super::User {
            type Type = super::super::String;
            const NAME: &'static str = "__typename";
        }
    }
}
pub type Boolean = bool;
pub type String = std::string::String;
pub type Float = f64;
pub type Int = i32;
pub type ID = cynic::Id;
pub mod variable {
    use cynic::variables::VariableType;
    #[doc = r" Used to determine the type of a given variable that"]
    #[doc = r" appears in an argument struct."]
    pub trait Variable {
        const TYPE: VariableType;
    }
    impl<T> Variable for &T
    where
        T: ?::core::marker::Sized + Variable,
    {
        const TYPE: VariableType = T::TYPE;
    }
    impl<T> Variable for Option<T>
    where
        T: Variable,
    {
        const TYPE: VariableType = VariableType::Nullable(&T::TYPE);
    }
    impl<T> Variable for [T]
    where
        T: Variable,
    {
        const TYPE: VariableType = VariableType::List(&T::TYPE);
    }
    impl<T> Variable for Vec<T>
    where
        T: Variable,
    {
        const TYPE: VariableType = VariableType::List(&T::TYPE);
    }
    impl<T> Variable for Box<T>
    where
        T: Variable,
    {
        const TYPE: VariableType = T::TYPE;
    }
    impl<T> Variable for std::rc::Rc<T>
    where
        T: Variable,
    {
        const TYPE: VariableType = T::TYPE;
    }
    impl<T> Variable for std::sync::Arc<T>
    where
        T: Variable,
    {
        const TYPE: VariableType = T::TYPE;
    }
    impl<T> Variable for std::borrow::Cow<'_, T>
    where
        T: ?::core::marker::Sized + Variable + ToOwned,
    {
        const TYPE: VariableType = T::TYPE;
    }
    impl Variable for bool {
        const TYPE: VariableType = VariableType::Named("Boolean");
    }
    impl Variable for str {
        const TYPE: VariableType = VariableType::Named("String");
    }
    impl Variable for String {
        const TYPE: VariableType = <str as Variable>::TYPE;
    }
    impl Variable for f64 {
        const TYPE: VariableType = VariableType::Named("Float");
    }
    impl Variable for i32 {
        const TYPE: VariableType = VariableType::Named("Int");
    }
    impl Variable for cynic::Id {
        const TYPE: VariableType = VariableType::Named("ID");
    }
}

