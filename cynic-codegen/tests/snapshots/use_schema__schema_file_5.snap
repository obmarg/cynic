---
source: cynic-codegen/tests/use-schema.rs
assertion_line: 25
expression: "format_code(format!(\"{}\", tokens))"

---
impl ::cynic::schema::QueryRoot for Query {}
pub struct AnInputType {}
pub struct Dessert {}
pub struct Json {}
pub struct MyUnionType {}
pub struct Nested;
pub mod nested_fields {
    pub struct AString;
    impl ::cynic::schema::Field for AString {
        type SchemaType = super::String;
        fn name() -> &'static str {
            "aString"
        }
    }
    impl ::cynic::schema::HasField<AString, super::String> for super::Nested {}
    pub struct OptString;
    impl ::cynic::schema::Field for OptString {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "optString"
        }
    }
    impl ::cynic::schema::HasField<OptString, Option<super::String>> for super::Nested {}
}
pub struct Query;
pub mod query_fields {
    pub struct TestStruct;
    impl ::cynic::schema::Field for TestStruct {
        type SchemaType = Option<super::TestStruct>;
        fn name() -> &'static str {
            "testStruct"
        }
    }
    impl ::cynic::schema::HasField<TestStruct, Option<super::TestStruct>> for super::Query {}
    pub struct MyUnion;
    impl ::cynic::schema::Field for MyUnion {
        type SchemaType = Option<super::MyUnionType>;
        fn name() -> &'static str {
            "myUnion"
        }
    }
    impl ::cynic::schema::HasField<MyUnion, Option<super::MyUnionType>> for super::Query {}
}
pub struct TestStruct;
pub mod test_struct_fields {
    pub struct FieldOne;
    impl ::cynic::schema::Field for FieldOne {
        type SchemaType = super::String;
        fn name() -> &'static str {
            "fieldOne"
        }
    }
    impl ::cynic::schema::HasField<FieldOne, super::String> for super::TestStruct {}
    pub mod field_one_arguments {
        pub struct X;
        impl ::cynic::schema::HasArgument<X> for super::FieldOne {
            type ArgumentSchemaType = Option<super::super::Int>;
            fn name() -> &'static str {
                "x"
            }
        }
        pub struct Y;
        impl ::cynic::schema::HasArgument<Y> for super::FieldOne {
            type ArgumentSchemaType = Option<super::super::String>;
            fn name() -> &'static str {
                "y"
            }
        }
    }
    pub struct TastyCakes;
    impl ::cynic::schema::Field for TastyCakes {
        type SchemaType = super::Dessert;
        fn name() -> &'static str {
            "tastyCakes"
        }
    }
    impl ::cynic::schema::HasField<TastyCakes, super::Dessert> for super::TestStruct {}
    pub mod tasty_cakes_arguments {
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::TastyCakes {
            type ArgumentSchemaType = super::super::Dessert;
            fn name() -> &'static str {
                "first"
            }
        }
        pub struct Second;
        impl ::cynic::schema::HasArgument<Second> for super::TastyCakes {
            type ArgumentSchemaType = Option<super::super::Dessert>;
            fn name() -> &'static str {
                "second"
            }
        }
    }
    pub struct FieldWithInput;
    impl ::cynic::schema::Field for FieldWithInput {
        type SchemaType = super::Dessert;
        fn name() -> &'static str {
            "fieldWithInput"
        }
    }
    impl ::cynic::schema::HasField<FieldWithInput, super::Dessert> for super::TestStruct {}
    pub mod field_with_input_arguments {
        pub struct Input;
        impl ::cynic::schema::HasArgument<Input> for super::FieldWithInput {
            type ArgumentSchemaType = super::super::AnInputType;
            fn name() -> &'static str {
                "input"
            }
        }
    }
    pub struct Nested;
    impl ::cynic::schema::Field for Nested {
        type SchemaType = super::Nested;
        fn name() -> &'static str {
            "nested"
        }
    }
    impl ::cynic::schema::HasField<Nested, super::Nested> for super::TestStruct {}
    pub struct OptNested;
    impl ::cynic::schema::Field for OptNested {
        type SchemaType = Option<super::Nested>;
        fn name() -> &'static str {
            "optNested"
        }
    }
    impl ::cynic::schema::HasField<OptNested, Option<super::Nested>> for super::TestStruct {}
    pub struct Dessert;
    impl ::cynic::schema::Field for Dessert {
        type SchemaType = Option<super::Dessert>;
        fn name() -> &'static str {
            "dessert"
        }
    }
    impl ::cynic::schema::HasField<Dessert, Option<super::Dessert>> for super::TestStruct {}
    pub struct Json;
    impl ::cynic::schema::Field for Json {
        type SchemaType = Option<super::Json>;
        fn name() -> &'static str {
            "json"
        }
    }
    impl ::cynic::schema::HasField<Json, Option<super::Json>> for super::TestStruct {}
}
impl ::cynic::schema::HasSubtype<Nested> for MyUnionType {}
impl ::cynic::schema::HasSubtype<TestStruct> for MyUnionType {}
impl ::cynic::schema::NamedType for MyUnionType {
    fn name() -> &'static str {
        "MyUnionType"
    }
}
impl ::cynic::schema::NamedType for Nested {
    fn name() -> &'static str {
        "Nested"
    }
}
impl ::cynic::schema::NamedType for Query {
    fn name() -> &'static str {
        "Query"
    }
}
impl ::cynic::schema::NamedType for TestStruct {
    fn name() -> &'static str {
        "TestStruct"
    }
}
pub type Boolean = bool;
pub type String = std::string::String;
pub type Float = f64;
pub type Int = i32;
pub type Id = ::cynic::Id;
pub mod variable {
    use cynic::variables::VariableType;
    #[doc = r" Used to determine the type of a given variable that"]
    #[doc = r" appears in an argument struct."]
    pub trait Variable {
        const TYPE: VariableType;
    }
    impl<T> Variable for &T
    where
        T: Variable,
    {
        const TYPE: VariableType = T::TYPE;
    }
    impl<T> Variable for Option<T>
    where
        T: Variable,
    {
        const TYPE: VariableType = VariableType::Nullable(&T::TYPE);
    }
    impl<T> Variable for Vec<T>
    where
        T: Variable,
    {
        const TYPE: VariableType = VariableType::List(&T::TYPE);
    }
    impl<T> Variable for Box<T>
    where
        T: Variable,
    {
        const TYPE: VariableType = T::TYPE;
    }
    impl<T> Variable for std::rc::Rc<T>
    where
        T: Variable,
    {
        const TYPE: VariableType = T::TYPE;
    }
    impl<T> Variable for std::sync::Arc<T>
    where
        T: Variable,
    {
        const TYPE: VariableType = T::TYPE;
    }
    impl Variable for bool {
        const TYPE: VariableType = VariableType::Named("Boolean");
    }
    impl Variable for String {
        const TYPE: VariableType = VariableType::Named("String");
    }
    impl Variable for f64 {
        const TYPE: VariableType = VariableType::Named("Float");
    }
    impl Variable for i32 {
        const TYPE: VariableType = VariableType::Named("Int");
    }
    impl Variable for ::cynic::Id {
        const TYPE: VariableType = VariableType::Named("ID");
    }
}

