---
source: cynic-codegen/tests/use-schema.rs
assertion_line: 25
expression: "format_code(format!(\"{}\", tokens))"

---
impl ::cynic::schema::QueryRoot for Query {}
impl ::cynic::schema::MutationRoot for Mutation {}
pub struct City;
pub mod city_fields {
    pub struct Id;
    impl ::cynic::schema::Field for Id {
        type SchemaType = super::Id;
        fn name() -> &'static str {
            "id"
        }
    }
    impl ::cynic::schema::HasField<Id, super::Id> for super::City {}
    pub struct Name;
    impl ::cynic::schema::Field for Name {
        type SchemaType = super::String;
        fn name() -> &'static str {
            "name"
        }
    }
    impl ::cynic::schema::HasField<Name, super::String> for super::City {}
    pub struct Slug;
    impl ::cynic::schema::Field for Slug {
        type SchemaType = super::String;
        fn name() -> &'static str {
            "slug"
        }
    }
    impl ::cynic::schema::HasField<Slug, super::String> for super::City {}
    pub struct Country;
    impl ::cynic::schema::Field for Country {
        type SchemaType = super::Country;
        fn name() -> &'static str {
            "country"
        }
    }
    impl ::cynic::schema::HasField<Country, super::Country> for super::City {}
    pub struct Type;
    impl ::cynic::schema::Field for Type {
        type SchemaType = super::String;
        fn name() -> &'static str {
            "type"
        }
    }
    impl ::cynic::schema::HasField<Type, super::String> for super::City {}
    pub struct Jobs;
    impl ::cynic::schema::Field for Jobs {
        type SchemaType = Option<Vec<super::Job>>;
        fn name() -> &'static str {
            "jobs"
        }
    }
    impl ::cynic::schema::HasField<Jobs, Option<Vec<super::Job>>> for super::City {}
    pub mod jobs_arguments {
        pub struct Where;
        impl ::cynic::schema::HasArgument<Where> for super::Jobs {
            type ArgumentSchemaType = Option<super::super::JobWhereInput>;
            type ArgumentKind = ::cynic::schema::InputObjectArgument;
            fn name() -> &'static str {
                "where"
            }
        }
        pub struct OrderBy;
        impl ::cynic::schema::HasArgument<OrderBy> for super::Jobs {
            type ArgumentSchemaType = Option<super::super::JobOrderByInput>;
            type ArgumentKind = ::cynic::schema::EnumArgument;
            fn name() -> &'static str {
                "orderBy"
            }
        }
        pub struct Skip;
        impl ::cynic::schema::HasArgument<Skip> for super::Jobs {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "skip"
            }
        }
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::Jobs {
            type ArgumentSchemaType = Option<super::super::String>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "after"
            }
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::Jobs {
            type ArgumentSchemaType = Option<super::super::String>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "before"
            }
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::Jobs {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "first"
            }
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::Jobs {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "last"
            }
        }
    }
    pub struct CreatedAt;
    impl ::cynic::schema::Field for CreatedAt {
        type SchemaType = super::DateTime;
        fn name() -> &'static str {
            "createdAt"
        }
    }
    impl ::cynic::schema::HasField<CreatedAt, super::DateTime> for super::City {}
    pub struct UpdatedAt;
    impl ::cynic::schema::Field for UpdatedAt {
        type SchemaType = super::DateTime;
        fn name() -> &'static str {
            "updatedAt"
        }
    }
    impl ::cynic::schema::HasField<UpdatedAt, super::DateTime> for super::City {}
}
pub struct CityOrderByInput {}
pub struct CityWhereInput {}
pub struct Commitment;
pub mod commitment_fields {
    pub struct Id;
    impl ::cynic::schema::Field for Id {
        type SchemaType = super::Id;
        fn name() -> &'static str {
            "id"
        }
    }
    impl ::cynic::schema::HasField<Id, super::Id> for super::Commitment {}
    pub struct Title;
    impl ::cynic::schema::Field for Title {
        type SchemaType = super::String;
        fn name() -> &'static str {
            "title"
        }
    }
    impl ::cynic::schema::HasField<Title, super::String> for super::Commitment {}
    pub struct Slug;
    impl ::cynic::schema::Field for Slug {
        type SchemaType = super::String;
        fn name() -> &'static str {
            "slug"
        }
    }
    impl ::cynic::schema::HasField<Slug, super::String> for super::Commitment {}
    pub struct Jobs;
    impl ::cynic::schema::Field for Jobs {
        type SchemaType = Option<Vec<super::Job>>;
        fn name() -> &'static str {
            "jobs"
        }
    }
    impl ::cynic::schema::HasField<Jobs, Option<Vec<super::Job>>> for super::Commitment {}
    pub mod jobs_arguments {
        pub struct Where;
        impl ::cynic::schema::HasArgument<Where> for super::Jobs {
            type ArgumentSchemaType = Option<super::super::JobWhereInput>;
            type ArgumentKind = ::cynic::schema::InputObjectArgument;
            fn name() -> &'static str {
                "where"
            }
        }
        pub struct OrderBy;
        impl ::cynic::schema::HasArgument<OrderBy> for super::Jobs {
            type ArgumentSchemaType = Option<super::super::JobOrderByInput>;
            type ArgumentKind = ::cynic::schema::EnumArgument;
            fn name() -> &'static str {
                "orderBy"
            }
        }
        pub struct Skip;
        impl ::cynic::schema::HasArgument<Skip> for super::Jobs {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "skip"
            }
        }
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::Jobs {
            type ArgumentSchemaType = Option<super::super::String>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "after"
            }
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::Jobs {
            type ArgumentSchemaType = Option<super::super::String>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "before"
            }
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::Jobs {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "first"
            }
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::Jobs {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "last"
            }
        }
    }
    pub struct CreatedAt;
    impl ::cynic::schema::Field for CreatedAt {
        type SchemaType = super::DateTime;
        fn name() -> &'static str {
            "createdAt"
        }
    }
    impl ::cynic::schema::HasField<CreatedAt, super::DateTime> for super::Commitment {}
    pub struct UpdatedAt;
    impl ::cynic::schema::Field for UpdatedAt {
        type SchemaType = super::DateTime;
        fn name() -> &'static str {
            "updatedAt"
        }
    }
    impl ::cynic::schema::HasField<UpdatedAt, super::DateTime> for super::Commitment {}
}
pub struct CommitmentWhereInput {}
pub struct Company;
pub mod company_fields {
    pub struct Id;
    impl ::cynic::schema::Field for Id {
        type SchemaType = super::Id;
        fn name() -> &'static str {
            "id"
        }
    }
    impl ::cynic::schema::HasField<Id, super::Id> for super::Company {}
    pub struct Name;
    impl ::cynic::schema::Field for Name {
        type SchemaType = super::String;
        fn name() -> &'static str {
            "name"
        }
    }
    impl ::cynic::schema::HasField<Name, super::String> for super::Company {}
    pub struct Slug;
    impl ::cynic::schema::Field for Slug {
        type SchemaType = super::String;
        fn name() -> &'static str {
            "slug"
        }
    }
    impl ::cynic::schema::HasField<Slug, super::String> for super::Company {}
    pub struct WebsiteUrl;
    impl ::cynic::schema::Field for WebsiteUrl {
        type SchemaType = super::String;
        fn name() -> &'static str {
            "websiteUrl"
        }
    }
    impl ::cynic::schema::HasField<WebsiteUrl, super::String> for super::Company {}
    pub struct LogoUrl;
    impl ::cynic::schema::Field for LogoUrl {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "logoUrl"
        }
    }
    impl ::cynic::schema::HasField<LogoUrl, Option<super::String>> for super::Company {}
    pub struct Jobs;
    impl ::cynic::schema::Field for Jobs {
        type SchemaType = Option<Vec<super::Job>>;
        fn name() -> &'static str {
            "jobs"
        }
    }
    impl ::cynic::schema::HasField<Jobs, Option<Vec<super::Job>>> for super::Company {}
    pub mod jobs_arguments {
        pub struct Where;
        impl ::cynic::schema::HasArgument<Where> for super::Jobs {
            type ArgumentSchemaType = Option<super::super::JobWhereInput>;
            type ArgumentKind = ::cynic::schema::InputObjectArgument;
            fn name() -> &'static str {
                "where"
            }
        }
        pub struct OrderBy;
        impl ::cynic::schema::HasArgument<OrderBy> for super::Jobs {
            type ArgumentSchemaType = Option<super::super::JobOrderByInput>;
            type ArgumentKind = ::cynic::schema::EnumArgument;
            fn name() -> &'static str {
                "orderBy"
            }
        }
        pub struct Skip;
        impl ::cynic::schema::HasArgument<Skip> for super::Jobs {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "skip"
            }
        }
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::Jobs {
            type ArgumentSchemaType = Option<super::super::String>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "after"
            }
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::Jobs {
            type ArgumentSchemaType = Option<super::super::String>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "before"
            }
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::Jobs {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "first"
            }
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::Jobs {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "last"
            }
        }
    }
    pub struct Twitter;
    impl ::cynic::schema::Field for Twitter {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "twitter"
        }
    }
    impl ::cynic::schema::HasField<Twitter, Option<super::String>> for super::Company {}
    pub struct Emailed;
    impl ::cynic::schema::Field for Emailed {
        type SchemaType = Option<super::Boolean>;
        fn name() -> &'static str {
            "emailed"
        }
    }
    impl ::cynic::schema::HasField<Emailed, Option<super::Boolean>> for super::Company {}
    pub struct CreatedAt;
    impl ::cynic::schema::Field for CreatedAt {
        type SchemaType = super::DateTime;
        fn name() -> &'static str {
            "createdAt"
        }
    }
    impl ::cynic::schema::HasField<CreatedAt, super::DateTime> for super::Company {}
    pub struct UpdatedAt;
    impl ::cynic::schema::Field for UpdatedAt {
        type SchemaType = super::DateTime;
        fn name() -> &'static str {
            "updatedAt"
        }
    }
    impl ::cynic::schema::HasField<UpdatedAt, super::DateTime> for super::Company {}
}
pub struct CompanyWhereInput {}
pub struct Country;
pub mod country_fields {
    pub struct Id;
    impl ::cynic::schema::Field for Id {
        type SchemaType = super::Id;
        fn name() -> &'static str {
            "id"
        }
    }
    impl ::cynic::schema::HasField<Id, super::Id> for super::Country {}
    pub struct Name;
    impl ::cynic::schema::Field for Name {
        type SchemaType = super::String;
        fn name() -> &'static str {
            "name"
        }
    }
    impl ::cynic::schema::HasField<Name, super::String> for super::Country {}
    pub struct Slug;
    impl ::cynic::schema::Field for Slug {
        type SchemaType = super::String;
        fn name() -> &'static str {
            "slug"
        }
    }
    impl ::cynic::schema::HasField<Slug, super::String> for super::Country {}
    pub struct Type;
    impl ::cynic::schema::Field for Type {
        type SchemaType = super::String;
        fn name() -> &'static str {
            "type"
        }
    }
    impl ::cynic::schema::HasField<Type, super::String> for super::Country {}
    pub struct IsoCode;
    impl ::cynic::schema::Field for IsoCode {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "isoCode"
        }
    }
    impl ::cynic::schema::HasField<IsoCode, Option<super::String>> for super::Country {}
    pub struct Cities;
    impl ::cynic::schema::Field for Cities {
        type SchemaType = Option<Vec<super::City>>;
        fn name() -> &'static str {
            "cities"
        }
    }
    impl ::cynic::schema::HasField<Cities, Option<Vec<super::City>>> for super::Country {}
    pub mod cities_arguments {
        pub struct Where;
        impl ::cynic::schema::HasArgument<Where> for super::Cities {
            type ArgumentSchemaType = Option<super::super::CityWhereInput>;
            type ArgumentKind = ::cynic::schema::InputObjectArgument;
            fn name() -> &'static str {
                "where"
            }
        }
        pub struct OrderBy;
        impl ::cynic::schema::HasArgument<OrderBy> for super::Cities {
            type ArgumentSchemaType = Option<super::super::CityOrderByInput>;
            type ArgumentKind = ::cynic::schema::EnumArgument;
            fn name() -> &'static str {
                "orderBy"
            }
        }
        pub struct Skip;
        impl ::cynic::schema::HasArgument<Skip> for super::Cities {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "skip"
            }
        }
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::Cities {
            type ArgumentSchemaType = Option<super::super::String>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "after"
            }
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::Cities {
            type ArgumentSchemaType = Option<super::super::String>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "before"
            }
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::Cities {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "first"
            }
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::Cities {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "last"
            }
        }
    }
    pub struct Jobs;
    impl ::cynic::schema::Field for Jobs {
        type SchemaType = Option<Vec<super::Job>>;
        fn name() -> &'static str {
            "jobs"
        }
    }
    impl ::cynic::schema::HasField<Jobs, Option<Vec<super::Job>>> for super::Country {}
    pub mod jobs_arguments {
        pub struct Where;
        impl ::cynic::schema::HasArgument<Where> for super::Jobs {
            type ArgumentSchemaType = Option<super::super::JobWhereInput>;
            type ArgumentKind = ::cynic::schema::InputObjectArgument;
            fn name() -> &'static str {
                "where"
            }
        }
        pub struct OrderBy;
        impl ::cynic::schema::HasArgument<OrderBy> for super::Jobs {
            type ArgumentSchemaType = Option<super::super::JobOrderByInput>;
            type ArgumentKind = ::cynic::schema::EnumArgument;
            fn name() -> &'static str {
                "orderBy"
            }
        }
        pub struct Skip;
        impl ::cynic::schema::HasArgument<Skip> for super::Jobs {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "skip"
            }
        }
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::Jobs {
            type ArgumentSchemaType = Option<super::super::String>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "after"
            }
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::Jobs {
            type ArgumentSchemaType = Option<super::super::String>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "before"
            }
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::Jobs {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "first"
            }
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::Jobs {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "last"
            }
        }
    }
    pub struct CreatedAt;
    impl ::cynic::schema::Field for CreatedAt {
        type SchemaType = super::DateTime;
        fn name() -> &'static str {
            "createdAt"
        }
    }
    impl ::cynic::schema::HasField<CreatedAt, super::DateTime> for super::Country {}
    pub struct UpdatedAt;
    impl ::cynic::schema::Field for UpdatedAt {
        type SchemaType = super::DateTime;
        fn name() -> &'static str {
            "updatedAt"
        }
    }
    impl ::cynic::schema::HasField<UpdatedAt, super::DateTime> for super::Country {}
}
pub struct CountryOrderByInput {}
pub struct CountryWhereInput {}
pub struct DateTime {}
pub struct Job;
pub mod job_fields {
    pub struct Id;
    impl ::cynic::schema::Field for Id {
        type SchemaType = super::Id;
        fn name() -> &'static str {
            "id"
        }
    }
    impl ::cynic::schema::HasField<Id, super::Id> for super::Job {}
    pub struct Title;
    impl ::cynic::schema::Field for Title {
        type SchemaType = super::String;
        fn name() -> &'static str {
            "title"
        }
    }
    impl ::cynic::schema::HasField<Title, super::String> for super::Job {}
    pub struct Slug;
    impl ::cynic::schema::Field for Slug {
        type SchemaType = super::String;
        fn name() -> &'static str {
            "slug"
        }
    }
    impl ::cynic::schema::HasField<Slug, super::String> for super::Job {}
    pub struct Commitment;
    impl ::cynic::schema::Field for Commitment {
        type SchemaType = super::Commitment;
        fn name() -> &'static str {
            "commitment"
        }
    }
    impl ::cynic::schema::HasField<Commitment, super::Commitment> for super::Job {}
    pub struct Cities;
    impl ::cynic::schema::Field for Cities {
        type SchemaType = Option<Vec<super::City>>;
        fn name() -> &'static str {
            "cities"
        }
    }
    impl ::cynic::schema::HasField<Cities, Option<Vec<super::City>>> for super::Job {}
    pub mod cities_arguments {
        pub struct Where;
        impl ::cynic::schema::HasArgument<Where> for super::Cities {
            type ArgumentSchemaType = Option<super::super::CityWhereInput>;
            type ArgumentKind = ::cynic::schema::InputObjectArgument;
            fn name() -> &'static str {
                "where"
            }
        }
        pub struct OrderBy;
        impl ::cynic::schema::HasArgument<OrderBy> for super::Cities {
            type ArgumentSchemaType = Option<super::super::CityOrderByInput>;
            type ArgumentKind = ::cynic::schema::EnumArgument;
            fn name() -> &'static str {
                "orderBy"
            }
        }
        pub struct Skip;
        impl ::cynic::schema::HasArgument<Skip> for super::Cities {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "skip"
            }
        }
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::Cities {
            type ArgumentSchemaType = Option<super::super::String>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "after"
            }
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::Cities {
            type ArgumentSchemaType = Option<super::super::String>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "before"
            }
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::Cities {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "first"
            }
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::Cities {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "last"
            }
        }
    }
    pub struct Countries;
    impl ::cynic::schema::Field for Countries {
        type SchemaType = Option<Vec<super::Country>>;
        fn name() -> &'static str {
            "countries"
        }
    }
    impl ::cynic::schema::HasField<Countries, Option<Vec<super::Country>>> for super::Job {}
    pub mod countries_arguments {
        pub struct Where;
        impl ::cynic::schema::HasArgument<Where> for super::Countries {
            type ArgumentSchemaType = Option<super::super::CountryWhereInput>;
            type ArgumentKind = ::cynic::schema::InputObjectArgument;
            fn name() -> &'static str {
                "where"
            }
        }
        pub struct OrderBy;
        impl ::cynic::schema::HasArgument<OrderBy> for super::Countries {
            type ArgumentSchemaType = Option<super::super::CountryOrderByInput>;
            type ArgumentKind = ::cynic::schema::EnumArgument;
            fn name() -> &'static str {
                "orderBy"
            }
        }
        pub struct Skip;
        impl ::cynic::schema::HasArgument<Skip> for super::Countries {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "skip"
            }
        }
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::Countries {
            type ArgumentSchemaType = Option<super::super::String>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "after"
            }
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::Countries {
            type ArgumentSchemaType = Option<super::super::String>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "before"
            }
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::Countries {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "first"
            }
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::Countries {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "last"
            }
        }
    }
    pub struct Remotes;
    impl ::cynic::schema::Field for Remotes {
        type SchemaType = Option<Vec<super::Remote>>;
        fn name() -> &'static str {
            "remotes"
        }
    }
    impl ::cynic::schema::HasField<Remotes, Option<Vec<super::Remote>>> for super::Job {}
    pub mod remotes_arguments {
        pub struct Where;
        impl ::cynic::schema::HasArgument<Where> for super::Remotes {
            type ArgumentSchemaType = Option<super::super::RemoteWhereInput>;
            type ArgumentKind = ::cynic::schema::InputObjectArgument;
            fn name() -> &'static str {
                "where"
            }
        }
        pub struct OrderBy;
        impl ::cynic::schema::HasArgument<OrderBy> for super::Remotes {
            type ArgumentSchemaType = Option<super::super::RemoteOrderByInput>;
            type ArgumentKind = ::cynic::schema::EnumArgument;
            fn name() -> &'static str {
                "orderBy"
            }
        }
        pub struct Skip;
        impl ::cynic::schema::HasArgument<Skip> for super::Remotes {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "skip"
            }
        }
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::Remotes {
            type ArgumentSchemaType = Option<super::super::String>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "after"
            }
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::Remotes {
            type ArgumentSchemaType = Option<super::super::String>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "before"
            }
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::Remotes {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "first"
            }
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::Remotes {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "last"
            }
        }
    }
    pub struct Description;
    impl ::cynic::schema::Field for Description {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "description"
        }
    }
    impl ::cynic::schema::HasField<Description, Option<super::String>> for super::Job {}
    pub struct ApplyUrl;
    impl ::cynic::schema::Field for ApplyUrl {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "applyUrl"
        }
    }
    impl ::cynic::schema::HasField<ApplyUrl, Option<super::String>> for super::Job {}
    pub struct Company;
    impl ::cynic::schema::Field for Company {
        type SchemaType = Option<super::Company>;
        fn name() -> &'static str {
            "company"
        }
    }
    impl ::cynic::schema::HasField<Company, Option<super::Company>> for super::Job {}
    pub struct Tags;
    impl ::cynic::schema::Field for Tags {
        type SchemaType = Option<Vec<super::Tag>>;
        fn name() -> &'static str {
            "tags"
        }
    }
    impl ::cynic::schema::HasField<Tags, Option<Vec<super::Tag>>> for super::Job {}
    pub mod tags_arguments {
        pub struct Where;
        impl ::cynic::schema::HasArgument<Where> for super::Tags {
            type ArgumentSchemaType = Option<super::super::TagWhereInput>;
            type ArgumentKind = ::cynic::schema::InputObjectArgument;
            fn name() -> &'static str {
                "where"
            }
        }
        pub struct OrderBy;
        impl ::cynic::schema::HasArgument<OrderBy> for super::Tags {
            type ArgumentSchemaType = Option<super::super::TagOrderByInput>;
            type ArgumentKind = ::cynic::schema::EnumArgument;
            fn name() -> &'static str {
                "orderBy"
            }
        }
        pub struct Skip;
        impl ::cynic::schema::HasArgument<Skip> for super::Tags {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "skip"
            }
        }
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::Tags {
            type ArgumentSchemaType = Option<super::super::String>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "after"
            }
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::Tags {
            type ArgumentSchemaType = Option<super::super::String>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "before"
            }
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::Tags {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "first"
            }
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::Tags {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "last"
            }
        }
    }
    pub struct IsPublished;
    impl ::cynic::schema::Field for IsPublished {
        type SchemaType = Option<super::Boolean>;
        fn name() -> &'static str {
            "isPublished"
        }
    }
    impl ::cynic::schema::HasField<IsPublished, Option<super::Boolean>> for super::Job {}
    pub struct IsFeatured;
    impl ::cynic::schema::Field for IsFeatured {
        type SchemaType = Option<super::Boolean>;
        fn name() -> &'static str {
            "isFeatured"
        }
    }
    impl ::cynic::schema::HasField<IsFeatured, Option<super::Boolean>> for super::Job {}
    pub struct LocationNames;
    impl ::cynic::schema::Field for LocationNames {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "locationNames"
        }
    }
    impl ::cynic::schema::HasField<LocationNames, Option<super::String>> for super::Job {}
    pub struct UserEmail;
    impl ::cynic::schema::Field for UserEmail {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "userEmail"
        }
    }
    impl ::cynic::schema::HasField<UserEmail, Option<super::String>> for super::Job {}
    pub struct PostedAt;
    impl ::cynic::schema::Field for PostedAt {
        type SchemaType = super::DateTime;
        fn name() -> &'static str {
            "postedAt"
        }
    }
    impl ::cynic::schema::HasField<PostedAt, super::DateTime> for super::Job {}
    pub struct CreatedAt;
    impl ::cynic::schema::Field for CreatedAt {
        type SchemaType = super::DateTime;
        fn name() -> &'static str {
            "createdAt"
        }
    }
    impl ::cynic::schema::HasField<CreatedAt, super::DateTime> for super::Job {}
    pub struct UpdatedAt;
    impl ::cynic::schema::Field for UpdatedAt {
        type SchemaType = super::DateTime;
        fn name() -> &'static str {
            "updatedAt"
        }
    }
    impl ::cynic::schema::HasField<UpdatedAt, super::DateTime> for super::Job {}
}
pub struct JobInput {}
pub struct JobOrderByInput {}
pub struct JobWhereInput {}
pub struct JobsInput {}
pub struct Location;
pub mod location_fields {
    pub struct Id;
    impl ::cynic::schema::Field for Id {
        type SchemaType = super::Id;
        fn name() -> &'static str {
            "id"
        }
    }
    impl ::cynic::schema::HasField<Id, super::Id> for super::Location {}
    pub struct Slug;
    impl ::cynic::schema::Field for Slug {
        type SchemaType = super::String;
        fn name() -> &'static str {
            "slug"
        }
    }
    impl ::cynic::schema::HasField<Slug, super::String> for super::Location {}
    pub struct Name;
    impl ::cynic::schema::Field for Name {
        type SchemaType = super::String;
        fn name() -> &'static str {
            "name"
        }
    }
    impl ::cynic::schema::HasField<Name, super::String> for super::Location {}
    pub struct Type;
    impl ::cynic::schema::Field for Type {
        type SchemaType = super::String;
        fn name() -> &'static str {
            "type"
        }
    }
    impl ::cynic::schema::HasField<Type, super::String> for super::Location {}
}
pub struct LocationInput {}
pub struct LocationsInput {}
pub struct Mutation;
pub mod mutation_fields {
    pub struct Subscribe;
    impl ::cynic::schema::Field for Subscribe {
        type SchemaType = super::User;
        fn name() -> &'static str {
            "subscribe"
        }
    }
    impl ::cynic::schema::HasField<Subscribe, super::User> for super::Mutation {}
    pub mod subscribe_arguments {
        pub struct Input;
        impl ::cynic::schema::HasArgument<Input> for super::Subscribe {
            type ArgumentSchemaType = super::super::SubscribeInput;
            type ArgumentKind = ::cynic::schema::InputObjectArgument;
            fn name() -> &'static str {
                "input"
            }
        }
    }
    pub struct PostJob;
    impl ::cynic::schema::Field for PostJob {
        type SchemaType = super::Job;
        fn name() -> &'static str {
            "postJob"
        }
    }
    impl ::cynic::schema::HasField<PostJob, super::Job> for super::Mutation {}
    pub mod post_job_arguments {
        pub struct Input;
        impl ::cynic::schema::HasArgument<Input> for super::PostJob {
            type ArgumentSchemaType = super::super::PostJobInput;
            type ArgumentKind = ::cynic::schema::InputObjectArgument;
            fn name() -> &'static str {
                "input"
            }
        }
    }
    pub struct UpdateJob;
    impl ::cynic::schema::Field for UpdateJob {
        type SchemaType = super::Job;
        fn name() -> &'static str {
            "updateJob"
        }
    }
    impl ::cynic::schema::HasField<UpdateJob, super::Job> for super::Mutation {}
    pub mod update_job_arguments {
        pub struct Input;
        impl ::cynic::schema::HasArgument<Input> for super::UpdateJob {
            type ArgumentSchemaType = super::super::UpdateJobInput;
            type ArgumentKind = ::cynic::schema::InputObjectArgument;
            fn name() -> &'static str {
                "input"
            }
        }
        pub struct AdminSecret;
        impl ::cynic::schema::HasArgument<AdminSecret> for super::UpdateJob {
            type ArgumentSchemaType = super::super::String;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "adminSecret"
            }
        }
    }
    pub struct UpdateCompany;
    impl ::cynic::schema::Field for UpdateCompany {
        type SchemaType = super::Company;
        fn name() -> &'static str {
            "updateCompany"
        }
    }
    impl ::cynic::schema::HasField<UpdateCompany, super::Company> for super::Mutation {}
    pub mod update_company_arguments {
        pub struct Input;
        impl ::cynic::schema::HasArgument<Input> for super::UpdateCompany {
            type ArgumentSchemaType = super::super::UpdateCompanyInput;
            type ArgumentKind = ::cynic::schema::InputObjectArgument;
            fn name() -> &'static str {
                "input"
            }
        }
        pub struct AdminSecret;
        impl ::cynic::schema::HasArgument<AdminSecret> for super::UpdateCompany {
            type ArgumentSchemaType = super::super::String;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "adminSecret"
            }
        }
    }
}
pub struct PostJobInput {}
pub struct Query;
pub mod query_fields {
    pub struct Jobs;
    impl ::cynic::schema::Field for Jobs {
        type SchemaType = Vec<super::Job>;
        fn name() -> &'static str {
            "jobs"
        }
    }
    impl ::cynic::schema::HasField<Jobs, Vec<super::Job>> for super::Query {}
    pub mod jobs_arguments {
        pub struct Input;
        impl ::cynic::schema::HasArgument<Input> for super::Jobs {
            type ArgumentSchemaType = Option<super::super::JobsInput>;
            type ArgumentKind = ::cynic::schema::InputObjectArgument;
            fn name() -> &'static str {
                "input"
            }
        }
    }
    pub struct Job;
    impl ::cynic::schema::Field for Job {
        type SchemaType = super::Job;
        fn name() -> &'static str {
            "job"
        }
    }
    impl ::cynic::schema::HasField<Job, super::Job> for super::Query {}
    pub mod job_arguments {
        pub struct Input;
        impl ::cynic::schema::HasArgument<Input> for super::Job {
            type ArgumentSchemaType = super::super::JobInput;
            type ArgumentKind = ::cynic::schema::InputObjectArgument;
            fn name() -> &'static str {
                "input"
            }
        }
    }
    pub struct Locations;
    impl ::cynic::schema::Field for Locations {
        type SchemaType = Vec<super::Location>;
        fn name() -> &'static str {
            "locations"
        }
    }
    impl ::cynic::schema::HasField<Locations, Vec<super::Location>> for super::Query {}
    pub mod locations_arguments {
        pub struct Input;
        impl ::cynic::schema::HasArgument<Input> for super::Locations {
            type ArgumentSchemaType = super::super::LocationsInput;
            type ArgumentKind = ::cynic::schema::InputObjectArgument;
            fn name() -> &'static str {
                "input"
            }
        }
    }
    pub struct City;
    impl ::cynic::schema::Field for City {
        type SchemaType = super::City;
        fn name() -> &'static str {
            "city"
        }
    }
    impl ::cynic::schema::HasField<City, super::City> for super::Query {}
    pub mod city_arguments {
        pub struct Input;
        impl ::cynic::schema::HasArgument<Input> for super::City {
            type ArgumentSchemaType = super::super::LocationInput;
            type ArgumentKind = ::cynic::schema::InputObjectArgument;
            fn name() -> &'static str {
                "input"
            }
        }
    }
    pub struct Country;
    impl ::cynic::schema::Field for Country {
        type SchemaType = super::Country;
        fn name() -> &'static str {
            "country"
        }
    }
    impl ::cynic::schema::HasField<Country, super::Country> for super::Query {}
    pub mod country_arguments {
        pub struct Input;
        impl ::cynic::schema::HasArgument<Input> for super::Country {
            type ArgumentSchemaType = super::super::LocationInput;
            type ArgumentKind = ::cynic::schema::InputObjectArgument;
            fn name() -> &'static str {
                "input"
            }
        }
    }
    pub struct Remote;
    impl ::cynic::schema::Field for Remote {
        type SchemaType = super::Remote;
        fn name() -> &'static str {
            "remote"
        }
    }
    impl ::cynic::schema::HasField<Remote, super::Remote> for super::Query {}
    pub mod remote_arguments {
        pub struct Input;
        impl ::cynic::schema::HasArgument<Input> for super::Remote {
            type ArgumentSchemaType = super::super::LocationInput;
            type ArgumentKind = ::cynic::schema::InputObjectArgument;
            fn name() -> &'static str {
                "input"
            }
        }
    }
    pub struct Commitments;
    impl ::cynic::schema::Field for Commitments {
        type SchemaType = Vec<super::Commitment>;
        fn name() -> &'static str {
            "commitments"
        }
    }
    impl ::cynic::schema::HasField<Commitments, Vec<super::Commitment>> for super::Query {}
    pub struct Cities;
    impl ::cynic::schema::Field for Cities {
        type SchemaType = Vec<super::City>;
        fn name() -> &'static str {
            "cities"
        }
    }
    impl ::cynic::schema::HasField<Cities, Vec<super::City>> for super::Query {}
    pub struct Countries;
    impl ::cynic::schema::Field for Countries {
        type SchemaType = Vec<super::Country>;
        fn name() -> &'static str {
            "countries"
        }
    }
    impl ::cynic::schema::HasField<Countries, Vec<super::Country>> for super::Query {}
    pub struct Remotes;
    impl ::cynic::schema::Field for Remotes {
        type SchemaType = Vec<super::Remote>;
        fn name() -> &'static str {
            "remotes"
        }
    }
    impl ::cynic::schema::HasField<Remotes, Vec<super::Remote>> for super::Query {}
    pub struct Companies;
    impl ::cynic::schema::Field for Companies {
        type SchemaType = Vec<super::Company>;
        fn name() -> &'static str {
            "companies"
        }
    }
    impl ::cynic::schema::HasField<Companies, Vec<super::Company>> for super::Query {}
}
pub struct Remote;
pub mod remote_fields {
    pub struct Id;
    impl ::cynic::schema::Field for Id {
        type SchemaType = super::Id;
        fn name() -> &'static str {
            "id"
        }
    }
    impl ::cynic::schema::HasField<Id, super::Id> for super::Remote {}
    pub struct Name;
    impl ::cynic::schema::Field for Name {
        type SchemaType = super::String;
        fn name() -> &'static str {
            "name"
        }
    }
    impl ::cynic::schema::HasField<Name, super::String> for super::Remote {}
    pub struct Slug;
    impl ::cynic::schema::Field for Slug {
        type SchemaType = super::String;
        fn name() -> &'static str {
            "slug"
        }
    }
    impl ::cynic::schema::HasField<Slug, super::String> for super::Remote {}
    pub struct Type;
    impl ::cynic::schema::Field for Type {
        type SchemaType = super::String;
        fn name() -> &'static str {
            "type"
        }
    }
    impl ::cynic::schema::HasField<Type, super::String> for super::Remote {}
    pub struct Jobs;
    impl ::cynic::schema::Field for Jobs {
        type SchemaType = Option<Vec<super::Job>>;
        fn name() -> &'static str {
            "jobs"
        }
    }
    impl ::cynic::schema::HasField<Jobs, Option<Vec<super::Job>>> for super::Remote {}
    pub mod jobs_arguments {
        pub struct Where;
        impl ::cynic::schema::HasArgument<Where> for super::Jobs {
            type ArgumentSchemaType = Option<super::super::JobWhereInput>;
            type ArgumentKind = ::cynic::schema::InputObjectArgument;
            fn name() -> &'static str {
                "where"
            }
        }
        pub struct OrderBy;
        impl ::cynic::schema::HasArgument<OrderBy> for super::Jobs {
            type ArgumentSchemaType = Option<super::super::JobOrderByInput>;
            type ArgumentKind = ::cynic::schema::EnumArgument;
            fn name() -> &'static str {
                "orderBy"
            }
        }
        pub struct Skip;
        impl ::cynic::schema::HasArgument<Skip> for super::Jobs {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "skip"
            }
        }
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::Jobs {
            type ArgumentSchemaType = Option<super::super::String>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "after"
            }
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::Jobs {
            type ArgumentSchemaType = Option<super::super::String>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "before"
            }
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::Jobs {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "first"
            }
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::Jobs {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "last"
            }
        }
    }
    pub struct CreatedAt;
    impl ::cynic::schema::Field for CreatedAt {
        type SchemaType = super::DateTime;
        fn name() -> &'static str {
            "createdAt"
        }
    }
    impl ::cynic::schema::HasField<CreatedAt, super::DateTime> for super::Remote {}
    pub struct UpdatedAt;
    impl ::cynic::schema::Field for UpdatedAt {
        type SchemaType = super::DateTime;
        fn name() -> &'static str {
            "updatedAt"
        }
    }
    impl ::cynic::schema::HasField<UpdatedAt, super::DateTime> for super::Remote {}
}
pub struct RemoteOrderByInput {}
pub struct RemoteWhereInput {}
pub struct SubscribeInput {}
pub struct Tag;
pub mod tag_fields {
    pub struct Id;
    impl ::cynic::schema::Field for Id {
        type SchemaType = super::Id;
        fn name() -> &'static str {
            "id"
        }
    }
    impl ::cynic::schema::HasField<Id, super::Id> for super::Tag {}
    pub struct Name;
    impl ::cynic::schema::Field for Name {
        type SchemaType = super::String;
        fn name() -> &'static str {
            "name"
        }
    }
    impl ::cynic::schema::HasField<Name, super::String> for super::Tag {}
    pub struct Slug;
    impl ::cynic::schema::Field for Slug {
        type SchemaType = super::String;
        fn name() -> &'static str {
            "slug"
        }
    }
    impl ::cynic::schema::HasField<Slug, super::String> for super::Tag {}
    pub struct Jobs;
    impl ::cynic::schema::Field for Jobs {
        type SchemaType = Option<Vec<super::Job>>;
        fn name() -> &'static str {
            "jobs"
        }
    }
    impl ::cynic::schema::HasField<Jobs, Option<Vec<super::Job>>> for super::Tag {}
    pub mod jobs_arguments {
        pub struct Where;
        impl ::cynic::schema::HasArgument<Where> for super::Jobs {
            type ArgumentSchemaType = Option<super::super::JobWhereInput>;
            type ArgumentKind = ::cynic::schema::InputObjectArgument;
            fn name() -> &'static str {
                "where"
            }
        }
        pub struct OrderBy;
        impl ::cynic::schema::HasArgument<OrderBy> for super::Jobs {
            type ArgumentSchemaType = Option<super::super::JobOrderByInput>;
            type ArgumentKind = ::cynic::schema::EnumArgument;
            fn name() -> &'static str {
                "orderBy"
            }
        }
        pub struct Skip;
        impl ::cynic::schema::HasArgument<Skip> for super::Jobs {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "skip"
            }
        }
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::Jobs {
            type ArgumentSchemaType = Option<super::super::String>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "after"
            }
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::Jobs {
            type ArgumentSchemaType = Option<super::super::String>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "before"
            }
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::Jobs {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "first"
            }
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::Jobs {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "last"
            }
        }
    }
    pub struct CreatedAt;
    impl ::cynic::schema::Field for CreatedAt {
        type SchemaType = super::DateTime;
        fn name() -> &'static str {
            "createdAt"
        }
    }
    impl ::cynic::schema::HasField<CreatedAt, super::DateTime> for super::Tag {}
    pub struct UpdatedAt;
    impl ::cynic::schema::Field for UpdatedAt {
        type SchemaType = super::DateTime;
        fn name() -> &'static str {
            "updatedAt"
        }
    }
    impl ::cynic::schema::HasField<UpdatedAt, super::DateTime> for super::Tag {}
}
pub struct TagOrderByInput {}
pub struct TagWhereInput {}
pub struct UpdateCompanyInput {}
pub struct UpdateJobInput {}
pub struct User;
pub mod user_fields {
    pub struct Id;
    impl ::cynic::schema::Field for Id {
        type SchemaType = super::Id;
        fn name() -> &'static str {
            "id"
        }
    }
    impl ::cynic::schema::HasField<Id, super::Id> for super::User {}
    pub struct Name;
    impl ::cynic::schema::Field for Name {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "name"
        }
    }
    impl ::cynic::schema::HasField<Name, Option<super::String>> for super::User {}
    pub struct Email;
    impl ::cynic::schema::Field for Email {
        type SchemaType = super::String;
        fn name() -> &'static str {
            "email"
        }
    }
    impl ::cynic::schema::HasField<Email, super::String> for super::User {}
    pub struct Subscribe;
    impl ::cynic::schema::Field for Subscribe {
        type SchemaType = super::Boolean;
        fn name() -> &'static str {
            "subscribe"
        }
    }
    impl ::cynic::schema::HasField<Subscribe, super::Boolean> for super::User {}
    pub struct CreatedAt;
    impl ::cynic::schema::Field for CreatedAt {
        type SchemaType = super::DateTime;
        fn name() -> &'static str {
            "createdAt"
        }
    }
    impl ::cynic::schema::HasField<CreatedAt, super::DateTime> for super::User {}
    pub struct UpdatedAt;
    impl ::cynic::schema::Field for UpdatedAt {
        type SchemaType = super::DateTime;
        fn name() -> &'static str {
            "updatedAt"
        }
    }
    impl ::cynic::schema::HasField<UpdatedAt, super::DateTime> for super::User {}
}
impl ::cynic::schema::NamedType for City {
    fn name() -> &'static str {
        "City"
    }
}
impl ::cynic::schema::NamedType for Commitment {
    fn name() -> &'static str {
        "Commitment"
    }
}
impl ::cynic::schema::NamedType for Company {
    fn name() -> &'static str {
        "Company"
    }
}
impl ::cynic::schema::NamedType for Country {
    fn name() -> &'static str {
        "Country"
    }
}
impl ::cynic::schema::NamedType for Job {
    fn name() -> &'static str {
        "Job"
    }
}
impl ::cynic::schema::NamedType for Location {
    fn name() -> &'static str {
        "Location"
    }
}
impl ::cynic::schema::NamedType for Mutation {
    fn name() -> &'static str {
        "Mutation"
    }
}
impl ::cynic::schema::NamedType for Query {
    fn name() -> &'static str {
        "Query"
    }
}
impl ::cynic::schema::NamedType for Remote {
    fn name() -> &'static str {
        "Remote"
    }
}
impl ::cynic::schema::NamedType for Tag {
    fn name() -> &'static str {
        "Tag"
    }
}
impl ::cynic::schema::NamedType for User {
    fn name() -> &'static str {
        "User"
    }
}
pub type Boolean = bool;
pub type String = std::string::String;
pub type Float = f64;
pub type Int = i32;
pub type Id = ::cynic::Id;
pub mod variable {
    use cynic::core::VariableType;
    #[doc = r" Used to determine the type of a given variable that"]
    #[doc = r" appears in an argument struct."]
    pub trait Variable {
        const TYPE: VariableType;
    }
    impl<T> Variable for &T
    where
        T: Variable,
    {
        const TYPE: VariableType = T::TYPE;
    }
    impl<T> Variable for Option<T>
    where
        T: Variable,
    {
        const TYPE: VariableType = VariableType::Nullable(&T::TYPE);
    }
    impl<T> Variable for Vec<T>
    where
        T: Variable,
    {
        const TYPE: VariableType = VariableType::List(&T::TYPE);
    }
    impl<T> Variable for Box<T>
    where
        T: Variable,
    {
        const TYPE: VariableType = T::TYPE;
    }
    impl<T> Variable for std::rc::Rc<T>
    where
        T: Variable,
    {
        const TYPE: VariableType = T::TYPE;
    }
    impl<T> Variable for std::sync::Arc<T>
    where
        T: Variable,
    {
        const TYPE: VariableType = T::TYPE;
    }
    impl Variable for bool {
        const TYPE: VariableType = VariableType::Named("Boolean");
    }
    impl Variable for String {
        const TYPE: VariableType = VariableType::Named("String");
    }
    impl Variable for f64 {
        const TYPE: VariableType = VariableType::Named("Float");
    }
    impl Variable for i32 {
        const TYPE: VariableType = VariableType::Named("Int");
    }
    impl Variable for ::cynic::Id {
        const TYPE: VariableType = VariableType::Named("ID");
    }
}

