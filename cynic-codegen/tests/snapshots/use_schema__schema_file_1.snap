---
source: cynic-codegen/tests/use-schema.rs
assertion_line: 25
expression: "format_code(format!(\"{}\", tokens))"

---
impl ::cynic::schema::QueryRoot for Query {}
impl ::cynic::schema::MutationRoot for Mutation {}
pub struct City;
pub mod city_fields {
    pub struct Id;
    impl ::cynic::schema::Field for Id {
        type Type = super::Id;
        const NAME: &'static str = "id";
    }
    impl ::cynic::schema::HasField<Id> for super::City {
        type Type = super::Id;
    }
    pub struct Name;
    impl ::cynic::schema::Field for Name {
        type Type = super::String;
        const NAME: &'static str = "name";
    }
    impl ::cynic::schema::HasField<Name> for super::City {
        type Type = super::String;
    }
    pub struct Slug;
    impl ::cynic::schema::Field for Slug {
        type Type = super::String;
        const NAME: &'static str = "slug";
    }
    impl ::cynic::schema::HasField<Slug> for super::City {
        type Type = super::String;
    }
    pub struct Country;
    impl ::cynic::schema::Field for Country {
        type Type = super::Country;
        const NAME: &'static str = "country";
    }
    impl ::cynic::schema::HasField<Country> for super::City {
        type Type = super::Country;
    }
    pub struct Type;
    impl ::cynic::schema::Field for Type {
        type Type = super::String;
        const NAME: &'static str = "type";
    }
    impl ::cynic::schema::HasField<Type> for super::City {
        type Type = super::String;
    }
    pub struct Jobs;
    impl ::cynic::schema::Field for Jobs {
        type Type = Option<Vec<super::Job>>;
        const NAME: &'static str = "jobs";
    }
    impl ::cynic::schema::HasField<Jobs> for super::City {
        type Type = Option<Vec<super::Job>>;
    }
    pub mod jobs_arguments {
        pub struct Where;
        impl ::cynic::schema::HasArgument<Where> for super::Jobs {
            type ArgumentType = Option<super::super::JobWhereInput>;
            const NAME: &'static str = "where";
        }
        pub struct OrderBy;
        impl ::cynic::schema::HasArgument<OrderBy> for super::Jobs {
            type ArgumentType = Option<super::super::JobOrderByInput>;
            const NAME: &'static str = "orderBy";
        }
        pub struct Skip;
        impl ::cynic::schema::HasArgument<Skip> for super::Jobs {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "skip";
        }
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::Jobs {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "after";
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::Jobs {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "before";
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::Jobs {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "first";
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::Jobs {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "last";
        }
    }
    pub struct CreatedAt;
    impl ::cynic::schema::Field for CreatedAt {
        type Type = super::DateTime;
        const NAME: &'static str = "createdAt";
    }
    impl ::cynic::schema::HasField<CreatedAt> for super::City {
        type Type = super::DateTime;
    }
    pub struct UpdatedAt;
    impl ::cynic::schema::Field for UpdatedAt {
        type Type = super::DateTime;
        const NAME: &'static str = "updatedAt";
    }
    impl ::cynic::schema::HasField<UpdatedAt> for super::City {
        type Type = super::DateTime;
    }
}
pub struct CityOrderByInput {}
pub struct CityWhereInput;
impl ::cynic::schema::InputObjectMarker for CityWhereInput {}
pub mod city_where_input_fields {
    pub struct Id;
    impl ::cynic::schema::Field for Id {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id";
    }
    impl ::cynic::schema::HasInputField<Id, Option<super::Id>> for super::CityWhereInput {}
    pub struct IdNot;
    impl ::cynic::schema::Field for IdNot {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_not";
    }
    impl ::cynic::schema::HasInputField<IdNot, Option<super::Id>> for super::CityWhereInput {}
    pub struct IdIn;
    impl ::cynic::schema::Field for IdIn {
        type Type = Option<Vec<super::Id>>;
        const NAME: &'static str = "id_in";
    }
    impl ::cynic::schema::HasInputField<IdIn, Option<Vec<super::Id>>> for super::CityWhereInput {}
    pub struct IdNotIn;
    impl ::cynic::schema::Field for IdNotIn {
        type Type = Option<Vec<super::Id>>;
        const NAME: &'static str = "id_not_in";
    }
    impl ::cynic::schema::HasInputField<IdNotIn, Option<Vec<super::Id>>> for super::CityWhereInput {}
    pub struct IdLt;
    impl ::cynic::schema::Field for IdLt {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_lt";
    }
    impl ::cynic::schema::HasInputField<IdLt, Option<super::Id>> for super::CityWhereInput {}
    pub struct IdLte;
    impl ::cynic::schema::Field for IdLte {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_lte";
    }
    impl ::cynic::schema::HasInputField<IdLte, Option<super::Id>> for super::CityWhereInput {}
    pub struct IdGt;
    impl ::cynic::schema::Field for IdGt {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_gt";
    }
    impl ::cynic::schema::HasInputField<IdGt, Option<super::Id>> for super::CityWhereInput {}
    pub struct IdGte;
    impl ::cynic::schema::Field for IdGte {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_gte";
    }
    impl ::cynic::schema::HasInputField<IdGte, Option<super::Id>> for super::CityWhereInput {}
    pub struct IdContains;
    impl ::cynic::schema::Field for IdContains {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_contains";
    }
    impl ::cynic::schema::HasInputField<IdContains, Option<super::Id>> for super::CityWhereInput {}
    pub struct IdNotContains;
    impl ::cynic::schema::Field for IdNotContains {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_not_contains";
    }
    impl ::cynic::schema::HasInputField<IdNotContains, Option<super::Id>> for super::CityWhereInput {}
    pub struct IdStartsWith;
    impl ::cynic::schema::Field for IdStartsWith {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_starts_with";
    }
    impl ::cynic::schema::HasInputField<IdStartsWith, Option<super::Id>> for super::CityWhereInput {}
    pub struct IdNotStartsWith;
    impl ::cynic::schema::Field for IdNotStartsWith {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_not_starts_with";
    }
    impl ::cynic::schema::HasInputField<IdNotStartsWith, Option<super::Id>> for super::CityWhereInput {}
    pub struct IdEndsWith;
    impl ::cynic::schema::Field for IdEndsWith {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_ends_with";
    }
    impl ::cynic::schema::HasInputField<IdEndsWith, Option<super::Id>> for super::CityWhereInput {}
    pub struct IdNotEndsWith;
    impl ::cynic::schema::Field for IdNotEndsWith {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_not_ends_with";
    }
    impl ::cynic::schema::HasInputField<IdNotEndsWith, Option<super::Id>> for super::CityWhereInput {}
    pub struct Name;
    impl ::cynic::schema::Field for Name {
        type Type = Option<super::String>;
        const NAME: &'static str = "name";
    }
    impl ::cynic::schema::HasInputField<Name, Option<super::String>> for super::CityWhereInput {}
    pub struct NameNot;
    impl ::cynic::schema::Field for NameNot {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_not";
    }
    impl ::cynic::schema::HasInputField<NameNot, Option<super::String>> for super::CityWhereInput {}
    pub struct NameIn;
    impl ::cynic::schema::Field for NameIn {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "name_in";
    }
    impl ::cynic::schema::HasInputField<NameIn, Option<Vec<super::String>>> for super::CityWhereInput {}
    pub struct NameNotIn;
    impl ::cynic::schema::Field for NameNotIn {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "name_not_in";
    }
    impl ::cynic::schema::HasInputField<NameNotIn, Option<Vec<super::String>>>
        for super::CityWhereInput
    {
    }
    pub struct NameLt;
    impl ::cynic::schema::Field for NameLt {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_lt";
    }
    impl ::cynic::schema::HasInputField<NameLt, Option<super::String>> for super::CityWhereInput {}
    pub struct NameLte;
    impl ::cynic::schema::Field for NameLte {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_lte";
    }
    impl ::cynic::schema::HasInputField<NameLte, Option<super::String>> for super::CityWhereInput {}
    pub struct NameGt;
    impl ::cynic::schema::Field for NameGt {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_gt";
    }
    impl ::cynic::schema::HasInputField<NameGt, Option<super::String>> for super::CityWhereInput {}
    pub struct NameGte;
    impl ::cynic::schema::Field for NameGte {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_gte";
    }
    impl ::cynic::schema::HasInputField<NameGte, Option<super::String>> for super::CityWhereInput {}
    pub struct NameContains;
    impl ::cynic::schema::Field for NameContains {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_contains";
    }
    impl ::cynic::schema::HasInputField<NameContains, Option<super::String>> for super::CityWhereInput {}
    pub struct NameNotContains;
    impl ::cynic::schema::Field for NameNotContains {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_not_contains";
    }
    impl ::cynic::schema::HasInputField<NameNotContains, Option<super::String>>
        for super::CityWhereInput
    {
    }
    pub struct NameStartsWith;
    impl ::cynic::schema::Field for NameStartsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_starts_with";
    }
    impl ::cynic::schema::HasInputField<NameStartsWith, Option<super::String>>
        for super::CityWhereInput
    {
    }
    pub struct NameNotStartsWith;
    impl ::cynic::schema::Field for NameNotStartsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_not_starts_with";
    }
    impl ::cynic::schema::HasInputField<NameNotStartsWith, Option<super::String>>
        for super::CityWhereInput
    {
    }
    pub struct NameEndsWith;
    impl ::cynic::schema::Field for NameEndsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_ends_with";
    }
    impl ::cynic::schema::HasInputField<NameEndsWith, Option<super::String>> for super::CityWhereInput {}
    pub struct NameNotEndsWith;
    impl ::cynic::schema::Field for NameNotEndsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_not_ends_with";
    }
    impl ::cynic::schema::HasInputField<NameNotEndsWith, Option<super::String>>
        for super::CityWhereInput
    {
    }
    pub struct Slug;
    impl ::cynic::schema::Field for Slug {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug";
    }
    impl ::cynic::schema::HasInputField<Slug, Option<super::String>> for super::CityWhereInput {}
    pub struct SlugNot;
    impl ::cynic::schema::Field for SlugNot {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_not";
    }
    impl ::cynic::schema::HasInputField<SlugNot, Option<super::String>> for super::CityWhereInput {}
    pub struct SlugIn;
    impl ::cynic::schema::Field for SlugIn {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "slug_in";
    }
    impl ::cynic::schema::HasInputField<SlugIn, Option<Vec<super::String>>> for super::CityWhereInput {}
    pub struct SlugNotIn;
    impl ::cynic::schema::Field for SlugNotIn {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "slug_not_in";
    }
    impl ::cynic::schema::HasInputField<SlugNotIn, Option<Vec<super::String>>>
        for super::CityWhereInput
    {
    }
    pub struct SlugLt;
    impl ::cynic::schema::Field for SlugLt {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_lt";
    }
    impl ::cynic::schema::HasInputField<SlugLt, Option<super::String>> for super::CityWhereInput {}
    pub struct SlugLte;
    impl ::cynic::schema::Field for SlugLte {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_lte";
    }
    impl ::cynic::schema::HasInputField<SlugLte, Option<super::String>> for super::CityWhereInput {}
    pub struct SlugGt;
    impl ::cynic::schema::Field for SlugGt {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_gt";
    }
    impl ::cynic::schema::HasInputField<SlugGt, Option<super::String>> for super::CityWhereInput {}
    pub struct SlugGte;
    impl ::cynic::schema::Field for SlugGte {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_gte";
    }
    impl ::cynic::schema::HasInputField<SlugGte, Option<super::String>> for super::CityWhereInput {}
    pub struct SlugContains;
    impl ::cynic::schema::Field for SlugContains {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_contains";
    }
    impl ::cynic::schema::HasInputField<SlugContains, Option<super::String>> for super::CityWhereInput {}
    pub struct SlugNotContains;
    impl ::cynic::schema::Field for SlugNotContains {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_not_contains";
    }
    impl ::cynic::schema::HasInputField<SlugNotContains, Option<super::String>>
        for super::CityWhereInput
    {
    }
    pub struct SlugStartsWith;
    impl ::cynic::schema::Field for SlugStartsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_starts_with";
    }
    impl ::cynic::schema::HasInputField<SlugStartsWith, Option<super::String>>
        for super::CityWhereInput
    {
    }
    pub struct SlugNotStartsWith;
    impl ::cynic::schema::Field for SlugNotStartsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_not_starts_with";
    }
    impl ::cynic::schema::HasInputField<SlugNotStartsWith, Option<super::String>>
        for super::CityWhereInput
    {
    }
    pub struct SlugEndsWith;
    impl ::cynic::schema::Field for SlugEndsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_ends_with";
    }
    impl ::cynic::schema::HasInputField<SlugEndsWith, Option<super::String>> for super::CityWhereInput {}
    pub struct SlugNotEndsWith;
    impl ::cynic::schema::Field for SlugNotEndsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_not_ends_with";
    }
    impl ::cynic::schema::HasInputField<SlugNotEndsWith, Option<super::String>>
        for super::CityWhereInput
    {
    }
    pub struct Country;
    impl ::cynic::schema::Field for Country {
        type Type = Option<super::CountryWhereInput>;
        const NAME: &'static str = "country";
    }
    impl ::cynic::schema::HasInputField<Country, Option<super::CountryWhereInput>>
        for super::CityWhereInput
    {
    }
    pub struct Type;
    impl ::cynic::schema::Field for Type {
        type Type = Option<super::String>;
        const NAME: &'static str = "type";
    }
    impl ::cynic::schema::HasInputField<Type, Option<super::String>> for super::CityWhereInput {}
    pub struct TypeNot;
    impl ::cynic::schema::Field for TypeNot {
        type Type = Option<super::String>;
        const NAME: &'static str = "type_not";
    }
    impl ::cynic::schema::HasInputField<TypeNot, Option<super::String>> for super::CityWhereInput {}
    pub struct TypeIn;
    impl ::cynic::schema::Field for TypeIn {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "type_in";
    }
    impl ::cynic::schema::HasInputField<TypeIn, Option<Vec<super::String>>> for super::CityWhereInput {}
    pub struct TypeNotIn;
    impl ::cynic::schema::Field for TypeNotIn {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "type_not_in";
    }
    impl ::cynic::schema::HasInputField<TypeNotIn, Option<Vec<super::String>>>
        for super::CityWhereInput
    {
    }
    pub struct TypeLt;
    impl ::cynic::schema::Field for TypeLt {
        type Type = Option<super::String>;
        const NAME: &'static str = "type_lt";
    }
    impl ::cynic::schema::HasInputField<TypeLt, Option<super::String>> for super::CityWhereInput {}
    pub struct TypeLte;
    impl ::cynic::schema::Field for TypeLte {
        type Type = Option<super::String>;
        const NAME: &'static str = "type_lte";
    }
    impl ::cynic::schema::HasInputField<TypeLte, Option<super::String>> for super::CityWhereInput {}
    pub struct TypeGt;
    impl ::cynic::schema::Field for TypeGt {
        type Type = Option<super::String>;
        const NAME: &'static str = "type_gt";
    }
    impl ::cynic::schema::HasInputField<TypeGt, Option<super::String>> for super::CityWhereInput {}
    pub struct TypeGte;
    impl ::cynic::schema::Field for TypeGte {
        type Type = Option<super::String>;
        const NAME: &'static str = "type_gte";
    }
    impl ::cynic::schema::HasInputField<TypeGte, Option<super::String>> for super::CityWhereInput {}
    pub struct TypeContains;
    impl ::cynic::schema::Field for TypeContains {
        type Type = Option<super::String>;
        const NAME: &'static str = "type_contains";
    }
    impl ::cynic::schema::HasInputField<TypeContains, Option<super::String>> for super::CityWhereInput {}
    pub struct TypeNotContains;
    impl ::cynic::schema::Field for TypeNotContains {
        type Type = Option<super::String>;
        const NAME: &'static str = "type_not_contains";
    }
    impl ::cynic::schema::HasInputField<TypeNotContains, Option<super::String>>
        for super::CityWhereInput
    {
    }
    pub struct TypeStartsWith;
    impl ::cynic::schema::Field for TypeStartsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "type_starts_with";
    }
    impl ::cynic::schema::HasInputField<TypeStartsWith, Option<super::String>>
        for super::CityWhereInput
    {
    }
    pub struct TypeNotStartsWith;
    impl ::cynic::schema::Field for TypeNotStartsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "type_not_starts_with";
    }
    impl ::cynic::schema::HasInputField<TypeNotStartsWith, Option<super::String>>
        for super::CityWhereInput
    {
    }
    pub struct TypeEndsWith;
    impl ::cynic::schema::Field for TypeEndsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "type_ends_with";
    }
    impl ::cynic::schema::HasInputField<TypeEndsWith, Option<super::String>> for super::CityWhereInput {}
    pub struct TypeNotEndsWith;
    impl ::cynic::schema::Field for TypeNotEndsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "type_not_ends_with";
    }
    impl ::cynic::schema::HasInputField<TypeNotEndsWith, Option<super::String>>
        for super::CityWhereInput
    {
    }
    pub struct JobsEvery;
    impl ::cynic::schema::Field for JobsEvery {
        type Type = Option<super::JobWhereInput>;
        const NAME: &'static str = "jobs_every";
    }
    impl ::cynic::schema::HasInputField<JobsEvery, Option<super::JobWhereInput>>
        for super::CityWhereInput
    {
    }
    pub struct JobsSome;
    impl ::cynic::schema::Field for JobsSome {
        type Type = Option<super::JobWhereInput>;
        const NAME: &'static str = "jobs_some";
    }
    impl ::cynic::schema::HasInputField<JobsSome, Option<super::JobWhereInput>>
        for super::CityWhereInput
    {
    }
    pub struct JobsNone;
    impl ::cynic::schema::Field for JobsNone {
        type Type = Option<super::JobWhereInput>;
        const NAME: &'static str = "jobs_none";
    }
    impl ::cynic::schema::HasInputField<JobsNone, Option<super::JobWhereInput>>
        for super::CityWhereInput
    {
    }
    pub struct CreatedAt;
    impl ::cynic::schema::Field for CreatedAt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt";
    }
    impl ::cynic::schema::HasInputField<CreatedAt, Option<super::DateTime>> for super::CityWhereInput {}
    pub struct CreatedAtNot;
    impl ::cynic::schema::Field for CreatedAtNot {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt_not";
    }
    impl ::cynic::schema::HasInputField<CreatedAtNot, Option<super::DateTime>>
        for super::CityWhereInput
    {
    }
    pub struct CreatedAtIn;
    impl ::cynic::schema::Field for CreatedAtIn {
        type Type = Option<Vec<super::DateTime>>;
        const NAME: &'static str = "createdAt_in";
    }
    impl ::cynic::schema::HasInputField<CreatedAtIn, Option<Vec<super::DateTime>>>
        for super::CityWhereInput
    {
    }
    pub struct CreatedAtNotIn;
    impl ::cynic::schema::Field for CreatedAtNotIn {
        type Type = Option<Vec<super::DateTime>>;
        const NAME: &'static str = "createdAt_not_in";
    }
    impl ::cynic::schema::HasInputField<CreatedAtNotIn, Option<Vec<super::DateTime>>>
        for super::CityWhereInput
    {
    }
    pub struct CreatedAtLt;
    impl ::cynic::schema::Field for CreatedAtLt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt_lt";
    }
    impl ::cynic::schema::HasInputField<CreatedAtLt, Option<super::DateTime>>
        for super::CityWhereInput
    {
    }
    pub struct CreatedAtLte;
    impl ::cynic::schema::Field for CreatedAtLte {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt_lte";
    }
    impl ::cynic::schema::HasInputField<CreatedAtLte, Option<super::DateTime>>
        for super::CityWhereInput
    {
    }
    pub struct CreatedAtGt;
    impl ::cynic::schema::Field for CreatedAtGt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt_gt";
    }
    impl ::cynic::schema::HasInputField<CreatedAtGt, Option<super::DateTime>>
        for super::CityWhereInput
    {
    }
    pub struct CreatedAtGte;
    impl ::cynic::schema::Field for CreatedAtGte {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt_gte";
    }
    impl ::cynic::schema::HasInputField<CreatedAtGte, Option<super::DateTime>>
        for super::CityWhereInput
    {
    }
    pub struct UpdatedAt;
    impl ::cynic::schema::Field for UpdatedAt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt";
    }
    impl ::cynic::schema::HasInputField<UpdatedAt, Option<super::DateTime>> for super::CityWhereInput {}
    pub struct UpdatedAtNot;
    impl ::cynic::schema::Field for UpdatedAtNot {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt_not";
    }
    impl ::cynic::schema::HasInputField<UpdatedAtNot, Option<super::DateTime>>
        for super::CityWhereInput
    {
    }
    pub struct UpdatedAtIn;
    impl ::cynic::schema::Field for UpdatedAtIn {
        type Type = Option<Vec<super::DateTime>>;
        const NAME: &'static str = "updatedAt_in";
    }
    impl ::cynic::schema::HasInputField<UpdatedAtIn, Option<Vec<super::DateTime>>>
        for super::CityWhereInput
    {
    }
    pub struct UpdatedAtNotIn;
    impl ::cynic::schema::Field for UpdatedAtNotIn {
        type Type = Option<Vec<super::DateTime>>;
        const NAME: &'static str = "updatedAt_not_in";
    }
    impl ::cynic::schema::HasInputField<UpdatedAtNotIn, Option<Vec<super::DateTime>>>
        for super::CityWhereInput
    {
    }
    pub struct UpdatedAtLt;
    impl ::cynic::schema::Field for UpdatedAtLt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt_lt";
    }
    impl ::cynic::schema::HasInputField<UpdatedAtLt, Option<super::DateTime>>
        for super::CityWhereInput
    {
    }
    pub struct UpdatedAtLte;
    impl ::cynic::schema::Field for UpdatedAtLte {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt_lte";
    }
    impl ::cynic::schema::HasInputField<UpdatedAtLte, Option<super::DateTime>>
        for super::CityWhereInput
    {
    }
    pub struct UpdatedAtGt;
    impl ::cynic::schema::Field for UpdatedAtGt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt_gt";
    }
    impl ::cynic::schema::HasInputField<UpdatedAtGt, Option<super::DateTime>>
        for super::CityWhereInput
    {
    }
    pub struct UpdatedAtGte;
    impl ::cynic::schema::Field for UpdatedAtGte {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt_gte";
    }
    impl ::cynic::schema::HasInputField<UpdatedAtGte, Option<super::DateTime>>
        for super::CityWhereInput
    {
    }
    pub struct And;
    impl ::cynic::schema::Field for And {
        type Type = Option<Vec<super::CityWhereInput>>;
        const NAME: &'static str = "AND";
    }
    impl ::cynic::schema::HasInputField<And, Option<Vec<super::CityWhereInput>>>
        for super::CityWhereInput
    {
    }
    pub struct Or;
    impl ::cynic::schema::Field for Or {
        type Type = Option<Vec<super::CityWhereInput>>;
        const NAME: &'static str = "OR";
    }
    impl ::cynic::schema::HasInputField<Or, Option<Vec<super::CityWhereInput>>>
        for super::CityWhereInput
    {
    }
    pub struct Not;
    impl ::cynic::schema::Field for Not {
        type Type = Option<Vec<super::CityWhereInput>>;
        const NAME: &'static str = "NOT";
    }
    impl ::cynic::schema::HasInputField<Not, Option<Vec<super::CityWhereInput>>>
        for super::CityWhereInput
    {
    }
}
pub struct Commitment;
pub mod commitment_fields {
    pub struct Id;
    impl ::cynic::schema::Field for Id {
        type Type = super::Id;
        const NAME: &'static str = "id";
    }
    impl ::cynic::schema::HasField<Id> for super::Commitment {
        type Type = super::Id;
    }
    pub struct Title;
    impl ::cynic::schema::Field for Title {
        type Type = super::String;
        const NAME: &'static str = "title";
    }
    impl ::cynic::schema::HasField<Title> for super::Commitment {
        type Type = super::String;
    }
    pub struct Slug;
    impl ::cynic::schema::Field for Slug {
        type Type = super::String;
        const NAME: &'static str = "slug";
    }
    impl ::cynic::schema::HasField<Slug> for super::Commitment {
        type Type = super::String;
    }
    pub struct Jobs;
    impl ::cynic::schema::Field for Jobs {
        type Type = Option<Vec<super::Job>>;
        const NAME: &'static str = "jobs";
    }
    impl ::cynic::schema::HasField<Jobs> for super::Commitment {
        type Type = Option<Vec<super::Job>>;
    }
    pub mod jobs_arguments {
        pub struct Where;
        impl ::cynic::schema::HasArgument<Where> for super::Jobs {
            type ArgumentType = Option<super::super::JobWhereInput>;
            const NAME: &'static str = "where";
        }
        pub struct OrderBy;
        impl ::cynic::schema::HasArgument<OrderBy> for super::Jobs {
            type ArgumentType = Option<super::super::JobOrderByInput>;
            const NAME: &'static str = "orderBy";
        }
        pub struct Skip;
        impl ::cynic::schema::HasArgument<Skip> for super::Jobs {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "skip";
        }
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::Jobs {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "after";
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::Jobs {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "before";
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::Jobs {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "first";
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::Jobs {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "last";
        }
    }
    pub struct CreatedAt;
    impl ::cynic::schema::Field for CreatedAt {
        type Type = super::DateTime;
        const NAME: &'static str = "createdAt";
    }
    impl ::cynic::schema::HasField<CreatedAt> for super::Commitment {
        type Type = super::DateTime;
    }
    pub struct UpdatedAt;
    impl ::cynic::schema::Field for UpdatedAt {
        type Type = super::DateTime;
        const NAME: &'static str = "updatedAt";
    }
    impl ::cynic::schema::HasField<UpdatedAt> for super::Commitment {
        type Type = super::DateTime;
    }
}
pub struct CommitmentWhereInput;
impl ::cynic::schema::InputObjectMarker for CommitmentWhereInput {}
pub mod commitment_where_input_fields {
    pub struct Id;
    impl ::cynic::schema::Field for Id {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id";
    }
    impl ::cynic::schema::HasInputField<Id, Option<super::Id>> for super::CommitmentWhereInput {}
    pub struct IdNot;
    impl ::cynic::schema::Field for IdNot {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_not";
    }
    impl ::cynic::schema::HasInputField<IdNot, Option<super::Id>> for super::CommitmentWhereInput {}
    pub struct IdIn;
    impl ::cynic::schema::Field for IdIn {
        type Type = Option<Vec<super::Id>>;
        const NAME: &'static str = "id_in";
    }
    impl ::cynic::schema::HasInputField<IdIn, Option<Vec<super::Id>>> for super::CommitmentWhereInput {}
    pub struct IdNotIn;
    impl ::cynic::schema::Field for IdNotIn {
        type Type = Option<Vec<super::Id>>;
        const NAME: &'static str = "id_not_in";
    }
    impl ::cynic::schema::HasInputField<IdNotIn, Option<Vec<super::Id>>>
        for super::CommitmentWhereInput
    {
    }
    pub struct IdLt;
    impl ::cynic::schema::Field for IdLt {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_lt";
    }
    impl ::cynic::schema::HasInputField<IdLt, Option<super::Id>> for super::CommitmentWhereInput {}
    pub struct IdLte;
    impl ::cynic::schema::Field for IdLte {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_lte";
    }
    impl ::cynic::schema::HasInputField<IdLte, Option<super::Id>> for super::CommitmentWhereInput {}
    pub struct IdGt;
    impl ::cynic::schema::Field for IdGt {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_gt";
    }
    impl ::cynic::schema::HasInputField<IdGt, Option<super::Id>> for super::CommitmentWhereInput {}
    pub struct IdGte;
    impl ::cynic::schema::Field for IdGte {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_gte";
    }
    impl ::cynic::schema::HasInputField<IdGte, Option<super::Id>> for super::CommitmentWhereInput {}
    pub struct IdContains;
    impl ::cynic::schema::Field for IdContains {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_contains";
    }
    impl ::cynic::schema::HasInputField<IdContains, Option<super::Id>> for super::CommitmentWhereInput {}
    pub struct IdNotContains;
    impl ::cynic::schema::Field for IdNotContains {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_not_contains";
    }
    impl ::cynic::schema::HasInputField<IdNotContains, Option<super::Id>>
        for super::CommitmentWhereInput
    {
    }
    pub struct IdStartsWith;
    impl ::cynic::schema::Field for IdStartsWith {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_starts_with";
    }
    impl ::cynic::schema::HasInputField<IdStartsWith, Option<super::Id>>
        for super::CommitmentWhereInput
    {
    }
    pub struct IdNotStartsWith;
    impl ::cynic::schema::Field for IdNotStartsWith {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_not_starts_with";
    }
    impl ::cynic::schema::HasInputField<IdNotStartsWith, Option<super::Id>>
        for super::CommitmentWhereInput
    {
    }
    pub struct IdEndsWith;
    impl ::cynic::schema::Field for IdEndsWith {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_ends_with";
    }
    impl ::cynic::schema::HasInputField<IdEndsWith, Option<super::Id>> for super::CommitmentWhereInput {}
    pub struct IdNotEndsWith;
    impl ::cynic::schema::Field for IdNotEndsWith {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_not_ends_with";
    }
    impl ::cynic::schema::HasInputField<IdNotEndsWith, Option<super::Id>>
        for super::CommitmentWhereInput
    {
    }
    pub struct Title;
    impl ::cynic::schema::Field for Title {
        type Type = Option<super::String>;
        const NAME: &'static str = "title";
    }
    impl ::cynic::schema::HasInputField<Title, Option<super::String>> for super::CommitmentWhereInput {}
    pub struct TitleNot;
    impl ::cynic::schema::Field for TitleNot {
        type Type = Option<super::String>;
        const NAME: &'static str = "title_not";
    }
    impl ::cynic::schema::HasInputField<TitleNot, Option<super::String>>
        for super::CommitmentWhereInput
    {
    }
    pub struct TitleIn;
    impl ::cynic::schema::Field for TitleIn {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "title_in";
    }
    impl ::cynic::schema::HasInputField<TitleIn, Option<Vec<super::String>>>
        for super::CommitmentWhereInput
    {
    }
    pub struct TitleNotIn;
    impl ::cynic::schema::Field for TitleNotIn {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "title_not_in";
    }
    impl ::cynic::schema::HasInputField<TitleNotIn, Option<Vec<super::String>>>
        for super::CommitmentWhereInput
    {
    }
    pub struct TitleLt;
    impl ::cynic::schema::Field for TitleLt {
        type Type = Option<super::String>;
        const NAME: &'static str = "title_lt";
    }
    impl ::cynic::schema::HasInputField<TitleLt, Option<super::String>>
        for super::CommitmentWhereInput
    {
    }
    pub struct TitleLte;
    impl ::cynic::schema::Field for TitleLte {
        type Type = Option<super::String>;
        const NAME: &'static str = "title_lte";
    }
    impl ::cynic::schema::HasInputField<TitleLte, Option<super::String>>
        for super::CommitmentWhereInput
    {
    }
    pub struct TitleGt;
    impl ::cynic::schema::Field for TitleGt {
        type Type = Option<super::String>;
        const NAME: &'static str = "title_gt";
    }
    impl ::cynic::schema::HasInputField<TitleGt, Option<super::String>>
        for super::CommitmentWhereInput
    {
    }
    pub struct TitleGte;
    impl ::cynic::schema::Field for TitleGte {
        type Type = Option<super::String>;
        const NAME: &'static str = "title_gte";
    }
    impl ::cynic::schema::HasInputField<TitleGte, Option<super::String>>
        for super::CommitmentWhereInput
    {
    }
    pub struct TitleContains;
    impl ::cynic::schema::Field for TitleContains {
        type Type = Option<super::String>;
        const NAME: &'static str = "title_contains";
    }
    impl ::cynic::schema::HasInputField<TitleContains, Option<super::String>>
        for super::CommitmentWhereInput
    {
    }
    pub struct TitleNotContains;
    impl ::cynic::schema::Field for TitleNotContains {
        type Type = Option<super::String>;
        const NAME: &'static str = "title_not_contains";
    }
    impl ::cynic::schema::HasInputField<TitleNotContains, Option<super::String>>
        for super::CommitmentWhereInput
    {
    }
    pub struct TitleStartsWith;
    impl ::cynic::schema::Field for TitleStartsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "title_starts_with";
    }
    impl ::cynic::schema::HasInputField<TitleStartsWith, Option<super::String>>
        for super::CommitmentWhereInput
    {
    }
    pub struct TitleNotStartsWith;
    impl ::cynic::schema::Field for TitleNotStartsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "title_not_starts_with";
    }
    impl ::cynic::schema::HasInputField<TitleNotStartsWith, Option<super::String>>
        for super::CommitmentWhereInput
    {
    }
    pub struct TitleEndsWith;
    impl ::cynic::schema::Field for TitleEndsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "title_ends_with";
    }
    impl ::cynic::schema::HasInputField<TitleEndsWith, Option<super::String>>
        for super::CommitmentWhereInput
    {
    }
    pub struct TitleNotEndsWith;
    impl ::cynic::schema::Field for TitleNotEndsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "title_not_ends_with";
    }
    impl ::cynic::schema::HasInputField<TitleNotEndsWith, Option<super::String>>
        for super::CommitmentWhereInput
    {
    }
    pub struct Slug;
    impl ::cynic::schema::Field for Slug {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug";
    }
    impl ::cynic::schema::HasInputField<Slug, Option<super::String>> for super::CommitmentWhereInput {}
    pub struct SlugNot;
    impl ::cynic::schema::Field for SlugNot {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_not";
    }
    impl ::cynic::schema::HasInputField<SlugNot, Option<super::String>>
        for super::CommitmentWhereInput
    {
    }
    pub struct SlugIn;
    impl ::cynic::schema::Field for SlugIn {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "slug_in";
    }
    impl ::cynic::schema::HasInputField<SlugIn, Option<Vec<super::String>>>
        for super::CommitmentWhereInput
    {
    }
    pub struct SlugNotIn;
    impl ::cynic::schema::Field for SlugNotIn {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "slug_not_in";
    }
    impl ::cynic::schema::HasInputField<SlugNotIn, Option<Vec<super::String>>>
        for super::CommitmentWhereInput
    {
    }
    pub struct SlugLt;
    impl ::cynic::schema::Field for SlugLt {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_lt";
    }
    impl ::cynic::schema::HasInputField<SlugLt, Option<super::String>> for super::CommitmentWhereInput {}
    pub struct SlugLte;
    impl ::cynic::schema::Field for SlugLte {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_lte";
    }
    impl ::cynic::schema::HasInputField<SlugLte, Option<super::String>>
        for super::CommitmentWhereInput
    {
    }
    pub struct SlugGt;
    impl ::cynic::schema::Field for SlugGt {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_gt";
    }
    impl ::cynic::schema::HasInputField<SlugGt, Option<super::String>> for super::CommitmentWhereInput {}
    pub struct SlugGte;
    impl ::cynic::schema::Field for SlugGte {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_gte";
    }
    impl ::cynic::schema::HasInputField<SlugGte, Option<super::String>>
        for super::CommitmentWhereInput
    {
    }
    pub struct SlugContains;
    impl ::cynic::schema::Field for SlugContains {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_contains";
    }
    impl ::cynic::schema::HasInputField<SlugContains, Option<super::String>>
        for super::CommitmentWhereInput
    {
    }
    pub struct SlugNotContains;
    impl ::cynic::schema::Field for SlugNotContains {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_not_contains";
    }
    impl ::cynic::schema::HasInputField<SlugNotContains, Option<super::String>>
        for super::CommitmentWhereInput
    {
    }
    pub struct SlugStartsWith;
    impl ::cynic::schema::Field for SlugStartsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_starts_with";
    }
    impl ::cynic::schema::HasInputField<SlugStartsWith, Option<super::String>>
        for super::CommitmentWhereInput
    {
    }
    pub struct SlugNotStartsWith;
    impl ::cynic::schema::Field for SlugNotStartsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_not_starts_with";
    }
    impl ::cynic::schema::HasInputField<SlugNotStartsWith, Option<super::String>>
        for super::CommitmentWhereInput
    {
    }
    pub struct SlugEndsWith;
    impl ::cynic::schema::Field for SlugEndsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_ends_with";
    }
    impl ::cynic::schema::HasInputField<SlugEndsWith, Option<super::String>>
        for super::CommitmentWhereInput
    {
    }
    pub struct SlugNotEndsWith;
    impl ::cynic::schema::Field for SlugNotEndsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_not_ends_with";
    }
    impl ::cynic::schema::HasInputField<SlugNotEndsWith, Option<super::String>>
        for super::CommitmentWhereInput
    {
    }
    pub struct JobsEvery;
    impl ::cynic::schema::Field for JobsEvery {
        type Type = Option<super::JobWhereInput>;
        const NAME: &'static str = "jobs_every";
    }
    impl ::cynic::schema::HasInputField<JobsEvery, Option<super::JobWhereInput>>
        for super::CommitmentWhereInput
    {
    }
    pub struct JobsSome;
    impl ::cynic::schema::Field for JobsSome {
        type Type = Option<super::JobWhereInput>;
        const NAME: &'static str = "jobs_some";
    }
    impl ::cynic::schema::HasInputField<JobsSome, Option<super::JobWhereInput>>
        for super::CommitmentWhereInput
    {
    }
    pub struct JobsNone;
    impl ::cynic::schema::Field for JobsNone {
        type Type = Option<super::JobWhereInput>;
        const NAME: &'static str = "jobs_none";
    }
    impl ::cynic::schema::HasInputField<JobsNone, Option<super::JobWhereInput>>
        for super::CommitmentWhereInput
    {
    }
    pub struct CreatedAt;
    impl ::cynic::schema::Field for CreatedAt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt";
    }
    impl ::cynic::schema::HasInputField<CreatedAt, Option<super::DateTime>>
        for super::CommitmentWhereInput
    {
    }
    pub struct CreatedAtNot;
    impl ::cynic::schema::Field for CreatedAtNot {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt_not";
    }
    impl ::cynic::schema::HasInputField<CreatedAtNot, Option<super::DateTime>>
        for super::CommitmentWhereInput
    {
    }
    pub struct CreatedAtIn;
    impl ::cynic::schema::Field for CreatedAtIn {
        type Type = Option<Vec<super::DateTime>>;
        const NAME: &'static str = "createdAt_in";
    }
    impl ::cynic::schema::HasInputField<CreatedAtIn, Option<Vec<super::DateTime>>>
        for super::CommitmentWhereInput
    {
    }
    pub struct CreatedAtNotIn;
    impl ::cynic::schema::Field for CreatedAtNotIn {
        type Type = Option<Vec<super::DateTime>>;
        const NAME: &'static str = "createdAt_not_in";
    }
    impl ::cynic::schema::HasInputField<CreatedAtNotIn, Option<Vec<super::DateTime>>>
        for super::CommitmentWhereInput
    {
    }
    pub struct CreatedAtLt;
    impl ::cynic::schema::Field for CreatedAtLt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt_lt";
    }
    impl ::cynic::schema::HasInputField<CreatedAtLt, Option<super::DateTime>>
        for super::CommitmentWhereInput
    {
    }
    pub struct CreatedAtLte;
    impl ::cynic::schema::Field for CreatedAtLte {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt_lte";
    }
    impl ::cynic::schema::HasInputField<CreatedAtLte, Option<super::DateTime>>
        for super::CommitmentWhereInput
    {
    }
    pub struct CreatedAtGt;
    impl ::cynic::schema::Field for CreatedAtGt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt_gt";
    }
    impl ::cynic::schema::HasInputField<CreatedAtGt, Option<super::DateTime>>
        for super::CommitmentWhereInput
    {
    }
    pub struct CreatedAtGte;
    impl ::cynic::schema::Field for CreatedAtGte {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt_gte";
    }
    impl ::cynic::schema::HasInputField<CreatedAtGte, Option<super::DateTime>>
        for super::CommitmentWhereInput
    {
    }
    pub struct UpdatedAt;
    impl ::cynic::schema::Field for UpdatedAt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt";
    }
    impl ::cynic::schema::HasInputField<UpdatedAt, Option<super::DateTime>>
        for super::CommitmentWhereInput
    {
    }
    pub struct UpdatedAtNot;
    impl ::cynic::schema::Field for UpdatedAtNot {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt_not";
    }
    impl ::cynic::schema::HasInputField<UpdatedAtNot, Option<super::DateTime>>
        for super::CommitmentWhereInput
    {
    }
    pub struct UpdatedAtIn;
    impl ::cynic::schema::Field for UpdatedAtIn {
        type Type = Option<Vec<super::DateTime>>;
        const NAME: &'static str = "updatedAt_in";
    }
    impl ::cynic::schema::HasInputField<UpdatedAtIn, Option<Vec<super::DateTime>>>
        for super::CommitmentWhereInput
    {
    }
    pub struct UpdatedAtNotIn;
    impl ::cynic::schema::Field for UpdatedAtNotIn {
        type Type = Option<Vec<super::DateTime>>;
        const NAME: &'static str = "updatedAt_not_in";
    }
    impl ::cynic::schema::HasInputField<UpdatedAtNotIn, Option<Vec<super::DateTime>>>
        for super::CommitmentWhereInput
    {
    }
    pub struct UpdatedAtLt;
    impl ::cynic::schema::Field for UpdatedAtLt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt_lt";
    }
    impl ::cynic::schema::HasInputField<UpdatedAtLt, Option<super::DateTime>>
        for super::CommitmentWhereInput
    {
    }
    pub struct UpdatedAtLte;
    impl ::cynic::schema::Field for UpdatedAtLte {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt_lte";
    }
    impl ::cynic::schema::HasInputField<UpdatedAtLte, Option<super::DateTime>>
        for super::CommitmentWhereInput
    {
    }
    pub struct UpdatedAtGt;
    impl ::cynic::schema::Field for UpdatedAtGt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt_gt";
    }
    impl ::cynic::schema::HasInputField<UpdatedAtGt, Option<super::DateTime>>
        for super::CommitmentWhereInput
    {
    }
    pub struct UpdatedAtGte;
    impl ::cynic::schema::Field for UpdatedAtGte {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt_gte";
    }
    impl ::cynic::schema::HasInputField<UpdatedAtGte, Option<super::DateTime>>
        for super::CommitmentWhereInput
    {
    }
    pub struct And;
    impl ::cynic::schema::Field for And {
        type Type = Option<Vec<super::CommitmentWhereInput>>;
        const NAME: &'static str = "AND";
    }
    impl ::cynic::schema::HasInputField<And, Option<Vec<super::CommitmentWhereInput>>>
        for super::CommitmentWhereInput
    {
    }
    pub struct Or;
    impl ::cynic::schema::Field for Or {
        type Type = Option<Vec<super::CommitmentWhereInput>>;
        const NAME: &'static str = "OR";
    }
    impl ::cynic::schema::HasInputField<Or, Option<Vec<super::CommitmentWhereInput>>>
        for super::CommitmentWhereInput
    {
    }
    pub struct Not;
    impl ::cynic::schema::Field for Not {
        type Type = Option<Vec<super::CommitmentWhereInput>>;
        const NAME: &'static str = "NOT";
    }
    impl ::cynic::schema::HasInputField<Not, Option<Vec<super::CommitmentWhereInput>>>
        for super::CommitmentWhereInput
    {
    }
}
pub struct Company;
pub mod company_fields {
    pub struct Id;
    impl ::cynic::schema::Field for Id {
        type Type = super::Id;
        const NAME: &'static str = "id";
    }
    impl ::cynic::schema::HasField<Id> for super::Company {
        type Type = super::Id;
    }
    pub struct Name;
    impl ::cynic::schema::Field for Name {
        type Type = super::String;
        const NAME: &'static str = "name";
    }
    impl ::cynic::schema::HasField<Name> for super::Company {
        type Type = super::String;
    }
    pub struct Slug;
    impl ::cynic::schema::Field for Slug {
        type Type = super::String;
        const NAME: &'static str = "slug";
    }
    impl ::cynic::schema::HasField<Slug> for super::Company {
        type Type = super::String;
    }
    pub struct WebsiteUrl;
    impl ::cynic::schema::Field for WebsiteUrl {
        type Type = super::String;
        const NAME: &'static str = "websiteUrl";
    }
    impl ::cynic::schema::HasField<WebsiteUrl> for super::Company {
        type Type = super::String;
    }
    pub struct LogoUrl;
    impl ::cynic::schema::Field for LogoUrl {
        type Type = Option<super::String>;
        const NAME: &'static str = "logoUrl";
    }
    impl ::cynic::schema::HasField<LogoUrl> for super::Company {
        type Type = Option<super::String>;
    }
    pub struct Jobs;
    impl ::cynic::schema::Field for Jobs {
        type Type = Option<Vec<super::Job>>;
        const NAME: &'static str = "jobs";
    }
    impl ::cynic::schema::HasField<Jobs> for super::Company {
        type Type = Option<Vec<super::Job>>;
    }
    pub mod jobs_arguments {
        pub struct Where;
        impl ::cynic::schema::HasArgument<Where> for super::Jobs {
            type ArgumentType = Option<super::super::JobWhereInput>;
            const NAME: &'static str = "where";
        }
        pub struct OrderBy;
        impl ::cynic::schema::HasArgument<OrderBy> for super::Jobs {
            type ArgumentType = Option<super::super::JobOrderByInput>;
            const NAME: &'static str = "orderBy";
        }
        pub struct Skip;
        impl ::cynic::schema::HasArgument<Skip> for super::Jobs {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "skip";
        }
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::Jobs {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "after";
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::Jobs {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "before";
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::Jobs {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "first";
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::Jobs {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "last";
        }
    }
    pub struct Twitter;
    impl ::cynic::schema::Field for Twitter {
        type Type = Option<super::String>;
        const NAME: &'static str = "twitter";
    }
    impl ::cynic::schema::HasField<Twitter> for super::Company {
        type Type = Option<super::String>;
    }
    pub struct Emailed;
    impl ::cynic::schema::Field for Emailed {
        type Type = Option<super::Boolean>;
        const NAME: &'static str = "emailed";
    }
    impl ::cynic::schema::HasField<Emailed> for super::Company {
        type Type = Option<super::Boolean>;
    }
    pub struct CreatedAt;
    impl ::cynic::schema::Field for CreatedAt {
        type Type = super::DateTime;
        const NAME: &'static str = "createdAt";
    }
    impl ::cynic::schema::HasField<CreatedAt> for super::Company {
        type Type = super::DateTime;
    }
    pub struct UpdatedAt;
    impl ::cynic::schema::Field for UpdatedAt {
        type Type = super::DateTime;
        const NAME: &'static str = "updatedAt";
    }
    impl ::cynic::schema::HasField<UpdatedAt> for super::Company {
        type Type = super::DateTime;
    }
}
pub struct CompanyWhereInput;
impl ::cynic::schema::InputObjectMarker for CompanyWhereInput {}
pub mod company_where_input_fields {
    pub struct Id;
    impl ::cynic::schema::Field for Id {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id";
    }
    impl ::cynic::schema::HasInputField<Id, Option<super::Id>> for super::CompanyWhereInput {}
    pub struct IdNot;
    impl ::cynic::schema::Field for IdNot {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_not";
    }
    impl ::cynic::schema::HasInputField<IdNot, Option<super::Id>> for super::CompanyWhereInput {}
    pub struct IdIn;
    impl ::cynic::schema::Field for IdIn {
        type Type = Option<Vec<super::Id>>;
        const NAME: &'static str = "id_in";
    }
    impl ::cynic::schema::HasInputField<IdIn, Option<Vec<super::Id>>> for super::CompanyWhereInput {}
    pub struct IdNotIn;
    impl ::cynic::schema::Field for IdNotIn {
        type Type = Option<Vec<super::Id>>;
        const NAME: &'static str = "id_not_in";
    }
    impl ::cynic::schema::HasInputField<IdNotIn, Option<Vec<super::Id>>> for super::CompanyWhereInput {}
    pub struct IdLt;
    impl ::cynic::schema::Field for IdLt {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_lt";
    }
    impl ::cynic::schema::HasInputField<IdLt, Option<super::Id>> for super::CompanyWhereInput {}
    pub struct IdLte;
    impl ::cynic::schema::Field for IdLte {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_lte";
    }
    impl ::cynic::schema::HasInputField<IdLte, Option<super::Id>> for super::CompanyWhereInput {}
    pub struct IdGt;
    impl ::cynic::schema::Field for IdGt {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_gt";
    }
    impl ::cynic::schema::HasInputField<IdGt, Option<super::Id>> for super::CompanyWhereInput {}
    pub struct IdGte;
    impl ::cynic::schema::Field for IdGte {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_gte";
    }
    impl ::cynic::schema::HasInputField<IdGte, Option<super::Id>> for super::CompanyWhereInput {}
    pub struct IdContains;
    impl ::cynic::schema::Field for IdContains {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_contains";
    }
    impl ::cynic::schema::HasInputField<IdContains, Option<super::Id>> for super::CompanyWhereInput {}
    pub struct IdNotContains;
    impl ::cynic::schema::Field for IdNotContains {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_not_contains";
    }
    impl ::cynic::schema::HasInputField<IdNotContains, Option<super::Id>> for super::CompanyWhereInput {}
    pub struct IdStartsWith;
    impl ::cynic::schema::Field for IdStartsWith {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_starts_with";
    }
    impl ::cynic::schema::HasInputField<IdStartsWith, Option<super::Id>> for super::CompanyWhereInput {}
    pub struct IdNotStartsWith;
    impl ::cynic::schema::Field for IdNotStartsWith {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_not_starts_with";
    }
    impl ::cynic::schema::HasInputField<IdNotStartsWith, Option<super::Id>>
        for super::CompanyWhereInput
    {
    }
    pub struct IdEndsWith;
    impl ::cynic::schema::Field for IdEndsWith {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_ends_with";
    }
    impl ::cynic::schema::HasInputField<IdEndsWith, Option<super::Id>> for super::CompanyWhereInput {}
    pub struct IdNotEndsWith;
    impl ::cynic::schema::Field for IdNotEndsWith {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_not_ends_with";
    }
    impl ::cynic::schema::HasInputField<IdNotEndsWith, Option<super::Id>> for super::CompanyWhereInput {}
    pub struct Name;
    impl ::cynic::schema::Field for Name {
        type Type = Option<super::String>;
        const NAME: &'static str = "name";
    }
    impl ::cynic::schema::HasInputField<Name, Option<super::String>> for super::CompanyWhereInput {}
    pub struct NameNot;
    impl ::cynic::schema::Field for NameNot {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_not";
    }
    impl ::cynic::schema::HasInputField<NameNot, Option<super::String>> for super::CompanyWhereInput {}
    pub struct NameIn;
    impl ::cynic::schema::Field for NameIn {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "name_in";
    }
    impl ::cynic::schema::HasInputField<NameIn, Option<Vec<super::String>>>
        for super::CompanyWhereInput
    {
    }
    pub struct NameNotIn;
    impl ::cynic::schema::Field for NameNotIn {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "name_not_in";
    }
    impl ::cynic::schema::HasInputField<NameNotIn, Option<Vec<super::String>>>
        for super::CompanyWhereInput
    {
    }
    pub struct NameLt;
    impl ::cynic::schema::Field for NameLt {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_lt";
    }
    impl ::cynic::schema::HasInputField<NameLt, Option<super::String>> for super::CompanyWhereInput {}
    pub struct NameLte;
    impl ::cynic::schema::Field for NameLte {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_lte";
    }
    impl ::cynic::schema::HasInputField<NameLte, Option<super::String>> for super::CompanyWhereInput {}
    pub struct NameGt;
    impl ::cynic::schema::Field for NameGt {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_gt";
    }
    impl ::cynic::schema::HasInputField<NameGt, Option<super::String>> for super::CompanyWhereInput {}
    pub struct NameGte;
    impl ::cynic::schema::Field for NameGte {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_gte";
    }
    impl ::cynic::schema::HasInputField<NameGte, Option<super::String>> for super::CompanyWhereInput {}
    pub struct NameContains;
    impl ::cynic::schema::Field for NameContains {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_contains";
    }
    impl ::cynic::schema::HasInputField<NameContains, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct NameNotContains;
    impl ::cynic::schema::Field for NameNotContains {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_not_contains";
    }
    impl ::cynic::schema::HasInputField<NameNotContains, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct NameStartsWith;
    impl ::cynic::schema::Field for NameStartsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_starts_with";
    }
    impl ::cynic::schema::HasInputField<NameStartsWith, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct NameNotStartsWith;
    impl ::cynic::schema::Field for NameNotStartsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_not_starts_with";
    }
    impl ::cynic::schema::HasInputField<NameNotStartsWith, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct NameEndsWith;
    impl ::cynic::schema::Field for NameEndsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_ends_with";
    }
    impl ::cynic::schema::HasInputField<NameEndsWith, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct NameNotEndsWith;
    impl ::cynic::schema::Field for NameNotEndsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_not_ends_with";
    }
    impl ::cynic::schema::HasInputField<NameNotEndsWith, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct Slug;
    impl ::cynic::schema::Field for Slug {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug";
    }
    impl ::cynic::schema::HasInputField<Slug, Option<super::String>> for super::CompanyWhereInput {}
    pub struct SlugNot;
    impl ::cynic::schema::Field for SlugNot {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_not";
    }
    impl ::cynic::schema::HasInputField<SlugNot, Option<super::String>> for super::CompanyWhereInput {}
    pub struct SlugIn;
    impl ::cynic::schema::Field for SlugIn {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "slug_in";
    }
    impl ::cynic::schema::HasInputField<SlugIn, Option<Vec<super::String>>>
        for super::CompanyWhereInput
    {
    }
    pub struct SlugNotIn;
    impl ::cynic::schema::Field for SlugNotIn {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "slug_not_in";
    }
    impl ::cynic::schema::HasInputField<SlugNotIn, Option<Vec<super::String>>>
        for super::CompanyWhereInput
    {
    }
    pub struct SlugLt;
    impl ::cynic::schema::Field for SlugLt {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_lt";
    }
    impl ::cynic::schema::HasInputField<SlugLt, Option<super::String>> for super::CompanyWhereInput {}
    pub struct SlugLte;
    impl ::cynic::schema::Field for SlugLte {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_lte";
    }
    impl ::cynic::schema::HasInputField<SlugLte, Option<super::String>> for super::CompanyWhereInput {}
    pub struct SlugGt;
    impl ::cynic::schema::Field for SlugGt {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_gt";
    }
    impl ::cynic::schema::HasInputField<SlugGt, Option<super::String>> for super::CompanyWhereInput {}
    pub struct SlugGte;
    impl ::cynic::schema::Field for SlugGte {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_gte";
    }
    impl ::cynic::schema::HasInputField<SlugGte, Option<super::String>> for super::CompanyWhereInput {}
    pub struct SlugContains;
    impl ::cynic::schema::Field for SlugContains {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_contains";
    }
    impl ::cynic::schema::HasInputField<SlugContains, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct SlugNotContains;
    impl ::cynic::schema::Field for SlugNotContains {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_not_contains";
    }
    impl ::cynic::schema::HasInputField<SlugNotContains, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct SlugStartsWith;
    impl ::cynic::schema::Field for SlugStartsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_starts_with";
    }
    impl ::cynic::schema::HasInputField<SlugStartsWith, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct SlugNotStartsWith;
    impl ::cynic::schema::Field for SlugNotStartsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_not_starts_with";
    }
    impl ::cynic::schema::HasInputField<SlugNotStartsWith, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct SlugEndsWith;
    impl ::cynic::schema::Field for SlugEndsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_ends_with";
    }
    impl ::cynic::schema::HasInputField<SlugEndsWith, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct SlugNotEndsWith;
    impl ::cynic::schema::Field for SlugNotEndsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_not_ends_with";
    }
    impl ::cynic::schema::HasInputField<SlugNotEndsWith, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct WebsiteUrl;
    impl ::cynic::schema::Field for WebsiteUrl {
        type Type = Option<super::String>;
        const NAME: &'static str = "websiteUrl";
    }
    impl ::cynic::schema::HasInputField<WebsiteUrl, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct WebsiteUrlNot;
    impl ::cynic::schema::Field for WebsiteUrlNot {
        type Type = Option<super::String>;
        const NAME: &'static str = "websiteUrl_not";
    }
    impl ::cynic::schema::HasInputField<WebsiteUrlNot, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct WebsiteUrlIn;
    impl ::cynic::schema::Field for WebsiteUrlIn {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "websiteUrl_in";
    }
    impl ::cynic::schema::HasInputField<WebsiteUrlIn, Option<Vec<super::String>>>
        for super::CompanyWhereInput
    {
    }
    pub struct WebsiteUrlNotIn;
    impl ::cynic::schema::Field for WebsiteUrlNotIn {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "websiteUrl_not_in";
    }
    impl ::cynic::schema::HasInputField<WebsiteUrlNotIn, Option<Vec<super::String>>>
        for super::CompanyWhereInput
    {
    }
    pub struct WebsiteUrlLt;
    impl ::cynic::schema::Field for WebsiteUrlLt {
        type Type = Option<super::String>;
        const NAME: &'static str = "websiteUrl_lt";
    }
    impl ::cynic::schema::HasInputField<WebsiteUrlLt, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct WebsiteUrlLte;
    impl ::cynic::schema::Field for WebsiteUrlLte {
        type Type = Option<super::String>;
        const NAME: &'static str = "websiteUrl_lte";
    }
    impl ::cynic::schema::HasInputField<WebsiteUrlLte, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct WebsiteUrlGt;
    impl ::cynic::schema::Field for WebsiteUrlGt {
        type Type = Option<super::String>;
        const NAME: &'static str = "websiteUrl_gt";
    }
    impl ::cynic::schema::HasInputField<WebsiteUrlGt, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct WebsiteUrlGte;
    impl ::cynic::schema::Field for WebsiteUrlGte {
        type Type = Option<super::String>;
        const NAME: &'static str = "websiteUrl_gte";
    }
    impl ::cynic::schema::HasInputField<WebsiteUrlGte, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct WebsiteUrlContains;
    impl ::cynic::schema::Field for WebsiteUrlContains {
        type Type = Option<super::String>;
        const NAME: &'static str = "websiteUrl_contains";
    }
    impl ::cynic::schema::HasInputField<WebsiteUrlContains, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct WebsiteUrlNotContains;
    impl ::cynic::schema::Field for WebsiteUrlNotContains {
        type Type = Option<super::String>;
        const NAME: &'static str = "websiteUrl_not_contains";
    }
    impl ::cynic::schema::HasInputField<WebsiteUrlNotContains, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct WebsiteUrlStartsWith;
    impl ::cynic::schema::Field for WebsiteUrlStartsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "websiteUrl_starts_with";
    }
    impl ::cynic::schema::HasInputField<WebsiteUrlStartsWith, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct WebsiteUrlNotStartsWith;
    impl ::cynic::schema::Field for WebsiteUrlNotStartsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "websiteUrl_not_starts_with";
    }
    impl ::cynic::schema::HasInputField<WebsiteUrlNotStartsWith, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct WebsiteUrlEndsWith;
    impl ::cynic::schema::Field for WebsiteUrlEndsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "websiteUrl_ends_with";
    }
    impl ::cynic::schema::HasInputField<WebsiteUrlEndsWith, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct WebsiteUrlNotEndsWith;
    impl ::cynic::schema::Field for WebsiteUrlNotEndsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "websiteUrl_not_ends_with";
    }
    impl ::cynic::schema::HasInputField<WebsiteUrlNotEndsWith, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct LogoUrl;
    impl ::cynic::schema::Field for LogoUrl {
        type Type = Option<super::String>;
        const NAME: &'static str = "logoUrl";
    }
    impl ::cynic::schema::HasInputField<LogoUrl, Option<super::String>> for super::CompanyWhereInput {}
    pub struct LogoUrlNot;
    impl ::cynic::schema::Field for LogoUrlNot {
        type Type = Option<super::String>;
        const NAME: &'static str = "logoUrl_not";
    }
    impl ::cynic::schema::HasInputField<LogoUrlNot, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct LogoUrlIn;
    impl ::cynic::schema::Field for LogoUrlIn {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "logoUrl_in";
    }
    impl ::cynic::schema::HasInputField<LogoUrlIn, Option<Vec<super::String>>>
        for super::CompanyWhereInput
    {
    }
    pub struct LogoUrlNotIn;
    impl ::cynic::schema::Field for LogoUrlNotIn {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "logoUrl_not_in";
    }
    impl ::cynic::schema::HasInputField<LogoUrlNotIn, Option<Vec<super::String>>>
        for super::CompanyWhereInput
    {
    }
    pub struct LogoUrlLt;
    impl ::cynic::schema::Field for LogoUrlLt {
        type Type = Option<super::String>;
        const NAME: &'static str = "logoUrl_lt";
    }
    impl ::cynic::schema::HasInputField<LogoUrlLt, Option<super::String>> for super::CompanyWhereInput {}
    pub struct LogoUrlLte;
    impl ::cynic::schema::Field for LogoUrlLte {
        type Type = Option<super::String>;
        const NAME: &'static str = "logoUrl_lte";
    }
    impl ::cynic::schema::HasInputField<LogoUrlLte, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct LogoUrlGt;
    impl ::cynic::schema::Field for LogoUrlGt {
        type Type = Option<super::String>;
        const NAME: &'static str = "logoUrl_gt";
    }
    impl ::cynic::schema::HasInputField<LogoUrlGt, Option<super::String>> for super::CompanyWhereInput {}
    pub struct LogoUrlGte;
    impl ::cynic::schema::Field for LogoUrlGte {
        type Type = Option<super::String>;
        const NAME: &'static str = "logoUrl_gte";
    }
    impl ::cynic::schema::HasInputField<LogoUrlGte, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct LogoUrlContains;
    impl ::cynic::schema::Field for LogoUrlContains {
        type Type = Option<super::String>;
        const NAME: &'static str = "logoUrl_contains";
    }
    impl ::cynic::schema::HasInputField<LogoUrlContains, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct LogoUrlNotContains;
    impl ::cynic::schema::Field for LogoUrlNotContains {
        type Type = Option<super::String>;
        const NAME: &'static str = "logoUrl_not_contains";
    }
    impl ::cynic::schema::HasInputField<LogoUrlNotContains, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct LogoUrlStartsWith;
    impl ::cynic::schema::Field for LogoUrlStartsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "logoUrl_starts_with";
    }
    impl ::cynic::schema::HasInputField<LogoUrlStartsWith, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct LogoUrlNotStartsWith;
    impl ::cynic::schema::Field for LogoUrlNotStartsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "logoUrl_not_starts_with";
    }
    impl ::cynic::schema::HasInputField<LogoUrlNotStartsWith, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct LogoUrlEndsWith;
    impl ::cynic::schema::Field for LogoUrlEndsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "logoUrl_ends_with";
    }
    impl ::cynic::schema::HasInputField<LogoUrlEndsWith, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct LogoUrlNotEndsWith;
    impl ::cynic::schema::Field for LogoUrlNotEndsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "logoUrl_not_ends_with";
    }
    impl ::cynic::schema::HasInputField<LogoUrlNotEndsWith, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct JobsEvery;
    impl ::cynic::schema::Field for JobsEvery {
        type Type = Option<super::JobWhereInput>;
        const NAME: &'static str = "jobs_every";
    }
    impl ::cynic::schema::HasInputField<JobsEvery, Option<super::JobWhereInput>>
        for super::CompanyWhereInput
    {
    }
    pub struct JobsSome;
    impl ::cynic::schema::Field for JobsSome {
        type Type = Option<super::JobWhereInput>;
        const NAME: &'static str = "jobs_some";
    }
    impl ::cynic::schema::HasInputField<JobsSome, Option<super::JobWhereInput>>
        for super::CompanyWhereInput
    {
    }
    pub struct JobsNone;
    impl ::cynic::schema::Field for JobsNone {
        type Type = Option<super::JobWhereInput>;
        const NAME: &'static str = "jobs_none";
    }
    impl ::cynic::schema::HasInputField<JobsNone, Option<super::JobWhereInput>>
        for super::CompanyWhereInput
    {
    }
    pub struct Twitter;
    impl ::cynic::schema::Field for Twitter {
        type Type = Option<super::String>;
        const NAME: &'static str = "twitter";
    }
    impl ::cynic::schema::HasInputField<Twitter, Option<super::String>> for super::CompanyWhereInput {}
    pub struct TwitterNot;
    impl ::cynic::schema::Field for TwitterNot {
        type Type = Option<super::String>;
        const NAME: &'static str = "twitter_not";
    }
    impl ::cynic::schema::HasInputField<TwitterNot, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct TwitterIn;
    impl ::cynic::schema::Field for TwitterIn {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "twitter_in";
    }
    impl ::cynic::schema::HasInputField<TwitterIn, Option<Vec<super::String>>>
        for super::CompanyWhereInput
    {
    }
    pub struct TwitterNotIn;
    impl ::cynic::schema::Field for TwitterNotIn {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "twitter_not_in";
    }
    impl ::cynic::schema::HasInputField<TwitterNotIn, Option<Vec<super::String>>>
        for super::CompanyWhereInput
    {
    }
    pub struct TwitterLt;
    impl ::cynic::schema::Field for TwitterLt {
        type Type = Option<super::String>;
        const NAME: &'static str = "twitter_lt";
    }
    impl ::cynic::schema::HasInputField<TwitterLt, Option<super::String>> for super::CompanyWhereInput {}
    pub struct TwitterLte;
    impl ::cynic::schema::Field for TwitterLte {
        type Type = Option<super::String>;
        const NAME: &'static str = "twitter_lte";
    }
    impl ::cynic::schema::HasInputField<TwitterLte, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct TwitterGt;
    impl ::cynic::schema::Field for TwitterGt {
        type Type = Option<super::String>;
        const NAME: &'static str = "twitter_gt";
    }
    impl ::cynic::schema::HasInputField<TwitterGt, Option<super::String>> for super::CompanyWhereInput {}
    pub struct TwitterGte;
    impl ::cynic::schema::Field for TwitterGte {
        type Type = Option<super::String>;
        const NAME: &'static str = "twitter_gte";
    }
    impl ::cynic::schema::HasInputField<TwitterGte, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct TwitterContains;
    impl ::cynic::schema::Field for TwitterContains {
        type Type = Option<super::String>;
        const NAME: &'static str = "twitter_contains";
    }
    impl ::cynic::schema::HasInputField<TwitterContains, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct TwitterNotContains;
    impl ::cynic::schema::Field for TwitterNotContains {
        type Type = Option<super::String>;
        const NAME: &'static str = "twitter_not_contains";
    }
    impl ::cynic::schema::HasInputField<TwitterNotContains, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct TwitterStartsWith;
    impl ::cynic::schema::Field for TwitterStartsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "twitter_starts_with";
    }
    impl ::cynic::schema::HasInputField<TwitterStartsWith, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct TwitterNotStartsWith;
    impl ::cynic::schema::Field for TwitterNotStartsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "twitter_not_starts_with";
    }
    impl ::cynic::schema::HasInputField<TwitterNotStartsWith, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct TwitterEndsWith;
    impl ::cynic::schema::Field for TwitterEndsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "twitter_ends_with";
    }
    impl ::cynic::schema::HasInputField<TwitterEndsWith, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct TwitterNotEndsWith;
    impl ::cynic::schema::Field for TwitterNotEndsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "twitter_not_ends_with";
    }
    impl ::cynic::schema::HasInputField<TwitterNotEndsWith, Option<super::String>>
        for super::CompanyWhereInput
    {
    }
    pub struct Emailed;
    impl ::cynic::schema::Field for Emailed {
        type Type = Option<super::Boolean>;
        const NAME: &'static str = "emailed";
    }
    impl ::cynic::schema::HasInputField<Emailed, Option<super::Boolean>> for super::CompanyWhereInput {}
    pub struct EmailedNot;
    impl ::cynic::schema::Field for EmailedNot {
        type Type = Option<super::Boolean>;
        const NAME: &'static str = "emailed_not";
    }
    impl ::cynic::schema::HasInputField<EmailedNot, Option<super::Boolean>>
        for super::CompanyWhereInput
    {
    }
    pub struct CreatedAt;
    impl ::cynic::schema::Field for CreatedAt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt";
    }
    impl ::cynic::schema::HasInputField<CreatedAt, Option<super::DateTime>>
        for super::CompanyWhereInput
    {
    }
    pub struct CreatedAtNot;
    impl ::cynic::schema::Field for CreatedAtNot {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt_not";
    }
    impl ::cynic::schema::HasInputField<CreatedAtNot, Option<super::DateTime>>
        for super::CompanyWhereInput
    {
    }
    pub struct CreatedAtIn;
    impl ::cynic::schema::Field for CreatedAtIn {
        type Type = Option<Vec<super::DateTime>>;
        const NAME: &'static str = "createdAt_in";
    }
    impl ::cynic::schema::HasInputField<CreatedAtIn, Option<Vec<super::DateTime>>>
        for super::CompanyWhereInput
    {
    }
    pub struct CreatedAtNotIn;
    impl ::cynic::schema::Field for CreatedAtNotIn {
        type Type = Option<Vec<super::DateTime>>;
        const NAME: &'static str = "createdAt_not_in";
    }
    impl ::cynic::schema::HasInputField<CreatedAtNotIn, Option<Vec<super::DateTime>>>
        for super::CompanyWhereInput
    {
    }
    pub struct CreatedAtLt;
    impl ::cynic::schema::Field for CreatedAtLt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt_lt";
    }
    impl ::cynic::schema::HasInputField<CreatedAtLt, Option<super::DateTime>>
        for super::CompanyWhereInput
    {
    }
    pub struct CreatedAtLte;
    impl ::cynic::schema::Field for CreatedAtLte {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt_lte";
    }
    impl ::cynic::schema::HasInputField<CreatedAtLte, Option<super::DateTime>>
        for super::CompanyWhereInput
    {
    }
    pub struct CreatedAtGt;
    impl ::cynic::schema::Field for CreatedAtGt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt_gt";
    }
    impl ::cynic::schema::HasInputField<CreatedAtGt, Option<super::DateTime>>
        for super::CompanyWhereInput
    {
    }
    pub struct CreatedAtGte;
    impl ::cynic::schema::Field for CreatedAtGte {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt_gte";
    }
    impl ::cynic::schema::HasInputField<CreatedAtGte, Option<super::DateTime>>
        for super::CompanyWhereInput
    {
    }
    pub struct UpdatedAt;
    impl ::cynic::schema::Field for UpdatedAt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt";
    }
    impl ::cynic::schema::HasInputField<UpdatedAt, Option<super::DateTime>>
        for super::CompanyWhereInput
    {
    }
    pub struct UpdatedAtNot;
    impl ::cynic::schema::Field for UpdatedAtNot {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt_not";
    }
    impl ::cynic::schema::HasInputField<UpdatedAtNot, Option<super::DateTime>>
        for super::CompanyWhereInput
    {
    }
    pub struct UpdatedAtIn;
    impl ::cynic::schema::Field for UpdatedAtIn {
        type Type = Option<Vec<super::DateTime>>;
        const NAME: &'static str = "updatedAt_in";
    }
    impl ::cynic::schema::HasInputField<UpdatedAtIn, Option<Vec<super::DateTime>>>
        for super::CompanyWhereInput
    {
    }
    pub struct UpdatedAtNotIn;
    impl ::cynic::schema::Field for UpdatedAtNotIn {
        type Type = Option<Vec<super::DateTime>>;
        const NAME: &'static str = "updatedAt_not_in";
    }
    impl ::cynic::schema::HasInputField<UpdatedAtNotIn, Option<Vec<super::DateTime>>>
        for super::CompanyWhereInput
    {
    }
    pub struct UpdatedAtLt;
    impl ::cynic::schema::Field for UpdatedAtLt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt_lt";
    }
    impl ::cynic::schema::HasInputField<UpdatedAtLt, Option<super::DateTime>>
        for super::CompanyWhereInput
    {
    }
    pub struct UpdatedAtLte;
    impl ::cynic::schema::Field for UpdatedAtLte {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt_lte";
    }
    impl ::cynic::schema::HasInputField<UpdatedAtLte, Option<super::DateTime>>
        for super::CompanyWhereInput
    {
    }
    pub struct UpdatedAtGt;
    impl ::cynic::schema::Field for UpdatedAtGt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt_gt";
    }
    impl ::cynic::schema::HasInputField<UpdatedAtGt, Option<super::DateTime>>
        for super::CompanyWhereInput
    {
    }
    pub struct UpdatedAtGte;
    impl ::cynic::schema::Field for UpdatedAtGte {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt_gte";
    }
    impl ::cynic::schema::HasInputField<UpdatedAtGte, Option<super::DateTime>>
        for super::CompanyWhereInput
    {
    }
    pub struct And;
    impl ::cynic::schema::Field for And {
        type Type = Option<Vec<super::CompanyWhereInput>>;
        const NAME: &'static str = "AND";
    }
    impl ::cynic::schema::HasInputField<And, Option<Vec<super::CompanyWhereInput>>>
        for super::CompanyWhereInput
    {
    }
    pub struct Or;
    impl ::cynic::schema::Field for Or {
        type Type = Option<Vec<super::CompanyWhereInput>>;
        const NAME: &'static str = "OR";
    }
    impl ::cynic::schema::HasInputField<Or, Option<Vec<super::CompanyWhereInput>>>
        for super::CompanyWhereInput
    {
    }
    pub struct Not;
    impl ::cynic::schema::Field for Not {
        type Type = Option<Vec<super::CompanyWhereInput>>;
        const NAME: &'static str = "NOT";
    }
    impl ::cynic::schema::HasInputField<Not, Option<Vec<super::CompanyWhereInput>>>
        for super::CompanyWhereInput
    {
    }
}
pub struct Country;
pub mod country_fields {
    pub struct Id;
    impl ::cynic::schema::Field for Id {
        type Type = super::Id;
        const NAME: &'static str = "id";
    }
    impl ::cynic::schema::HasField<Id> for super::Country {
        type Type = super::Id;
    }
    pub struct Name;
    impl ::cynic::schema::Field for Name {
        type Type = super::String;
        const NAME: &'static str = "name";
    }
    impl ::cynic::schema::HasField<Name> for super::Country {
        type Type = super::String;
    }
    pub struct Slug;
    impl ::cynic::schema::Field for Slug {
        type Type = super::String;
        const NAME: &'static str = "slug";
    }
    impl ::cynic::schema::HasField<Slug> for super::Country {
        type Type = super::String;
    }
    pub struct Type;
    impl ::cynic::schema::Field for Type {
        type Type = super::String;
        const NAME: &'static str = "type";
    }
    impl ::cynic::schema::HasField<Type> for super::Country {
        type Type = super::String;
    }
    pub struct IsoCode;
    impl ::cynic::schema::Field for IsoCode {
        type Type = Option<super::String>;
        const NAME: &'static str = "isoCode";
    }
    impl ::cynic::schema::HasField<IsoCode> for super::Country {
        type Type = Option<super::String>;
    }
    pub struct Cities;
    impl ::cynic::schema::Field for Cities {
        type Type = Option<Vec<super::City>>;
        const NAME: &'static str = "cities";
    }
    impl ::cynic::schema::HasField<Cities> for super::Country {
        type Type = Option<Vec<super::City>>;
    }
    pub mod cities_arguments {
        pub struct Where;
        impl ::cynic::schema::HasArgument<Where> for super::Cities {
            type ArgumentType = Option<super::super::CityWhereInput>;
            const NAME: &'static str = "where";
        }
        pub struct OrderBy;
        impl ::cynic::schema::HasArgument<OrderBy> for super::Cities {
            type ArgumentType = Option<super::super::CityOrderByInput>;
            const NAME: &'static str = "orderBy";
        }
        pub struct Skip;
        impl ::cynic::schema::HasArgument<Skip> for super::Cities {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "skip";
        }
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::Cities {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "after";
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::Cities {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "before";
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::Cities {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "first";
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::Cities {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "last";
        }
    }
    pub struct Jobs;
    impl ::cynic::schema::Field for Jobs {
        type Type = Option<Vec<super::Job>>;
        const NAME: &'static str = "jobs";
    }
    impl ::cynic::schema::HasField<Jobs> for super::Country {
        type Type = Option<Vec<super::Job>>;
    }
    pub mod jobs_arguments {
        pub struct Where;
        impl ::cynic::schema::HasArgument<Where> for super::Jobs {
            type ArgumentType = Option<super::super::JobWhereInput>;
            const NAME: &'static str = "where";
        }
        pub struct OrderBy;
        impl ::cynic::schema::HasArgument<OrderBy> for super::Jobs {
            type ArgumentType = Option<super::super::JobOrderByInput>;
            const NAME: &'static str = "orderBy";
        }
        pub struct Skip;
        impl ::cynic::schema::HasArgument<Skip> for super::Jobs {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "skip";
        }
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::Jobs {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "after";
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::Jobs {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "before";
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::Jobs {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "first";
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::Jobs {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "last";
        }
    }
    pub struct CreatedAt;
    impl ::cynic::schema::Field for CreatedAt {
        type Type = super::DateTime;
        const NAME: &'static str = "createdAt";
    }
    impl ::cynic::schema::HasField<CreatedAt> for super::Country {
        type Type = super::DateTime;
    }
    pub struct UpdatedAt;
    impl ::cynic::schema::Field for UpdatedAt {
        type Type = super::DateTime;
        const NAME: &'static str = "updatedAt";
    }
    impl ::cynic::schema::HasField<UpdatedAt> for super::Country {
        type Type = super::DateTime;
    }
}
pub struct CountryOrderByInput {}
pub struct CountryWhereInput;
impl ::cynic::schema::InputObjectMarker for CountryWhereInput {}
pub mod country_where_input_fields {
    pub struct Id;
    impl ::cynic::schema::Field for Id {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id";
    }
    impl ::cynic::schema::HasInputField<Id, Option<super::Id>> for super::CountryWhereInput {}
    pub struct IdNot;
    impl ::cynic::schema::Field for IdNot {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_not";
    }
    impl ::cynic::schema::HasInputField<IdNot, Option<super::Id>> for super::CountryWhereInput {}
    pub struct IdIn;
    impl ::cynic::schema::Field for IdIn {
        type Type = Option<Vec<super::Id>>;
        const NAME: &'static str = "id_in";
    }
    impl ::cynic::schema::HasInputField<IdIn, Option<Vec<super::Id>>> for super::CountryWhereInput {}
    pub struct IdNotIn;
    impl ::cynic::schema::Field for IdNotIn {
        type Type = Option<Vec<super::Id>>;
        const NAME: &'static str = "id_not_in";
    }
    impl ::cynic::schema::HasInputField<IdNotIn, Option<Vec<super::Id>>> for super::CountryWhereInput {}
    pub struct IdLt;
    impl ::cynic::schema::Field for IdLt {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_lt";
    }
    impl ::cynic::schema::HasInputField<IdLt, Option<super::Id>> for super::CountryWhereInput {}
    pub struct IdLte;
    impl ::cynic::schema::Field for IdLte {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_lte";
    }
    impl ::cynic::schema::HasInputField<IdLte, Option<super::Id>> for super::CountryWhereInput {}
    pub struct IdGt;
    impl ::cynic::schema::Field for IdGt {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_gt";
    }
    impl ::cynic::schema::HasInputField<IdGt, Option<super::Id>> for super::CountryWhereInput {}
    pub struct IdGte;
    impl ::cynic::schema::Field for IdGte {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_gte";
    }
    impl ::cynic::schema::HasInputField<IdGte, Option<super::Id>> for super::CountryWhereInput {}
    pub struct IdContains;
    impl ::cynic::schema::Field for IdContains {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_contains";
    }
    impl ::cynic::schema::HasInputField<IdContains, Option<super::Id>> for super::CountryWhereInput {}
    pub struct IdNotContains;
    impl ::cynic::schema::Field for IdNotContains {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_not_contains";
    }
    impl ::cynic::schema::HasInputField<IdNotContains, Option<super::Id>> for super::CountryWhereInput {}
    pub struct IdStartsWith;
    impl ::cynic::schema::Field for IdStartsWith {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_starts_with";
    }
    impl ::cynic::schema::HasInputField<IdStartsWith, Option<super::Id>> for super::CountryWhereInput {}
    pub struct IdNotStartsWith;
    impl ::cynic::schema::Field for IdNotStartsWith {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_not_starts_with";
    }
    impl ::cynic::schema::HasInputField<IdNotStartsWith, Option<super::Id>>
        for super::CountryWhereInput
    {
    }
    pub struct IdEndsWith;
    impl ::cynic::schema::Field for IdEndsWith {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_ends_with";
    }
    impl ::cynic::schema::HasInputField<IdEndsWith, Option<super::Id>> for super::CountryWhereInput {}
    pub struct IdNotEndsWith;
    impl ::cynic::schema::Field for IdNotEndsWith {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_not_ends_with";
    }
    impl ::cynic::schema::HasInputField<IdNotEndsWith, Option<super::Id>> for super::CountryWhereInput {}
    pub struct Name;
    impl ::cynic::schema::Field for Name {
        type Type = Option<super::String>;
        const NAME: &'static str = "name";
    }
    impl ::cynic::schema::HasInputField<Name, Option<super::String>> for super::CountryWhereInput {}
    pub struct NameNot;
    impl ::cynic::schema::Field for NameNot {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_not";
    }
    impl ::cynic::schema::HasInputField<NameNot, Option<super::String>> for super::CountryWhereInput {}
    pub struct NameIn;
    impl ::cynic::schema::Field for NameIn {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "name_in";
    }
    impl ::cynic::schema::HasInputField<NameIn, Option<Vec<super::String>>>
        for super::CountryWhereInput
    {
    }
    pub struct NameNotIn;
    impl ::cynic::schema::Field for NameNotIn {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "name_not_in";
    }
    impl ::cynic::schema::HasInputField<NameNotIn, Option<Vec<super::String>>>
        for super::CountryWhereInput
    {
    }
    pub struct NameLt;
    impl ::cynic::schema::Field for NameLt {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_lt";
    }
    impl ::cynic::schema::HasInputField<NameLt, Option<super::String>> for super::CountryWhereInput {}
    pub struct NameLte;
    impl ::cynic::schema::Field for NameLte {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_lte";
    }
    impl ::cynic::schema::HasInputField<NameLte, Option<super::String>> for super::CountryWhereInput {}
    pub struct NameGt;
    impl ::cynic::schema::Field for NameGt {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_gt";
    }
    impl ::cynic::schema::HasInputField<NameGt, Option<super::String>> for super::CountryWhereInput {}
    pub struct NameGte;
    impl ::cynic::schema::Field for NameGte {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_gte";
    }
    impl ::cynic::schema::HasInputField<NameGte, Option<super::String>> for super::CountryWhereInput {}
    pub struct NameContains;
    impl ::cynic::schema::Field for NameContains {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_contains";
    }
    impl ::cynic::schema::HasInputField<NameContains, Option<super::String>>
        for super::CountryWhereInput
    {
    }
    pub struct NameNotContains;
    impl ::cynic::schema::Field for NameNotContains {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_not_contains";
    }
    impl ::cynic::schema::HasInputField<NameNotContains, Option<super::String>>
        for super::CountryWhereInput
    {
    }
    pub struct NameStartsWith;
    impl ::cynic::schema::Field for NameStartsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_starts_with";
    }
    impl ::cynic::schema::HasInputField<NameStartsWith, Option<super::String>>
        for super::CountryWhereInput
    {
    }
    pub struct NameNotStartsWith;
    impl ::cynic::schema::Field for NameNotStartsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_not_starts_with";
    }
    impl ::cynic::schema::HasInputField<NameNotStartsWith, Option<super::String>>
        for super::CountryWhereInput
    {
    }
    pub struct NameEndsWith;
    impl ::cynic::schema::Field for NameEndsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_ends_with";
    }
    impl ::cynic::schema::HasInputField<NameEndsWith, Option<super::String>>
        for super::CountryWhereInput
    {
    }
    pub struct NameNotEndsWith;
    impl ::cynic::schema::Field for NameNotEndsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_not_ends_with";
    }
    impl ::cynic::schema::HasInputField<NameNotEndsWith, Option<super::String>>
        for super::CountryWhereInput
    {
    }
    pub struct Slug;
    impl ::cynic::schema::Field for Slug {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug";
    }
    impl ::cynic::schema::HasInputField<Slug, Option<super::String>> for super::CountryWhereInput {}
    pub struct SlugNot;
    impl ::cynic::schema::Field for SlugNot {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_not";
    }
    impl ::cynic::schema::HasInputField<SlugNot, Option<super::String>> for super::CountryWhereInput {}
    pub struct SlugIn;
    impl ::cynic::schema::Field for SlugIn {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "slug_in";
    }
    impl ::cynic::schema::HasInputField<SlugIn, Option<Vec<super::String>>>
        for super::CountryWhereInput
    {
    }
    pub struct SlugNotIn;
    impl ::cynic::schema::Field for SlugNotIn {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "slug_not_in";
    }
    impl ::cynic::schema::HasInputField<SlugNotIn, Option<Vec<super::String>>>
        for super::CountryWhereInput
    {
    }
    pub struct SlugLt;
    impl ::cynic::schema::Field for SlugLt {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_lt";
    }
    impl ::cynic::schema::HasInputField<SlugLt, Option<super::String>> for super::CountryWhereInput {}
    pub struct SlugLte;
    impl ::cynic::schema::Field for SlugLte {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_lte";
    }
    impl ::cynic::schema::HasInputField<SlugLte, Option<super::String>> for super::CountryWhereInput {}
    pub struct SlugGt;
    impl ::cynic::schema::Field for SlugGt {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_gt";
    }
    impl ::cynic::schema::HasInputField<SlugGt, Option<super::String>> for super::CountryWhereInput {}
    pub struct SlugGte;
    impl ::cynic::schema::Field for SlugGte {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_gte";
    }
    impl ::cynic::schema::HasInputField<SlugGte, Option<super::String>> for super::CountryWhereInput {}
    pub struct SlugContains;
    impl ::cynic::schema::Field for SlugContains {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_contains";
    }
    impl ::cynic::schema::HasInputField<SlugContains, Option<super::String>>
        for super::CountryWhereInput
    {
    }
    pub struct SlugNotContains;
    impl ::cynic::schema::Field for SlugNotContains {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_not_contains";
    }
    impl ::cynic::schema::HasInputField<SlugNotContains, Option<super::String>>
        for super::CountryWhereInput
    {
    }
    pub struct SlugStartsWith;
    impl ::cynic::schema::Field for SlugStartsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_starts_with";
    }
    impl ::cynic::schema::HasInputField<SlugStartsWith, Option<super::String>>
        for super::CountryWhereInput
    {
    }
    pub struct SlugNotStartsWith;
    impl ::cynic::schema::Field for SlugNotStartsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_not_starts_with";
    }
    impl ::cynic::schema::HasInputField<SlugNotStartsWith, Option<super::String>>
        for super::CountryWhereInput
    {
    }
    pub struct SlugEndsWith;
    impl ::cynic::schema::Field for SlugEndsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_ends_with";
    }
    impl ::cynic::schema::HasInputField<SlugEndsWith, Option<super::String>>
        for super::CountryWhereInput
    {
    }
    pub struct SlugNotEndsWith;
    impl ::cynic::schema::Field for SlugNotEndsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_not_ends_with";
    }
    impl ::cynic::schema::HasInputField<SlugNotEndsWith, Option<super::String>>
        for super::CountryWhereInput
    {
    }
    pub struct Type;
    impl ::cynic::schema::Field for Type {
        type Type = Option<super::String>;
        const NAME: &'static str = "type";
    }
    impl ::cynic::schema::HasInputField<Type, Option<super::String>> for super::CountryWhereInput {}
    pub struct TypeNot;
    impl ::cynic::schema::Field for TypeNot {
        type Type = Option<super::String>;
        const NAME: &'static str = "type_not";
    }
    impl ::cynic::schema::HasInputField<TypeNot, Option<super::String>> for super::CountryWhereInput {}
    pub struct TypeIn;
    impl ::cynic::schema::Field for TypeIn {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "type_in";
    }
    impl ::cynic::schema::HasInputField<TypeIn, Option<Vec<super::String>>>
        for super::CountryWhereInput
    {
    }
    pub struct TypeNotIn;
    impl ::cynic::schema::Field for TypeNotIn {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "type_not_in";
    }
    impl ::cynic::schema::HasInputField<TypeNotIn, Option<Vec<super::String>>>
        for super::CountryWhereInput
    {
    }
    pub struct TypeLt;
    impl ::cynic::schema::Field for TypeLt {
        type Type = Option<super::String>;
        const NAME: &'static str = "type_lt";
    }
    impl ::cynic::schema::HasInputField<TypeLt, Option<super::String>> for super::CountryWhereInput {}
    pub struct TypeLte;
    impl ::cynic::schema::Field for TypeLte {
        type Type = Option<super::String>;
        const NAME: &'static str = "type_lte";
    }
    impl ::cynic::schema::HasInputField<TypeLte, Option<super::String>> for super::CountryWhereInput {}
    pub struct TypeGt;
    impl ::cynic::schema::Field for TypeGt {
        type Type = Option<super::String>;
        const NAME: &'static str = "type_gt";
    }
    impl ::cynic::schema::HasInputField<TypeGt, Option<super::String>> for super::CountryWhereInput {}
    pub struct TypeGte;
    impl ::cynic::schema::Field for TypeGte {
        type Type = Option<super::String>;
        const NAME: &'static str = "type_gte";
    }
    impl ::cynic::schema::HasInputField<TypeGte, Option<super::String>> for super::CountryWhereInput {}
    pub struct TypeContains;
    impl ::cynic::schema::Field for TypeContains {
        type Type = Option<super::String>;
        const NAME: &'static str = "type_contains";
    }
    impl ::cynic::schema::HasInputField<TypeContains, Option<super::String>>
        for super::CountryWhereInput
    {
    }
    pub struct TypeNotContains;
    impl ::cynic::schema::Field for TypeNotContains {
        type Type = Option<super::String>;
        const NAME: &'static str = "type_not_contains";
    }
    impl ::cynic::schema::HasInputField<TypeNotContains, Option<super::String>>
        for super::CountryWhereInput
    {
    }
    pub struct TypeStartsWith;
    impl ::cynic::schema::Field for TypeStartsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "type_starts_with";
    }
    impl ::cynic::schema::HasInputField<TypeStartsWith, Option<super::String>>
        for super::CountryWhereInput
    {
    }
    pub struct TypeNotStartsWith;
    impl ::cynic::schema::Field for TypeNotStartsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "type_not_starts_with";
    }
    impl ::cynic::schema::HasInputField<TypeNotStartsWith, Option<super::String>>
        for super::CountryWhereInput
    {
    }
    pub struct TypeEndsWith;
    impl ::cynic::schema::Field for TypeEndsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "type_ends_with";
    }
    impl ::cynic::schema::HasInputField<TypeEndsWith, Option<super::String>>
        for super::CountryWhereInput
    {
    }
    pub struct TypeNotEndsWith;
    impl ::cynic::schema::Field for TypeNotEndsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "type_not_ends_with";
    }
    impl ::cynic::schema::HasInputField<TypeNotEndsWith, Option<super::String>>
        for super::CountryWhereInput
    {
    }
    pub struct IsoCode;
    impl ::cynic::schema::Field for IsoCode {
        type Type = Option<super::String>;
        const NAME: &'static str = "isoCode";
    }
    impl ::cynic::schema::HasInputField<IsoCode, Option<super::String>> for super::CountryWhereInput {}
    pub struct IsoCodeNot;
    impl ::cynic::schema::Field for IsoCodeNot {
        type Type = Option<super::String>;
        const NAME: &'static str = "isoCode_not";
    }
    impl ::cynic::schema::HasInputField<IsoCodeNot, Option<super::String>>
        for super::CountryWhereInput
    {
    }
    pub struct IsoCodeIn;
    impl ::cynic::schema::Field for IsoCodeIn {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "isoCode_in";
    }
    impl ::cynic::schema::HasInputField<IsoCodeIn, Option<Vec<super::String>>>
        for super::CountryWhereInput
    {
    }
    pub struct IsoCodeNotIn;
    impl ::cynic::schema::Field for IsoCodeNotIn {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "isoCode_not_in";
    }
    impl ::cynic::schema::HasInputField<IsoCodeNotIn, Option<Vec<super::String>>>
        for super::CountryWhereInput
    {
    }
    pub struct IsoCodeLt;
    impl ::cynic::schema::Field for IsoCodeLt {
        type Type = Option<super::String>;
        const NAME: &'static str = "isoCode_lt";
    }
    impl ::cynic::schema::HasInputField<IsoCodeLt, Option<super::String>> for super::CountryWhereInput {}
    pub struct IsoCodeLte;
    impl ::cynic::schema::Field for IsoCodeLte {
        type Type = Option<super::String>;
        const NAME: &'static str = "isoCode_lte";
    }
    impl ::cynic::schema::HasInputField<IsoCodeLte, Option<super::String>>
        for super::CountryWhereInput
    {
    }
    pub struct IsoCodeGt;
    impl ::cynic::schema::Field for IsoCodeGt {
        type Type = Option<super::String>;
        const NAME: &'static str = "isoCode_gt";
    }
    impl ::cynic::schema::HasInputField<IsoCodeGt, Option<super::String>> for super::CountryWhereInput {}
    pub struct IsoCodeGte;
    impl ::cynic::schema::Field for IsoCodeGte {
        type Type = Option<super::String>;
        const NAME: &'static str = "isoCode_gte";
    }
    impl ::cynic::schema::HasInputField<IsoCodeGte, Option<super::String>>
        for super::CountryWhereInput
    {
    }
    pub struct IsoCodeContains;
    impl ::cynic::schema::Field for IsoCodeContains {
        type Type = Option<super::String>;
        const NAME: &'static str = "isoCode_contains";
    }
    impl ::cynic::schema::HasInputField<IsoCodeContains, Option<super::String>>
        for super::CountryWhereInput
    {
    }
    pub struct IsoCodeNotContains;
    impl ::cynic::schema::Field for IsoCodeNotContains {
        type Type = Option<super::String>;
        const NAME: &'static str = "isoCode_not_contains";
    }
    impl ::cynic::schema::HasInputField<IsoCodeNotContains, Option<super::String>>
        for super::CountryWhereInput
    {
    }
    pub struct IsoCodeStartsWith;
    impl ::cynic::schema::Field for IsoCodeStartsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "isoCode_starts_with";
    }
    impl ::cynic::schema::HasInputField<IsoCodeStartsWith, Option<super::String>>
        for super::CountryWhereInput
    {
    }
    pub struct IsoCodeNotStartsWith;
    impl ::cynic::schema::Field for IsoCodeNotStartsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "isoCode_not_starts_with";
    }
    impl ::cynic::schema::HasInputField<IsoCodeNotStartsWith, Option<super::String>>
        for super::CountryWhereInput
    {
    }
    pub struct IsoCodeEndsWith;
    impl ::cynic::schema::Field for IsoCodeEndsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "isoCode_ends_with";
    }
    impl ::cynic::schema::HasInputField<IsoCodeEndsWith, Option<super::String>>
        for super::CountryWhereInput
    {
    }
    pub struct IsoCodeNotEndsWith;
    impl ::cynic::schema::Field for IsoCodeNotEndsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "isoCode_not_ends_with";
    }
    impl ::cynic::schema::HasInputField<IsoCodeNotEndsWith, Option<super::String>>
        for super::CountryWhereInput
    {
    }
    pub struct CitiesEvery;
    impl ::cynic::schema::Field for CitiesEvery {
        type Type = Option<super::CityWhereInput>;
        const NAME: &'static str = "cities_every";
    }
    impl ::cynic::schema::HasInputField<CitiesEvery, Option<super::CityWhereInput>>
        for super::CountryWhereInput
    {
    }
    pub struct CitiesSome;
    impl ::cynic::schema::Field for CitiesSome {
        type Type = Option<super::CityWhereInput>;
        const NAME: &'static str = "cities_some";
    }
    impl ::cynic::schema::HasInputField<CitiesSome, Option<super::CityWhereInput>>
        for super::CountryWhereInput
    {
    }
    pub struct CitiesNone;
    impl ::cynic::schema::Field for CitiesNone {
        type Type = Option<super::CityWhereInput>;
        const NAME: &'static str = "cities_none";
    }
    impl ::cynic::schema::HasInputField<CitiesNone, Option<super::CityWhereInput>>
        for super::CountryWhereInput
    {
    }
    pub struct JobsEvery;
    impl ::cynic::schema::Field for JobsEvery {
        type Type = Option<super::JobWhereInput>;
        const NAME: &'static str = "jobs_every";
    }
    impl ::cynic::schema::HasInputField<JobsEvery, Option<super::JobWhereInput>>
        for super::CountryWhereInput
    {
    }
    pub struct JobsSome;
    impl ::cynic::schema::Field for JobsSome {
        type Type = Option<super::JobWhereInput>;
        const NAME: &'static str = "jobs_some";
    }
    impl ::cynic::schema::HasInputField<JobsSome, Option<super::JobWhereInput>>
        for super::CountryWhereInput
    {
    }
    pub struct JobsNone;
    impl ::cynic::schema::Field for JobsNone {
        type Type = Option<super::JobWhereInput>;
        const NAME: &'static str = "jobs_none";
    }
    impl ::cynic::schema::HasInputField<JobsNone, Option<super::JobWhereInput>>
        for super::CountryWhereInput
    {
    }
    pub struct CreatedAt;
    impl ::cynic::schema::Field for CreatedAt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt";
    }
    impl ::cynic::schema::HasInputField<CreatedAt, Option<super::DateTime>>
        for super::CountryWhereInput
    {
    }
    pub struct CreatedAtNot;
    impl ::cynic::schema::Field for CreatedAtNot {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt_not";
    }
    impl ::cynic::schema::HasInputField<CreatedAtNot, Option<super::DateTime>>
        for super::CountryWhereInput
    {
    }
    pub struct CreatedAtIn;
    impl ::cynic::schema::Field for CreatedAtIn {
        type Type = Option<Vec<super::DateTime>>;
        const NAME: &'static str = "createdAt_in";
    }
    impl ::cynic::schema::HasInputField<CreatedAtIn, Option<Vec<super::DateTime>>>
        for super::CountryWhereInput
    {
    }
    pub struct CreatedAtNotIn;
    impl ::cynic::schema::Field for CreatedAtNotIn {
        type Type = Option<Vec<super::DateTime>>;
        const NAME: &'static str = "createdAt_not_in";
    }
    impl ::cynic::schema::HasInputField<CreatedAtNotIn, Option<Vec<super::DateTime>>>
        for super::CountryWhereInput
    {
    }
    pub struct CreatedAtLt;
    impl ::cynic::schema::Field for CreatedAtLt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt_lt";
    }
    impl ::cynic::schema::HasInputField<CreatedAtLt, Option<super::DateTime>>
        for super::CountryWhereInput
    {
    }
    pub struct CreatedAtLte;
    impl ::cynic::schema::Field for CreatedAtLte {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt_lte";
    }
    impl ::cynic::schema::HasInputField<CreatedAtLte, Option<super::DateTime>>
        for super::CountryWhereInput
    {
    }
    pub struct CreatedAtGt;
    impl ::cynic::schema::Field for CreatedAtGt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt_gt";
    }
    impl ::cynic::schema::HasInputField<CreatedAtGt, Option<super::DateTime>>
        for super::CountryWhereInput
    {
    }
    pub struct CreatedAtGte;
    impl ::cynic::schema::Field for CreatedAtGte {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt_gte";
    }
    impl ::cynic::schema::HasInputField<CreatedAtGte, Option<super::DateTime>>
        for super::CountryWhereInput
    {
    }
    pub struct UpdatedAt;
    impl ::cynic::schema::Field for UpdatedAt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt";
    }
    impl ::cynic::schema::HasInputField<UpdatedAt, Option<super::DateTime>>
        for super::CountryWhereInput
    {
    }
    pub struct UpdatedAtNot;
    impl ::cynic::schema::Field for UpdatedAtNot {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt_not";
    }
    impl ::cynic::schema::HasInputField<UpdatedAtNot, Option<super::DateTime>>
        for super::CountryWhereInput
    {
    }
    pub struct UpdatedAtIn;
    impl ::cynic::schema::Field for UpdatedAtIn {
        type Type = Option<Vec<super::DateTime>>;
        const NAME: &'static str = "updatedAt_in";
    }
    impl ::cynic::schema::HasInputField<UpdatedAtIn, Option<Vec<super::DateTime>>>
        for super::CountryWhereInput
    {
    }
    pub struct UpdatedAtNotIn;
    impl ::cynic::schema::Field for UpdatedAtNotIn {
        type Type = Option<Vec<super::DateTime>>;
        const NAME: &'static str = "updatedAt_not_in";
    }
    impl ::cynic::schema::HasInputField<UpdatedAtNotIn, Option<Vec<super::DateTime>>>
        for super::CountryWhereInput
    {
    }
    pub struct UpdatedAtLt;
    impl ::cynic::schema::Field for UpdatedAtLt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt_lt";
    }
    impl ::cynic::schema::HasInputField<UpdatedAtLt, Option<super::DateTime>>
        for super::CountryWhereInput
    {
    }
    pub struct UpdatedAtLte;
    impl ::cynic::schema::Field for UpdatedAtLte {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt_lte";
    }
    impl ::cynic::schema::HasInputField<UpdatedAtLte, Option<super::DateTime>>
        for super::CountryWhereInput
    {
    }
    pub struct UpdatedAtGt;
    impl ::cynic::schema::Field for UpdatedAtGt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt_gt";
    }
    impl ::cynic::schema::HasInputField<UpdatedAtGt, Option<super::DateTime>>
        for super::CountryWhereInput
    {
    }
    pub struct UpdatedAtGte;
    impl ::cynic::schema::Field for UpdatedAtGte {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt_gte";
    }
    impl ::cynic::schema::HasInputField<UpdatedAtGte, Option<super::DateTime>>
        for super::CountryWhereInput
    {
    }
    pub struct And;
    impl ::cynic::schema::Field for And {
        type Type = Option<Vec<super::CountryWhereInput>>;
        const NAME: &'static str = "AND";
    }
    impl ::cynic::schema::HasInputField<And, Option<Vec<super::CountryWhereInput>>>
        for super::CountryWhereInput
    {
    }
    pub struct Or;
    impl ::cynic::schema::Field for Or {
        type Type = Option<Vec<super::CountryWhereInput>>;
        const NAME: &'static str = "OR";
    }
    impl ::cynic::schema::HasInputField<Or, Option<Vec<super::CountryWhereInput>>>
        for super::CountryWhereInput
    {
    }
    pub struct Not;
    impl ::cynic::schema::Field for Not {
        type Type = Option<Vec<super::CountryWhereInput>>;
        const NAME: &'static str = "NOT";
    }
    impl ::cynic::schema::HasInputField<Not, Option<Vec<super::CountryWhereInput>>>
        for super::CountryWhereInput
    {
    }
}
pub struct DateTime {}
pub struct Job;
pub mod job_fields {
    pub struct Id;
    impl ::cynic::schema::Field for Id {
        type Type = super::Id;
        const NAME: &'static str = "id";
    }
    impl ::cynic::schema::HasField<Id> for super::Job {
        type Type = super::Id;
    }
    pub struct Title;
    impl ::cynic::schema::Field for Title {
        type Type = super::String;
        const NAME: &'static str = "title";
    }
    impl ::cynic::schema::HasField<Title> for super::Job {
        type Type = super::String;
    }
    pub struct Slug;
    impl ::cynic::schema::Field for Slug {
        type Type = super::String;
        const NAME: &'static str = "slug";
    }
    impl ::cynic::schema::HasField<Slug> for super::Job {
        type Type = super::String;
    }
    pub struct Commitment;
    impl ::cynic::schema::Field for Commitment {
        type Type = super::Commitment;
        const NAME: &'static str = "commitment";
    }
    impl ::cynic::schema::HasField<Commitment> for super::Job {
        type Type = super::Commitment;
    }
    pub struct Cities;
    impl ::cynic::schema::Field for Cities {
        type Type = Option<Vec<super::City>>;
        const NAME: &'static str = "cities";
    }
    impl ::cynic::schema::HasField<Cities> for super::Job {
        type Type = Option<Vec<super::City>>;
    }
    pub mod cities_arguments {
        pub struct Where;
        impl ::cynic::schema::HasArgument<Where> for super::Cities {
            type ArgumentType = Option<super::super::CityWhereInput>;
            const NAME: &'static str = "where";
        }
        pub struct OrderBy;
        impl ::cynic::schema::HasArgument<OrderBy> for super::Cities {
            type ArgumentType = Option<super::super::CityOrderByInput>;
            const NAME: &'static str = "orderBy";
        }
        pub struct Skip;
        impl ::cynic::schema::HasArgument<Skip> for super::Cities {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "skip";
        }
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::Cities {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "after";
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::Cities {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "before";
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::Cities {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "first";
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::Cities {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "last";
        }
    }
    pub struct Countries;
    impl ::cynic::schema::Field for Countries {
        type Type = Option<Vec<super::Country>>;
        const NAME: &'static str = "countries";
    }
    impl ::cynic::schema::HasField<Countries> for super::Job {
        type Type = Option<Vec<super::Country>>;
    }
    pub mod countries_arguments {
        pub struct Where;
        impl ::cynic::schema::HasArgument<Where> for super::Countries {
            type ArgumentType = Option<super::super::CountryWhereInput>;
            const NAME: &'static str = "where";
        }
        pub struct OrderBy;
        impl ::cynic::schema::HasArgument<OrderBy> for super::Countries {
            type ArgumentType = Option<super::super::CountryOrderByInput>;
            const NAME: &'static str = "orderBy";
        }
        pub struct Skip;
        impl ::cynic::schema::HasArgument<Skip> for super::Countries {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "skip";
        }
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::Countries {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "after";
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::Countries {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "before";
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::Countries {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "first";
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::Countries {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "last";
        }
    }
    pub struct Remotes;
    impl ::cynic::schema::Field for Remotes {
        type Type = Option<Vec<super::Remote>>;
        const NAME: &'static str = "remotes";
    }
    impl ::cynic::schema::HasField<Remotes> for super::Job {
        type Type = Option<Vec<super::Remote>>;
    }
    pub mod remotes_arguments {
        pub struct Where;
        impl ::cynic::schema::HasArgument<Where> for super::Remotes {
            type ArgumentType = Option<super::super::RemoteWhereInput>;
            const NAME: &'static str = "where";
        }
        pub struct OrderBy;
        impl ::cynic::schema::HasArgument<OrderBy> for super::Remotes {
            type ArgumentType = Option<super::super::RemoteOrderByInput>;
            const NAME: &'static str = "orderBy";
        }
        pub struct Skip;
        impl ::cynic::schema::HasArgument<Skip> for super::Remotes {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "skip";
        }
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::Remotes {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "after";
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::Remotes {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "before";
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::Remotes {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "first";
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::Remotes {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "last";
        }
    }
    pub struct Description;
    impl ::cynic::schema::Field for Description {
        type Type = Option<super::String>;
        const NAME: &'static str = "description";
    }
    impl ::cynic::schema::HasField<Description> for super::Job {
        type Type = Option<super::String>;
    }
    pub struct ApplyUrl;
    impl ::cynic::schema::Field for ApplyUrl {
        type Type = Option<super::String>;
        const NAME: &'static str = "applyUrl";
    }
    impl ::cynic::schema::HasField<ApplyUrl> for super::Job {
        type Type = Option<super::String>;
    }
    pub struct Company;
    impl ::cynic::schema::Field for Company {
        type Type = Option<super::Company>;
        const NAME: &'static str = "company";
    }
    impl ::cynic::schema::HasField<Company> for super::Job {
        type Type = Option<super::Company>;
    }
    pub struct Tags;
    impl ::cynic::schema::Field for Tags {
        type Type = Option<Vec<super::Tag>>;
        const NAME: &'static str = "tags";
    }
    impl ::cynic::schema::HasField<Tags> for super::Job {
        type Type = Option<Vec<super::Tag>>;
    }
    pub mod tags_arguments {
        pub struct Where;
        impl ::cynic::schema::HasArgument<Where> for super::Tags {
            type ArgumentType = Option<super::super::TagWhereInput>;
            const NAME: &'static str = "where";
        }
        pub struct OrderBy;
        impl ::cynic::schema::HasArgument<OrderBy> for super::Tags {
            type ArgumentType = Option<super::super::TagOrderByInput>;
            const NAME: &'static str = "orderBy";
        }
        pub struct Skip;
        impl ::cynic::schema::HasArgument<Skip> for super::Tags {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "skip";
        }
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::Tags {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "after";
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::Tags {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "before";
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::Tags {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "first";
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::Tags {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "last";
        }
    }
    pub struct IsPublished;
    impl ::cynic::schema::Field for IsPublished {
        type Type = Option<super::Boolean>;
        const NAME: &'static str = "isPublished";
    }
    impl ::cynic::schema::HasField<IsPublished> for super::Job {
        type Type = Option<super::Boolean>;
    }
    pub struct IsFeatured;
    impl ::cynic::schema::Field for IsFeatured {
        type Type = Option<super::Boolean>;
        const NAME: &'static str = "isFeatured";
    }
    impl ::cynic::schema::HasField<IsFeatured> for super::Job {
        type Type = Option<super::Boolean>;
    }
    pub struct LocationNames;
    impl ::cynic::schema::Field for LocationNames {
        type Type = Option<super::String>;
        const NAME: &'static str = "locationNames";
    }
    impl ::cynic::schema::HasField<LocationNames> for super::Job {
        type Type = Option<super::String>;
    }
    pub struct UserEmail;
    impl ::cynic::schema::Field for UserEmail {
        type Type = Option<super::String>;
        const NAME: &'static str = "userEmail";
    }
    impl ::cynic::schema::HasField<UserEmail> for super::Job {
        type Type = Option<super::String>;
    }
    pub struct PostedAt;
    impl ::cynic::schema::Field for PostedAt {
        type Type = super::DateTime;
        const NAME: &'static str = "postedAt";
    }
    impl ::cynic::schema::HasField<PostedAt> for super::Job {
        type Type = super::DateTime;
    }
    pub struct CreatedAt;
    impl ::cynic::schema::Field for CreatedAt {
        type Type = super::DateTime;
        const NAME: &'static str = "createdAt";
    }
    impl ::cynic::schema::HasField<CreatedAt> for super::Job {
        type Type = super::DateTime;
    }
    pub struct UpdatedAt;
    impl ::cynic::schema::Field for UpdatedAt {
        type Type = super::DateTime;
        const NAME: &'static str = "updatedAt";
    }
    impl ::cynic::schema::HasField<UpdatedAt> for super::Job {
        type Type = super::DateTime;
    }
}
pub struct JobInput;
impl ::cynic::schema::InputObjectMarker for JobInput {}
pub mod job_input_fields {
    pub struct CompanySlug;
    impl ::cynic::schema::Field for CompanySlug {
        type Type = super::String;
        const NAME: &'static str = "companySlug";
    }
    impl ::cynic::schema::HasInputField<CompanySlug, super::String> for super::JobInput {}
    pub struct JobSlug;
    impl ::cynic::schema::Field for JobSlug {
        type Type = super::String;
        const NAME: &'static str = "jobSlug";
    }
    impl ::cynic::schema::HasInputField<JobSlug, super::String> for super::JobInput {}
}
pub struct JobOrderByInput {}
pub struct JobWhereInput;
impl ::cynic::schema::InputObjectMarker for JobWhereInput {}
pub mod job_where_input_fields {
    pub struct Id;
    impl ::cynic::schema::Field for Id {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id";
    }
    impl ::cynic::schema::HasInputField<Id, Option<super::Id>> for super::JobWhereInput {}
    pub struct IdNot;
    impl ::cynic::schema::Field for IdNot {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_not";
    }
    impl ::cynic::schema::HasInputField<IdNot, Option<super::Id>> for super::JobWhereInput {}
    pub struct IdIn;
    impl ::cynic::schema::Field for IdIn {
        type Type = Option<Vec<super::Id>>;
        const NAME: &'static str = "id_in";
    }
    impl ::cynic::schema::HasInputField<IdIn, Option<Vec<super::Id>>> for super::JobWhereInput {}
    pub struct IdNotIn;
    impl ::cynic::schema::Field for IdNotIn {
        type Type = Option<Vec<super::Id>>;
        const NAME: &'static str = "id_not_in";
    }
    impl ::cynic::schema::HasInputField<IdNotIn, Option<Vec<super::Id>>> for super::JobWhereInput {}
    pub struct IdLt;
    impl ::cynic::schema::Field for IdLt {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_lt";
    }
    impl ::cynic::schema::HasInputField<IdLt, Option<super::Id>> for super::JobWhereInput {}
    pub struct IdLte;
    impl ::cynic::schema::Field for IdLte {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_lte";
    }
    impl ::cynic::schema::HasInputField<IdLte, Option<super::Id>> for super::JobWhereInput {}
    pub struct IdGt;
    impl ::cynic::schema::Field for IdGt {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_gt";
    }
    impl ::cynic::schema::HasInputField<IdGt, Option<super::Id>> for super::JobWhereInput {}
    pub struct IdGte;
    impl ::cynic::schema::Field for IdGte {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_gte";
    }
    impl ::cynic::schema::HasInputField<IdGte, Option<super::Id>> for super::JobWhereInput {}
    pub struct IdContains;
    impl ::cynic::schema::Field for IdContains {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_contains";
    }
    impl ::cynic::schema::HasInputField<IdContains, Option<super::Id>> for super::JobWhereInput {}
    pub struct IdNotContains;
    impl ::cynic::schema::Field for IdNotContains {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_not_contains";
    }
    impl ::cynic::schema::HasInputField<IdNotContains, Option<super::Id>> for super::JobWhereInput {}
    pub struct IdStartsWith;
    impl ::cynic::schema::Field for IdStartsWith {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_starts_with";
    }
    impl ::cynic::schema::HasInputField<IdStartsWith, Option<super::Id>> for super::JobWhereInput {}
    pub struct IdNotStartsWith;
    impl ::cynic::schema::Field for IdNotStartsWith {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_not_starts_with";
    }
    impl ::cynic::schema::HasInputField<IdNotStartsWith, Option<super::Id>> for super::JobWhereInput {}
    pub struct IdEndsWith;
    impl ::cynic::schema::Field for IdEndsWith {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_ends_with";
    }
    impl ::cynic::schema::HasInputField<IdEndsWith, Option<super::Id>> for super::JobWhereInput {}
    pub struct IdNotEndsWith;
    impl ::cynic::schema::Field for IdNotEndsWith {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_not_ends_with";
    }
    impl ::cynic::schema::HasInputField<IdNotEndsWith, Option<super::Id>> for super::JobWhereInput {}
    pub struct Title;
    impl ::cynic::schema::Field for Title {
        type Type = Option<super::String>;
        const NAME: &'static str = "title";
    }
    impl ::cynic::schema::HasInputField<Title, Option<super::String>> for super::JobWhereInput {}
    pub struct TitleNot;
    impl ::cynic::schema::Field for TitleNot {
        type Type = Option<super::String>;
        const NAME: &'static str = "title_not";
    }
    impl ::cynic::schema::HasInputField<TitleNot, Option<super::String>> for super::JobWhereInput {}
    pub struct TitleIn;
    impl ::cynic::schema::Field for TitleIn {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "title_in";
    }
    impl ::cynic::schema::HasInputField<TitleIn, Option<Vec<super::String>>> for super::JobWhereInput {}
    pub struct TitleNotIn;
    impl ::cynic::schema::Field for TitleNotIn {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "title_not_in";
    }
    impl ::cynic::schema::HasInputField<TitleNotIn, Option<Vec<super::String>>>
        for super::JobWhereInput
    {
    }
    pub struct TitleLt;
    impl ::cynic::schema::Field for TitleLt {
        type Type = Option<super::String>;
        const NAME: &'static str = "title_lt";
    }
    impl ::cynic::schema::HasInputField<TitleLt, Option<super::String>> for super::JobWhereInput {}
    pub struct TitleLte;
    impl ::cynic::schema::Field for TitleLte {
        type Type = Option<super::String>;
        const NAME: &'static str = "title_lte";
    }
    impl ::cynic::schema::HasInputField<TitleLte, Option<super::String>> for super::JobWhereInput {}
    pub struct TitleGt;
    impl ::cynic::schema::Field for TitleGt {
        type Type = Option<super::String>;
        const NAME: &'static str = "title_gt";
    }
    impl ::cynic::schema::HasInputField<TitleGt, Option<super::String>> for super::JobWhereInput {}
    pub struct TitleGte;
    impl ::cynic::schema::Field for TitleGte {
        type Type = Option<super::String>;
        const NAME: &'static str = "title_gte";
    }
    impl ::cynic::schema::HasInputField<TitleGte, Option<super::String>> for super::JobWhereInput {}
    pub struct TitleContains;
    impl ::cynic::schema::Field for TitleContains {
        type Type = Option<super::String>;
        const NAME: &'static str = "title_contains";
    }
    impl ::cynic::schema::HasInputField<TitleContains, Option<super::String>> for super::JobWhereInput {}
    pub struct TitleNotContains;
    impl ::cynic::schema::Field for TitleNotContains {
        type Type = Option<super::String>;
        const NAME: &'static str = "title_not_contains";
    }
    impl ::cynic::schema::HasInputField<TitleNotContains, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct TitleStartsWith;
    impl ::cynic::schema::Field for TitleStartsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "title_starts_with";
    }
    impl ::cynic::schema::HasInputField<TitleStartsWith, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct TitleNotStartsWith;
    impl ::cynic::schema::Field for TitleNotStartsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "title_not_starts_with";
    }
    impl ::cynic::schema::HasInputField<TitleNotStartsWith, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct TitleEndsWith;
    impl ::cynic::schema::Field for TitleEndsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "title_ends_with";
    }
    impl ::cynic::schema::HasInputField<TitleEndsWith, Option<super::String>> for super::JobWhereInput {}
    pub struct TitleNotEndsWith;
    impl ::cynic::schema::Field for TitleNotEndsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "title_not_ends_with";
    }
    impl ::cynic::schema::HasInputField<TitleNotEndsWith, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct Slug;
    impl ::cynic::schema::Field for Slug {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug";
    }
    impl ::cynic::schema::HasInputField<Slug, Option<super::String>> for super::JobWhereInput {}
    pub struct SlugNot;
    impl ::cynic::schema::Field for SlugNot {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_not";
    }
    impl ::cynic::schema::HasInputField<SlugNot, Option<super::String>> for super::JobWhereInput {}
    pub struct SlugIn;
    impl ::cynic::schema::Field for SlugIn {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "slug_in";
    }
    impl ::cynic::schema::HasInputField<SlugIn, Option<Vec<super::String>>> for super::JobWhereInput {}
    pub struct SlugNotIn;
    impl ::cynic::schema::Field for SlugNotIn {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "slug_not_in";
    }
    impl ::cynic::schema::HasInputField<SlugNotIn, Option<Vec<super::String>>>
        for super::JobWhereInput
    {
    }
    pub struct SlugLt;
    impl ::cynic::schema::Field for SlugLt {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_lt";
    }
    impl ::cynic::schema::HasInputField<SlugLt, Option<super::String>> for super::JobWhereInput {}
    pub struct SlugLte;
    impl ::cynic::schema::Field for SlugLte {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_lte";
    }
    impl ::cynic::schema::HasInputField<SlugLte, Option<super::String>> for super::JobWhereInput {}
    pub struct SlugGt;
    impl ::cynic::schema::Field for SlugGt {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_gt";
    }
    impl ::cynic::schema::HasInputField<SlugGt, Option<super::String>> for super::JobWhereInput {}
    pub struct SlugGte;
    impl ::cynic::schema::Field for SlugGte {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_gte";
    }
    impl ::cynic::schema::HasInputField<SlugGte, Option<super::String>> for super::JobWhereInput {}
    pub struct SlugContains;
    impl ::cynic::schema::Field for SlugContains {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_contains";
    }
    impl ::cynic::schema::HasInputField<SlugContains, Option<super::String>> for super::JobWhereInput {}
    pub struct SlugNotContains;
    impl ::cynic::schema::Field for SlugNotContains {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_not_contains";
    }
    impl ::cynic::schema::HasInputField<SlugNotContains, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct SlugStartsWith;
    impl ::cynic::schema::Field for SlugStartsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_starts_with";
    }
    impl ::cynic::schema::HasInputField<SlugStartsWith, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct SlugNotStartsWith;
    impl ::cynic::schema::Field for SlugNotStartsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_not_starts_with";
    }
    impl ::cynic::schema::HasInputField<SlugNotStartsWith, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct SlugEndsWith;
    impl ::cynic::schema::Field for SlugEndsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_ends_with";
    }
    impl ::cynic::schema::HasInputField<SlugEndsWith, Option<super::String>> for super::JobWhereInput {}
    pub struct SlugNotEndsWith;
    impl ::cynic::schema::Field for SlugNotEndsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_not_ends_with";
    }
    impl ::cynic::schema::HasInputField<SlugNotEndsWith, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct Commitment;
    impl ::cynic::schema::Field for Commitment {
        type Type = Option<super::CommitmentWhereInput>;
        const NAME: &'static str = "commitment";
    }
    impl ::cynic::schema::HasInputField<Commitment, Option<super::CommitmentWhereInput>>
        for super::JobWhereInput
    {
    }
    pub struct CitiesEvery;
    impl ::cynic::schema::Field for CitiesEvery {
        type Type = Option<super::CityWhereInput>;
        const NAME: &'static str = "cities_every";
    }
    impl ::cynic::schema::HasInputField<CitiesEvery, Option<super::CityWhereInput>>
        for super::JobWhereInput
    {
    }
    pub struct CitiesSome;
    impl ::cynic::schema::Field for CitiesSome {
        type Type = Option<super::CityWhereInput>;
        const NAME: &'static str = "cities_some";
    }
    impl ::cynic::schema::HasInputField<CitiesSome, Option<super::CityWhereInput>>
        for super::JobWhereInput
    {
    }
    pub struct CitiesNone;
    impl ::cynic::schema::Field for CitiesNone {
        type Type = Option<super::CityWhereInput>;
        const NAME: &'static str = "cities_none";
    }
    impl ::cynic::schema::HasInputField<CitiesNone, Option<super::CityWhereInput>>
        for super::JobWhereInput
    {
    }
    pub struct CountriesEvery;
    impl ::cynic::schema::Field for CountriesEvery {
        type Type = Option<super::CountryWhereInput>;
        const NAME: &'static str = "countries_every";
    }
    impl ::cynic::schema::HasInputField<CountriesEvery, Option<super::CountryWhereInput>>
        for super::JobWhereInput
    {
    }
    pub struct CountriesSome;
    impl ::cynic::schema::Field for CountriesSome {
        type Type = Option<super::CountryWhereInput>;
        const NAME: &'static str = "countries_some";
    }
    impl ::cynic::schema::HasInputField<CountriesSome, Option<super::CountryWhereInput>>
        for super::JobWhereInput
    {
    }
    pub struct CountriesNone;
    impl ::cynic::schema::Field for CountriesNone {
        type Type = Option<super::CountryWhereInput>;
        const NAME: &'static str = "countries_none";
    }
    impl ::cynic::schema::HasInputField<CountriesNone, Option<super::CountryWhereInput>>
        for super::JobWhereInput
    {
    }
    pub struct RemotesEvery;
    impl ::cynic::schema::Field for RemotesEvery {
        type Type = Option<super::RemoteWhereInput>;
        const NAME: &'static str = "remotes_every";
    }
    impl ::cynic::schema::HasInputField<RemotesEvery, Option<super::RemoteWhereInput>>
        for super::JobWhereInput
    {
    }
    pub struct RemotesSome;
    impl ::cynic::schema::Field for RemotesSome {
        type Type = Option<super::RemoteWhereInput>;
        const NAME: &'static str = "remotes_some";
    }
    impl ::cynic::schema::HasInputField<RemotesSome, Option<super::RemoteWhereInput>>
        for super::JobWhereInput
    {
    }
    pub struct RemotesNone;
    impl ::cynic::schema::Field for RemotesNone {
        type Type = Option<super::RemoteWhereInput>;
        const NAME: &'static str = "remotes_none";
    }
    impl ::cynic::schema::HasInputField<RemotesNone, Option<super::RemoteWhereInput>>
        for super::JobWhereInput
    {
    }
    pub struct Description;
    impl ::cynic::schema::Field for Description {
        type Type = Option<super::String>;
        const NAME: &'static str = "description";
    }
    impl ::cynic::schema::HasInputField<Description, Option<super::String>> for super::JobWhereInput {}
    pub struct DescriptionNot;
    impl ::cynic::schema::Field for DescriptionNot {
        type Type = Option<super::String>;
        const NAME: &'static str = "description_not";
    }
    impl ::cynic::schema::HasInputField<DescriptionNot, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct DescriptionIn;
    impl ::cynic::schema::Field for DescriptionIn {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "description_in";
    }
    impl ::cynic::schema::HasInputField<DescriptionIn, Option<Vec<super::String>>>
        for super::JobWhereInput
    {
    }
    pub struct DescriptionNotIn;
    impl ::cynic::schema::Field for DescriptionNotIn {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "description_not_in";
    }
    impl ::cynic::schema::HasInputField<DescriptionNotIn, Option<Vec<super::String>>>
        for super::JobWhereInput
    {
    }
    pub struct DescriptionLt;
    impl ::cynic::schema::Field for DescriptionLt {
        type Type = Option<super::String>;
        const NAME: &'static str = "description_lt";
    }
    impl ::cynic::schema::HasInputField<DescriptionLt, Option<super::String>> for super::JobWhereInput {}
    pub struct DescriptionLte;
    impl ::cynic::schema::Field for DescriptionLte {
        type Type = Option<super::String>;
        const NAME: &'static str = "description_lte";
    }
    impl ::cynic::schema::HasInputField<DescriptionLte, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct DescriptionGt;
    impl ::cynic::schema::Field for DescriptionGt {
        type Type = Option<super::String>;
        const NAME: &'static str = "description_gt";
    }
    impl ::cynic::schema::HasInputField<DescriptionGt, Option<super::String>> for super::JobWhereInput {}
    pub struct DescriptionGte;
    impl ::cynic::schema::Field for DescriptionGte {
        type Type = Option<super::String>;
        const NAME: &'static str = "description_gte";
    }
    impl ::cynic::schema::HasInputField<DescriptionGte, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct DescriptionContains;
    impl ::cynic::schema::Field for DescriptionContains {
        type Type = Option<super::String>;
        const NAME: &'static str = "description_contains";
    }
    impl ::cynic::schema::HasInputField<DescriptionContains, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct DescriptionNotContains;
    impl ::cynic::schema::Field for DescriptionNotContains {
        type Type = Option<super::String>;
        const NAME: &'static str = "description_not_contains";
    }
    impl ::cynic::schema::HasInputField<DescriptionNotContains, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct DescriptionStartsWith;
    impl ::cynic::schema::Field for DescriptionStartsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "description_starts_with";
    }
    impl ::cynic::schema::HasInputField<DescriptionStartsWith, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct DescriptionNotStartsWith;
    impl ::cynic::schema::Field for DescriptionNotStartsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "description_not_starts_with";
    }
    impl ::cynic::schema::HasInputField<DescriptionNotStartsWith, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct DescriptionEndsWith;
    impl ::cynic::schema::Field for DescriptionEndsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "description_ends_with";
    }
    impl ::cynic::schema::HasInputField<DescriptionEndsWith, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct DescriptionNotEndsWith;
    impl ::cynic::schema::Field for DescriptionNotEndsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "description_not_ends_with";
    }
    impl ::cynic::schema::HasInputField<DescriptionNotEndsWith, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct ApplyUrl;
    impl ::cynic::schema::Field for ApplyUrl {
        type Type = Option<super::String>;
        const NAME: &'static str = "applyUrl";
    }
    impl ::cynic::schema::HasInputField<ApplyUrl, Option<super::String>> for super::JobWhereInput {}
    pub struct ApplyUrlNot;
    impl ::cynic::schema::Field for ApplyUrlNot {
        type Type = Option<super::String>;
        const NAME: &'static str = "applyUrl_not";
    }
    impl ::cynic::schema::HasInputField<ApplyUrlNot, Option<super::String>> for super::JobWhereInput {}
    pub struct ApplyUrlIn;
    impl ::cynic::schema::Field for ApplyUrlIn {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "applyUrl_in";
    }
    impl ::cynic::schema::HasInputField<ApplyUrlIn, Option<Vec<super::String>>>
        for super::JobWhereInput
    {
    }
    pub struct ApplyUrlNotIn;
    impl ::cynic::schema::Field for ApplyUrlNotIn {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "applyUrl_not_in";
    }
    impl ::cynic::schema::HasInputField<ApplyUrlNotIn, Option<Vec<super::String>>>
        for super::JobWhereInput
    {
    }
    pub struct ApplyUrlLt;
    impl ::cynic::schema::Field for ApplyUrlLt {
        type Type = Option<super::String>;
        const NAME: &'static str = "applyUrl_lt";
    }
    impl ::cynic::schema::HasInputField<ApplyUrlLt, Option<super::String>> for super::JobWhereInput {}
    pub struct ApplyUrlLte;
    impl ::cynic::schema::Field for ApplyUrlLte {
        type Type = Option<super::String>;
        const NAME: &'static str = "applyUrl_lte";
    }
    impl ::cynic::schema::HasInputField<ApplyUrlLte, Option<super::String>> for super::JobWhereInput {}
    pub struct ApplyUrlGt;
    impl ::cynic::schema::Field for ApplyUrlGt {
        type Type = Option<super::String>;
        const NAME: &'static str = "applyUrl_gt";
    }
    impl ::cynic::schema::HasInputField<ApplyUrlGt, Option<super::String>> for super::JobWhereInput {}
    pub struct ApplyUrlGte;
    impl ::cynic::schema::Field for ApplyUrlGte {
        type Type = Option<super::String>;
        const NAME: &'static str = "applyUrl_gte";
    }
    impl ::cynic::schema::HasInputField<ApplyUrlGte, Option<super::String>> for super::JobWhereInput {}
    pub struct ApplyUrlContains;
    impl ::cynic::schema::Field for ApplyUrlContains {
        type Type = Option<super::String>;
        const NAME: &'static str = "applyUrl_contains";
    }
    impl ::cynic::schema::HasInputField<ApplyUrlContains, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct ApplyUrlNotContains;
    impl ::cynic::schema::Field for ApplyUrlNotContains {
        type Type = Option<super::String>;
        const NAME: &'static str = "applyUrl_not_contains";
    }
    impl ::cynic::schema::HasInputField<ApplyUrlNotContains, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct ApplyUrlStartsWith;
    impl ::cynic::schema::Field for ApplyUrlStartsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "applyUrl_starts_with";
    }
    impl ::cynic::schema::HasInputField<ApplyUrlStartsWith, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct ApplyUrlNotStartsWith;
    impl ::cynic::schema::Field for ApplyUrlNotStartsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "applyUrl_not_starts_with";
    }
    impl ::cynic::schema::HasInputField<ApplyUrlNotStartsWith, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct ApplyUrlEndsWith;
    impl ::cynic::schema::Field for ApplyUrlEndsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "applyUrl_ends_with";
    }
    impl ::cynic::schema::HasInputField<ApplyUrlEndsWith, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct ApplyUrlNotEndsWith;
    impl ::cynic::schema::Field for ApplyUrlNotEndsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "applyUrl_not_ends_with";
    }
    impl ::cynic::schema::HasInputField<ApplyUrlNotEndsWith, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct Company;
    impl ::cynic::schema::Field for Company {
        type Type = Option<super::CompanyWhereInput>;
        const NAME: &'static str = "company";
    }
    impl ::cynic::schema::HasInputField<Company, Option<super::CompanyWhereInput>>
        for super::JobWhereInput
    {
    }
    pub struct TagsEvery;
    impl ::cynic::schema::Field for TagsEvery {
        type Type = Option<super::TagWhereInput>;
        const NAME: &'static str = "tags_every";
    }
    impl ::cynic::schema::HasInputField<TagsEvery, Option<super::TagWhereInput>>
        for super::JobWhereInput
    {
    }
    pub struct TagsSome;
    impl ::cynic::schema::Field for TagsSome {
        type Type = Option<super::TagWhereInput>;
        const NAME: &'static str = "tags_some";
    }
    impl ::cynic::schema::HasInputField<TagsSome, Option<super::TagWhereInput>>
        for super::JobWhereInput
    {
    }
    pub struct TagsNone;
    impl ::cynic::schema::Field for TagsNone {
        type Type = Option<super::TagWhereInput>;
        const NAME: &'static str = "tags_none";
    }
    impl ::cynic::schema::HasInputField<TagsNone, Option<super::TagWhereInput>>
        for super::JobWhereInput
    {
    }
    pub struct IsPublished;
    impl ::cynic::schema::Field for IsPublished {
        type Type = Option<super::Boolean>;
        const NAME: &'static str = "isPublished";
    }
    impl ::cynic::schema::HasInputField<IsPublished, Option<super::Boolean>> for super::JobWhereInput {}
    pub struct IsPublishedNot;
    impl ::cynic::schema::Field for IsPublishedNot {
        type Type = Option<super::Boolean>;
        const NAME: &'static str = "isPublished_not";
    }
    impl ::cynic::schema::HasInputField<IsPublishedNot, Option<super::Boolean>>
        for super::JobWhereInput
    {
    }
    pub struct IsFeatured;
    impl ::cynic::schema::Field for IsFeatured {
        type Type = Option<super::Boolean>;
        const NAME: &'static str = "isFeatured";
    }
    impl ::cynic::schema::HasInputField<IsFeatured, Option<super::Boolean>> for super::JobWhereInput {}
    pub struct IsFeaturedNot;
    impl ::cynic::schema::Field for IsFeaturedNot {
        type Type = Option<super::Boolean>;
        const NAME: &'static str = "isFeatured_not";
    }
    impl ::cynic::schema::HasInputField<IsFeaturedNot, Option<super::Boolean>>
        for super::JobWhereInput
    {
    }
    pub struct LocationNames;
    impl ::cynic::schema::Field for LocationNames {
        type Type = Option<super::String>;
        const NAME: &'static str = "locationNames";
    }
    impl ::cynic::schema::HasInputField<LocationNames, Option<super::String>> for super::JobWhereInput {}
    pub struct LocationNamesNot;
    impl ::cynic::schema::Field for LocationNamesNot {
        type Type = Option<super::String>;
        const NAME: &'static str = "locationNames_not";
    }
    impl ::cynic::schema::HasInputField<LocationNamesNot, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct LocationNamesIn;
    impl ::cynic::schema::Field for LocationNamesIn {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "locationNames_in";
    }
    impl ::cynic::schema::HasInputField<LocationNamesIn, Option<Vec<super::String>>>
        for super::JobWhereInput
    {
    }
    pub struct LocationNamesNotIn;
    impl ::cynic::schema::Field for LocationNamesNotIn {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "locationNames_not_in";
    }
    impl ::cynic::schema::HasInputField<LocationNamesNotIn, Option<Vec<super::String>>>
        for super::JobWhereInput
    {
    }
    pub struct LocationNamesLt;
    impl ::cynic::schema::Field for LocationNamesLt {
        type Type = Option<super::String>;
        const NAME: &'static str = "locationNames_lt";
    }
    impl ::cynic::schema::HasInputField<LocationNamesLt, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct LocationNamesLte;
    impl ::cynic::schema::Field for LocationNamesLte {
        type Type = Option<super::String>;
        const NAME: &'static str = "locationNames_lte";
    }
    impl ::cynic::schema::HasInputField<LocationNamesLte, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct LocationNamesGt;
    impl ::cynic::schema::Field for LocationNamesGt {
        type Type = Option<super::String>;
        const NAME: &'static str = "locationNames_gt";
    }
    impl ::cynic::schema::HasInputField<LocationNamesGt, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct LocationNamesGte;
    impl ::cynic::schema::Field for LocationNamesGte {
        type Type = Option<super::String>;
        const NAME: &'static str = "locationNames_gte";
    }
    impl ::cynic::schema::HasInputField<LocationNamesGte, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct LocationNamesContains;
    impl ::cynic::schema::Field for LocationNamesContains {
        type Type = Option<super::String>;
        const NAME: &'static str = "locationNames_contains";
    }
    impl ::cynic::schema::HasInputField<LocationNamesContains, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct LocationNamesNotContains;
    impl ::cynic::schema::Field for LocationNamesNotContains {
        type Type = Option<super::String>;
        const NAME: &'static str = "locationNames_not_contains";
    }
    impl ::cynic::schema::HasInputField<LocationNamesNotContains, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct LocationNamesStartsWith;
    impl ::cynic::schema::Field for LocationNamesStartsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "locationNames_starts_with";
    }
    impl ::cynic::schema::HasInputField<LocationNamesStartsWith, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct LocationNamesNotStartsWith;
    impl ::cynic::schema::Field for LocationNamesNotStartsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "locationNames_not_starts_with";
    }
    impl ::cynic::schema::HasInputField<LocationNamesNotStartsWith, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct LocationNamesEndsWith;
    impl ::cynic::schema::Field for LocationNamesEndsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "locationNames_ends_with";
    }
    impl ::cynic::schema::HasInputField<LocationNamesEndsWith, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct LocationNamesNotEndsWith;
    impl ::cynic::schema::Field for LocationNamesNotEndsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "locationNames_not_ends_with";
    }
    impl ::cynic::schema::HasInputField<LocationNamesNotEndsWith, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct UserEmail;
    impl ::cynic::schema::Field for UserEmail {
        type Type = Option<super::String>;
        const NAME: &'static str = "userEmail";
    }
    impl ::cynic::schema::HasInputField<UserEmail, Option<super::String>> for super::JobWhereInput {}
    pub struct UserEmailNot;
    impl ::cynic::schema::Field for UserEmailNot {
        type Type = Option<super::String>;
        const NAME: &'static str = "userEmail_not";
    }
    impl ::cynic::schema::HasInputField<UserEmailNot, Option<super::String>> for super::JobWhereInput {}
    pub struct UserEmailIn;
    impl ::cynic::schema::Field for UserEmailIn {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "userEmail_in";
    }
    impl ::cynic::schema::HasInputField<UserEmailIn, Option<Vec<super::String>>>
        for super::JobWhereInput
    {
    }
    pub struct UserEmailNotIn;
    impl ::cynic::schema::Field for UserEmailNotIn {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "userEmail_not_in";
    }
    impl ::cynic::schema::HasInputField<UserEmailNotIn, Option<Vec<super::String>>>
        for super::JobWhereInput
    {
    }
    pub struct UserEmailLt;
    impl ::cynic::schema::Field for UserEmailLt {
        type Type = Option<super::String>;
        const NAME: &'static str = "userEmail_lt";
    }
    impl ::cynic::schema::HasInputField<UserEmailLt, Option<super::String>> for super::JobWhereInput {}
    pub struct UserEmailLte;
    impl ::cynic::schema::Field for UserEmailLte {
        type Type = Option<super::String>;
        const NAME: &'static str = "userEmail_lte";
    }
    impl ::cynic::schema::HasInputField<UserEmailLte, Option<super::String>> for super::JobWhereInput {}
    pub struct UserEmailGt;
    impl ::cynic::schema::Field for UserEmailGt {
        type Type = Option<super::String>;
        const NAME: &'static str = "userEmail_gt";
    }
    impl ::cynic::schema::HasInputField<UserEmailGt, Option<super::String>> for super::JobWhereInput {}
    pub struct UserEmailGte;
    impl ::cynic::schema::Field for UserEmailGte {
        type Type = Option<super::String>;
        const NAME: &'static str = "userEmail_gte";
    }
    impl ::cynic::schema::HasInputField<UserEmailGte, Option<super::String>> for super::JobWhereInput {}
    pub struct UserEmailContains;
    impl ::cynic::schema::Field for UserEmailContains {
        type Type = Option<super::String>;
        const NAME: &'static str = "userEmail_contains";
    }
    impl ::cynic::schema::HasInputField<UserEmailContains, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct UserEmailNotContains;
    impl ::cynic::schema::Field for UserEmailNotContains {
        type Type = Option<super::String>;
        const NAME: &'static str = "userEmail_not_contains";
    }
    impl ::cynic::schema::HasInputField<UserEmailNotContains, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct UserEmailStartsWith;
    impl ::cynic::schema::Field for UserEmailStartsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "userEmail_starts_with";
    }
    impl ::cynic::schema::HasInputField<UserEmailStartsWith, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct UserEmailNotStartsWith;
    impl ::cynic::schema::Field for UserEmailNotStartsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "userEmail_not_starts_with";
    }
    impl ::cynic::schema::HasInputField<UserEmailNotStartsWith, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct UserEmailEndsWith;
    impl ::cynic::schema::Field for UserEmailEndsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "userEmail_ends_with";
    }
    impl ::cynic::schema::HasInputField<UserEmailEndsWith, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct UserEmailNotEndsWith;
    impl ::cynic::schema::Field for UserEmailNotEndsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "userEmail_not_ends_with";
    }
    impl ::cynic::schema::HasInputField<UserEmailNotEndsWith, Option<super::String>>
        for super::JobWhereInput
    {
    }
    pub struct PostedAt;
    impl ::cynic::schema::Field for PostedAt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "postedAt";
    }
    impl ::cynic::schema::HasInputField<PostedAt, Option<super::DateTime>> for super::JobWhereInput {}
    pub struct PostedAtNot;
    impl ::cynic::schema::Field for PostedAtNot {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "postedAt_not";
    }
    impl ::cynic::schema::HasInputField<PostedAtNot, Option<super::DateTime>> for super::JobWhereInput {}
    pub struct PostedAtIn;
    impl ::cynic::schema::Field for PostedAtIn {
        type Type = Option<Vec<super::DateTime>>;
        const NAME: &'static str = "postedAt_in";
    }
    impl ::cynic::schema::HasInputField<PostedAtIn, Option<Vec<super::DateTime>>>
        for super::JobWhereInput
    {
    }
    pub struct PostedAtNotIn;
    impl ::cynic::schema::Field for PostedAtNotIn {
        type Type = Option<Vec<super::DateTime>>;
        const NAME: &'static str = "postedAt_not_in";
    }
    impl ::cynic::schema::HasInputField<PostedAtNotIn, Option<Vec<super::DateTime>>>
        for super::JobWhereInput
    {
    }
    pub struct PostedAtLt;
    impl ::cynic::schema::Field for PostedAtLt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "postedAt_lt";
    }
    impl ::cynic::schema::HasInputField<PostedAtLt, Option<super::DateTime>> for super::JobWhereInput {}
    pub struct PostedAtLte;
    impl ::cynic::schema::Field for PostedAtLte {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "postedAt_lte";
    }
    impl ::cynic::schema::HasInputField<PostedAtLte, Option<super::DateTime>> for super::JobWhereInput {}
    pub struct PostedAtGt;
    impl ::cynic::schema::Field for PostedAtGt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "postedAt_gt";
    }
    impl ::cynic::schema::HasInputField<PostedAtGt, Option<super::DateTime>> for super::JobWhereInput {}
    pub struct PostedAtGte;
    impl ::cynic::schema::Field for PostedAtGte {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "postedAt_gte";
    }
    impl ::cynic::schema::HasInputField<PostedAtGte, Option<super::DateTime>> for super::JobWhereInput {}
    pub struct CreatedAt;
    impl ::cynic::schema::Field for CreatedAt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt";
    }
    impl ::cynic::schema::HasInputField<CreatedAt, Option<super::DateTime>> for super::JobWhereInput {}
    pub struct CreatedAtNot;
    impl ::cynic::schema::Field for CreatedAtNot {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt_not";
    }
    impl ::cynic::schema::HasInputField<CreatedAtNot, Option<super::DateTime>>
        for super::JobWhereInput
    {
    }
    pub struct CreatedAtIn;
    impl ::cynic::schema::Field for CreatedAtIn {
        type Type = Option<Vec<super::DateTime>>;
        const NAME: &'static str = "createdAt_in";
    }
    impl ::cynic::schema::HasInputField<CreatedAtIn, Option<Vec<super::DateTime>>>
        for super::JobWhereInput
    {
    }
    pub struct CreatedAtNotIn;
    impl ::cynic::schema::Field for CreatedAtNotIn {
        type Type = Option<Vec<super::DateTime>>;
        const NAME: &'static str = "createdAt_not_in";
    }
    impl ::cynic::schema::HasInputField<CreatedAtNotIn, Option<Vec<super::DateTime>>>
        for super::JobWhereInput
    {
    }
    pub struct CreatedAtLt;
    impl ::cynic::schema::Field for CreatedAtLt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt_lt";
    }
    impl ::cynic::schema::HasInputField<CreatedAtLt, Option<super::DateTime>> for super::JobWhereInput {}
    pub struct CreatedAtLte;
    impl ::cynic::schema::Field for CreatedAtLte {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt_lte";
    }
    impl ::cynic::schema::HasInputField<CreatedAtLte, Option<super::DateTime>>
        for super::JobWhereInput
    {
    }
    pub struct CreatedAtGt;
    impl ::cynic::schema::Field for CreatedAtGt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt_gt";
    }
    impl ::cynic::schema::HasInputField<CreatedAtGt, Option<super::DateTime>> for super::JobWhereInput {}
    pub struct CreatedAtGte;
    impl ::cynic::schema::Field for CreatedAtGte {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt_gte";
    }
    impl ::cynic::schema::HasInputField<CreatedAtGte, Option<super::DateTime>>
        for super::JobWhereInput
    {
    }
    pub struct UpdatedAt;
    impl ::cynic::schema::Field for UpdatedAt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt";
    }
    impl ::cynic::schema::HasInputField<UpdatedAt, Option<super::DateTime>> for super::JobWhereInput {}
    pub struct UpdatedAtNot;
    impl ::cynic::schema::Field for UpdatedAtNot {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt_not";
    }
    impl ::cynic::schema::HasInputField<UpdatedAtNot, Option<super::DateTime>>
        for super::JobWhereInput
    {
    }
    pub struct UpdatedAtIn;
    impl ::cynic::schema::Field for UpdatedAtIn {
        type Type = Option<Vec<super::DateTime>>;
        const NAME: &'static str = "updatedAt_in";
    }
    impl ::cynic::schema::HasInputField<UpdatedAtIn, Option<Vec<super::DateTime>>>
        for super::JobWhereInput
    {
    }
    pub struct UpdatedAtNotIn;
    impl ::cynic::schema::Field for UpdatedAtNotIn {
        type Type = Option<Vec<super::DateTime>>;
        const NAME: &'static str = "updatedAt_not_in";
    }
    impl ::cynic::schema::HasInputField<UpdatedAtNotIn, Option<Vec<super::DateTime>>>
        for super::JobWhereInput
    {
    }
    pub struct UpdatedAtLt;
    impl ::cynic::schema::Field for UpdatedAtLt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt_lt";
    }
    impl ::cynic::schema::HasInputField<UpdatedAtLt, Option<super::DateTime>> for super::JobWhereInput {}
    pub struct UpdatedAtLte;
    impl ::cynic::schema::Field for UpdatedAtLte {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt_lte";
    }
    impl ::cynic::schema::HasInputField<UpdatedAtLte, Option<super::DateTime>>
        for super::JobWhereInput
    {
    }
    pub struct UpdatedAtGt;
    impl ::cynic::schema::Field for UpdatedAtGt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt_gt";
    }
    impl ::cynic::schema::HasInputField<UpdatedAtGt, Option<super::DateTime>> for super::JobWhereInput {}
    pub struct UpdatedAtGte;
    impl ::cynic::schema::Field for UpdatedAtGte {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt_gte";
    }
    impl ::cynic::schema::HasInputField<UpdatedAtGte, Option<super::DateTime>>
        for super::JobWhereInput
    {
    }
    pub struct And;
    impl ::cynic::schema::Field for And {
        type Type = Option<Vec<super::JobWhereInput>>;
        const NAME: &'static str = "AND";
    }
    impl ::cynic::schema::HasInputField<And, Option<Vec<super::JobWhereInput>>>
        for super::JobWhereInput
    {
    }
    pub struct Or;
    impl ::cynic::schema::Field for Or {
        type Type = Option<Vec<super::JobWhereInput>>;
        const NAME: &'static str = "OR";
    }
    impl ::cynic::schema::HasInputField<Or, Option<Vec<super::JobWhereInput>>>
        for super::JobWhereInput
    {
    }
    pub struct Not;
    impl ::cynic::schema::Field for Not {
        type Type = Option<Vec<super::JobWhereInput>>;
        const NAME: &'static str = "NOT";
    }
    impl ::cynic::schema::HasInputField<Not, Option<Vec<super::JobWhereInput>>>
        for super::JobWhereInput
    {
    }
}
pub struct JobsInput;
impl ::cynic::schema::InputObjectMarker for JobsInput {}
pub mod jobs_input_fields {
    pub struct Type;
    impl ::cynic::schema::Field for Type {
        type Type = Option<super::String>;
        const NAME: &'static str = "type";
    }
    impl ::cynic::schema::HasInputField<Type, Option<super::String>> for super::JobsInput {}
    pub struct Slug;
    impl ::cynic::schema::Field for Slug {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug";
    }
    impl ::cynic::schema::HasInputField<Slug, Option<super::String>> for super::JobsInput {}
}
pub struct Location;
pub mod location_fields {
    pub struct Id;
    impl ::cynic::schema::Field for Id {
        type Type = super::Id;
        const NAME: &'static str = "id";
    }
    impl ::cynic::schema::HasField<Id> for super::Location {
        type Type = super::Id;
    }
    pub struct Slug;
    impl ::cynic::schema::Field for Slug {
        type Type = super::String;
        const NAME: &'static str = "slug";
    }
    impl ::cynic::schema::HasField<Slug> for super::Location {
        type Type = super::String;
    }
    pub struct Name;
    impl ::cynic::schema::Field for Name {
        type Type = super::String;
        const NAME: &'static str = "name";
    }
    impl ::cynic::schema::HasField<Name> for super::Location {
        type Type = super::String;
    }
    pub struct Type;
    impl ::cynic::schema::Field for Type {
        type Type = super::String;
        const NAME: &'static str = "type";
    }
    impl ::cynic::schema::HasField<Type> for super::Location {
        type Type = super::String;
    }
}
pub struct LocationInput;
impl ::cynic::schema::InputObjectMarker for LocationInput {}
pub mod location_input_fields {
    pub struct Slug;
    impl ::cynic::schema::Field for Slug {
        type Type = super::String;
        const NAME: &'static str = "slug";
    }
    impl ::cynic::schema::HasInputField<Slug, super::String> for super::LocationInput {}
}
pub struct LocationsInput;
impl ::cynic::schema::InputObjectMarker for LocationsInput {}
pub mod locations_input_fields {
    pub struct Value;
    impl ::cynic::schema::Field for Value {
        type Type = super::String;
        const NAME: &'static str = "value";
    }
    impl ::cynic::schema::HasInputField<Value, super::String> for super::LocationsInput {}
}
pub struct Mutation;
pub mod mutation_fields {
    pub struct Subscribe;
    impl ::cynic::schema::Field for Subscribe {
        type Type = super::User;
        const NAME: &'static str = "subscribe";
    }
    impl ::cynic::schema::HasField<Subscribe> for super::Mutation {
        type Type = super::User;
    }
    pub mod subscribe_arguments {
        pub struct Input;
        impl ::cynic::schema::HasArgument<Input> for super::Subscribe {
            type ArgumentType = super::super::SubscribeInput;
            const NAME: &'static str = "input";
        }
    }
    pub struct PostJob;
    impl ::cynic::schema::Field for PostJob {
        type Type = super::Job;
        const NAME: &'static str = "postJob";
    }
    impl ::cynic::schema::HasField<PostJob> for super::Mutation {
        type Type = super::Job;
    }
    pub mod post_job_arguments {
        pub struct Input;
        impl ::cynic::schema::HasArgument<Input> for super::PostJob {
            type ArgumentType = super::super::PostJobInput;
            const NAME: &'static str = "input";
        }
    }
    pub struct UpdateJob;
    impl ::cynic::schema::Field for UpdateJob {
        type Type = super::Job;
        const NAME: &'static str = "updateJob";
    }
    impl ::cynic::schema::HasField<UpdateJob> for super::Mutation {
        type Type = super::Job;
    }
    pub mod update_job_arguments {
        pub struct Input;
        impl ::cynic::schema::HasArgument<Input> for super::UpdateJob {
            type ArgumentType = super::super::UpdateJobInput;
            const NAME: &'static str = "input";
        }
        pub struct AdminSecret;
        impl ::cynic::schema::HasArgument<AdminSecret> for super::UpdateJob {
            type ArgumentType = super::super::String;
            const NAME: &'static str = "adminSecret";
        }
    }
    pub struct UpdateCompany;
    impl ::cynic::schema::Field for UpdateCompany {
        type Type = super::Company;
        const NAME: &'static str = "updateCompany";
    }
    impl ::cynic::schema::HasField<UpdateCompany> for super::Mutation {
        type Type = super::Company;
    }
    pub mod update_company_arguments {
        pub struct Input;
        impl ::cynic::schema::HasArgument<Input> for super::UpdateCompany {
            type ArgumentType = super::super::UpdateCompanyInput;
            const NAME: &'static str = "input";
        }
        pub struct AdminSecret;
        impl ::cynic::schema::HasArgument<AdminSecret> for super::UpdateCompany {
            type ArgumentType = super::super::String;
            const NAME: &'static str = "adminSecret";
        }
    }
}
pub struct PostJobInput;
impl ::cynic::schema::InputObjectMarker for PostJobInput {}
pub mod post_job_input_fields {
    pub struct Title;
    impl ::cynic::schema::Field for Title {
        type Type = super::String;
        const NAME: &'static str = "title";
    }
    impl ::cynic::schema::HasInputField<Title, super::String> for super::PostJobInput {}
    pub struct CommitmentId;
    impl ::cynic::schema::Field for CommitmentId {
        type Type = super::Id;
        const NAME: &'static str = "commitmentId";
    }
    impl ::cynic::schema::HasInputField<CommitmentId, super::Id> for super::PostJobInput {}
    pub struct CompanyName;
    impl ::cynic::schema::Field for CompanyName {
        type Type = super::String;
        const NAME: &'static str = "companyName";
    }
    impl ::cynic::schema::HasInputField<CompanyName, super::String> for super::PostJobInput {}
    pub struct LocationNames;
    impl ::cynic::schema::Field for LocationNames {
        type Type = super::String;
        const NAME: &'static str = "locationNames";
    }
    impl ::cynic::schema::HasInputField<LocationNames, super::String> for super::PostJobInput {}
    pub struct UserEmail;
    impl ::cynic::schema::Field for UserEmail {
        type Type = super::String;
        const NAME: &'static str = "userEmail";
    }
    impl ::cynic::schema::HasInputField<UserEmail, super::String> for super::PostJobInput {}
    pub struct Description;
    impl ::cynic::schema::Field for Description {
        type Type = super::String;
        const NAME: &'static str = "description";
    }
    impl ::cynic::schema::HasInputField<Description, super::String> for super::PostJobInput {}
    pub struct ApplyUrl;
    impl ::cynic::schema::Field for ApplyUrl {
        type Type = super::String;
        const NAME: &'static str = "applyUrl";
    }
    impl ::cynic::schema::HasInputField<ApplyUrl, super::String> for super::PostJobInput {}
}
pub struct Query;
pub mod query_fields {
    pub struct Jobs;
    impl ::cynic::schema::Field for Jobs {
        type Type = Vec<super::Job>;
        const NAME: &'static str = "jobs";
    }
    impl ::cynic::schema::HasField<Jobs> for super::Query {
        type Type = Vec<super::Job>;
    }
    pub mod jobs_arguments {
        pub struct Input;
        impl ::cynic::schema::HasArgument<Input> for super::Jobs {
            type ArgumentType = Option<super::super::JobsInput>;
            const NAME: &'static str = "input";
        }
    }
    pub struct Job;
    impl ::cynic::schema::Field for Job {
        type Type = super::Job;
        const NAME: &'static str = "job";
    }
    impl ::cynic::schema::HasField<Job> for super::Query {
        type Type = super::Job;
    }
    pub mod job_arguments {
        pub struct Input;
        impl ::cynic::schema::HasArgument<Input> for super::Job {
            type ArgumentType = super::super::JobInput;
            const NAME: &'static str = "input";
        }
    }
    pub struct Locations;
    impl ::cynic::schema::Field for Locations {
        type Type = Vec<super::Location>;
        const NAME: &'static str = "locations";
    }
    impl ::cynic::schema::HasField<Locations> for super::Query {
        type Type = Vec<super::Location>;
    }
    pub mod locations_arguments {
        pub struct Input;
        impl ::cynic::schema::HasArgument<Input> for super::Locations {
            type ArgumentType = super::super::LocationsInput;
            const NAME: &'static str = "input";
        }
    }
    pub struct City;
    impl ::cynic::schema::Field for City {
        type Type = super::City;
        const NAME: &'static str = "city";
    }
    impl ::cynic::schema::HasField<City> for super::Query {
        type Type = super::City;
    }
    pub mod city_arguments {
        pub struct Input;
        impl ::cynic::schema::HasArgument<Input> for super::City {
            type ArgumentType = super::super::LocationInput;
            const NAME: &'static str = "input";
        }
    }
    pub struct Country;
    impl ::cynic::schema::Field for Country {
        type Type = super::Country;
        const NAME: &'static str = "country";
    }
    impl ::cynic::schema::HasField<Country> for super::Query {
        type Type = super::Country;
    }
    pub mod country_arguments {
        pub struct Input;
        impl ::cynic::schema::HasArgument<Input> for super::Country {
            type ArgumentType = super::super::LocationInput;
            const NAME: &'static str = "input";
        }
    }
    pub struct Remote;
    impl ::cynic::schema::Field for Remote {
        type Type = super::Remote;
        const NAME: &'static str = "remote";
    }
    impl ::cynic::schema::HasField<Remote> for super::Query {
        type Type = super::Remote;
    }
    pub mod remote_arguments {
        pub struct Input;
        impl ::cynic::schema::HasArgument<Input> for super::Remote {
            type ArgumentType = super::super::LocationInput;
            const NAME: &'static str = "input";
        }
    }
    pub struct Commitments;
    impl ::cynic::schema::Field for Commitments {
        type Type = Vec<super::Commitment>;
        const NAME: &'static str = "commitments";
    }
    impl ::cynic::schema::HasField<Commitments> for super::Query {
        type Type = Vec<super::Commitment>;
    }
    pub struct Cities;
    impl ::cynic::schema::Field for Cities {
        type Type = Vec<super::City>;
        const NAME: &'static str = "cities";
    }
    impl ::cynic::schema::HasField<Cities> for super::Query {
        type Type = Vec<super::City>;
    }
    pub struct Countries;
    impl ::cynic::schema::Field for Countries {
        type Type = Vec<super::Country>;
        const NAME: &'static str = "countries";
    }
    impl ::cynic::schema::HasField<Countries> for super::Query {
        type Type = Vec<super::Country>;
    }
    pub struct Remotes;
    impl ::cynic::schema::Field for Remotes {
        type Type = Vec<super::Remote>;
        const NAME: &'static str = "remotes";
    }
    impl ::cynic::schema::HasField<Remotes> for super::Query {
        type Type = Vec<super::Remote>;
    }
    pub struct Companies;
    impl ::cynic::schema::Field for Companies {
        type Type = Vec<super::Company>;
        const NAME: &'static str = "companies";
    }
    impl ::cynic::schema::HasField<Companies> for super::Query {
        type Type = Vec<super::Company>;
    }
}
pub struct Remote;
pub mod remote_fields {
    pub struct Id;
    impl ::cynic::schema::Field for Id {
        type Type = super::Id;
        const NAME: &'static str = "id";
    }
    impl ::cynic::schema::HasField<Id> for super::Remote {
        type Type = super::Id;
    }
    pub struct Name;
    impl ::cynic::schema::Field for Name {
        type Type = super::String;
        const NAME: &'static str = "name";
    }
    impl ::cynic::schema::HasField<Name> for super::Remote {
        type Type = super::String;
    }
    pub struct Slug;
    impl ::cynic::schema::Field for Slug {
        type Type = super::String;
        const NAME: &'static str = "slug";
    }
    impl ::cynic::schema::HasField<Slug> for super::Remote {
        type Type = super::String;
    }
    pub struct Type;
    impl ::cynic::schema::Field for Type {
        type Type = super::String;
        const NAME: &'static str = "type";
    }
    impl ::cynic::schema::HasField<Type> for super::Remote {
        type Type = super::String;
    }
    pub struct Jobs;
    impl ::cynic::schema::Field for Jobs {
        type Type = Option<Vec<super::Job>>;
        const NAME: &'static str = "jobs";
    }
    impl ::cynic::schema::HasField<Jobs> for super::Remote {
        type Type = Option<Vec<super::Job>>;
    }
    pub mod jobs_arguments {
        pub struct Where;
        impl ::cynic::schema::HasArgument<Where> for super::Jobs {
            type ArgumentType = Option<super::super::JobWhereInput>;
            const NAME: &'static str = "where";
        }
        pub struct OrderBy;
        impl ::cynic::schema::HasArgument<OrderBy> for super::Jobs {
            type ArgumentType = Option<super::super::JobOrderByInput>;
            const NAME: &'static str = "orderBy";
        }
        pub struct Skip;
        impl ::cynic::schema::HasArgument<Skip> for super::Jobs {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "skip";
        }
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::Jobs {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "after";
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::Jobs {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "before";
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::Jobs {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "first";
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::Jobs {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "last";
        }
    }
    pub struct CreatedAt;
    impl ::cynic::schema::Field for CreatedAt {
        type Type = super::DateTime;
        const NAME: &'static str = "createdAt";
    }
    impl ::cynic::schema::HasField<CreatedAt> for super::Remote {
        type Type = super::DateTime;
    }
    pub struct UpdatedAt;
    impl ::cynic::schema::Field for UpdatedAt {
        type Type = super::DateTime;
        const NAME: &'static str = "updatedAt";
    }
    impl ::cynic::schema::HasField<UpdatedAt> for super::Remote {
        type Type = super::DateTime;
    }
}
pub struct RemoteOrderByInput {}
pub struct RemoteWhereInput;
impl ::cynic::schema::InputObjectMarker for RemoteWhereInput {}
pub mod remote_where_input_fields {
    pub struct Id;
    impl ::cynic::schema::Field for Id {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id";
    }
    impl ::cynic::schema::HasInputField<Id, Option<super::Id>> for super::RemoteWhereInput {}
    pub struct IdNot;
    impl ::cynic::schema::Field for IdNot {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_not";
    }
    impl ::cynic::schema::HasInputField<IdNot, Option<super::Id>> for super::RemoteWhereInput {}
    pub struct IdIn;
    impl ::cynic::schema::Field for IdIn {
        type Type = Option<Vec<super::Id>>;
        const NAME: &'static str = "id_in";
    }
    impl ::cynic::schema::HasInputField<IdIn, Option<Vec<super::Id>>> for super::RemoteWhereInput {}
    pub struct IdNotIn;
    impl ::cynic::schema::Field for IdNotIn {
        type Type = Option<Vec<super::Id>>;
        const NAME: &'static str = "id_not_in";
    }
    impl ::cynic::schema::HasInputField<IdNotIn, Option<Vec<super::Id>>> for super::RemoteWhereInput {}
    pub struct IdLt;
    impl ::cynic::schema::Field for IdLt {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_lt";
    }
    impl ::cynic::schema::HasInputField<IdLt, Option<super::Id>> for super::RemoteWhereInput {}
    pub struct IdLte;
    impl ::cynic::schema::Field for IdLte {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_lte";
    }
    impl ::cynic::schema::HasInputField<IdLte, Option<super::Id>> for super::RemoteWhereInput {}
    pub struct IdGt;
    impl ::cynic::schema::Field for IdGt {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_gt";
    }
    impl ::cynic::schema::HasInputField<IdGt, Option<super::Id>> for super::RemoteWhereInput {}
    pub struct IdGte;
    impl ::cynic::schema::Field for IdGte {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_gte";
    }
    impl ::cynic::schema::HasInputField<IdGte, Option<super::Id>> for super::RemoteWhereInput {}
    pub struct IdContains;
    impl ::cynic::schema::Field for IdContains {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_contains";
    }
    impl ::cynic::schema::HasInputField<IdContains, Option<super::Id>> for super::RemoteWhereInput {}
    pub struct IdNotContains;
    impl ::cynic::schema::Field for IdNotContains {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_not_contains";
    }
    impl ::cynic::schema::HasInputField<IdNotContains, Option<super::Id>> for super::RemoteWhereInput {}
    pub struct IdStartsWith;
    impl ::cynic::schema::Field for IdStartsWith {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_starts_with";
    }
    impl ::cynic::schema::HasInputField<IdStartsWith, Option<super::Id>> for super::RemoteWhereInput {}
    pub struct IdNotStartsWith;
    impl ::cynic::schema::Field for IdNotStartsWith {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_not_starts_with";
    }
    impl ::cynic::schema::HasInputField<IdNotStartsWith, Option<super::Id>>
        for super::RemoteWhereInput
    {
    }
    pub struct IdEndsWith;
    impl ::cynic::schema::Field for IdEndsWith {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_ends_with";
    }
    impl ::cynic::schema::HasInputField<IdEndsWith, Option<super::Id>> for super::RemoteWhereInput {}
    pub struct IdNotEndsWith;
    impl ::cynic::schema::Field for IdNotEndsWith {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_not_ends_with";
    }
    impl ::cynic::schema::HasInputField<IdNotEndsWith, Option<super::Id>> for super::RemoteWhereInput {}
    pub struct Name;
    impl ::cynic::schema::Field for Name {
        type Type = Option<super::String>;
        const NAME: &'static str = "name";
    }
    impl ::cynic::schema::HasInputField<Name, Option<super::String>> for super::RemoteWhereInput {}
    pub struct NameNot;
    impl ::cynic::schema::Field for NameNot {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_not";
    }
    impl ::cynic::schema::HasInputField<NameNot, Option<super::String>> for super::RemoteWhereInput {}
    pub struct NameIn;
    impl ::cynic::schema::Field for NameIn {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "name_in";
    }
    impl ::cynic::schema::HasInputField<NameIn, Option<Vec<super::String>>>
        for super::RemoteWhereInput
    {
    }
    pub struct NameNotIn;
    impl ::cynic::schema::Field for NameNotIn {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "name_not_in";
    }
    impl ::cynic::schema::HasInputField<NameNotIn, Option<Vec<super::String>>>
        for super::RemoteWhereInput
    {
    }
    pub struct NameLt;
    impl ::cynic::schema::Field for NameLt {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_lt";
    }
    impl ::cynic::schema::HasInputField<NameLt, Option<super::String>> for super::RemoteWhereInput {}
    pub struct NameLte;
    impl ::cynic::schema::Field for NameLte {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_lte";
    }
    impl ::cynic::schema::HasInputField<NameLte, Option<super::String>> for super::RemoteWhereInput {}
    pub struct NameGt;
    impl ::cynic::schema::Field for NameGt {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_gt";
    }
    impl ::cynic::schema::HasInputField<NameGt, Option<super::String>> for super::RemoteWhereInput {}
    pub struct NameGte;
    impl ::cynic::schema::Field for NameGte {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_gte";
    }
    impl ::cynic::schema::HasInputField<NameGte, Option<super::String>> for super::RemoteWhereInput {}
    pub struct NameContains;
    impl ::cynic::schema::Field for NameContains {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_contains";
    }
    impl ::cynic::schema::HasInputField<NameContains, Option<super::String>>
        for super::RemoteWhereInput
    {
    }
    pub struct NameNotContains;
    impl ::cynic::schema::Field for NameNotContains {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_not_contains";
    }
    impl ::cynic::schema::HasInputField<NameNotContains, Option<super::String>>
        for super::RemoteWhereInput
    {
    }
    pub struct NameStartsWith;
    impl ::cynic::schema::Field for NameStartsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_starts_with";
    }
    impl ::cynic::schema::HasInputField<NameStartsWith, Option<super::String>>
        for super::RemoteWhereInput
    {
    }
    pub struct NameNotStartsWith;
    impl ::cynic::schema::Field for NameNotStartsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_not_starts_with";
    }
    impl ::cynic::schema::HasInputField<NameNotStartsWith, Option<super::String>>
        for super::RemoteWhereInput
    {
    }
    pub struct NameEndsWith;
    impl ::cynic::schema::Field for NameEndsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_ends_with";
    }
    impl ::cynic::schema::HasInputField<NameEndsWith, Option<super::String>>
        for super::RemoteWhereInput
    {
    }
    pub struct NameNotEndsWith;
    impl ::cynic::schema::Field for NameNotEndsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_not_ends_with";
    }
    impl ::cynic::schema::HasInputField<NameNotEndsWith, Option<super::String>>
        for super::RemoteWhereInput
    {
    }
    pub struct Slug;
    impl ::cynic::schema::Field for Slug {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug";
    }
    impl ::cynic::schema::HasInputField<Slug, Option<super::String>> for super::RemoteWhereInput {}
    pub struct SlugNot;
    impl ::cynic::schema::Field for SlugNot {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_not";
    }
    impl ::cynic::schema::HasInputField<SlugNot, Option<super::String>> for super::RemoteWhereInput {}
    pub struct SlugIn;
    impl ::cynic::schema::Field for SlugIn {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "slug_in";
    }
    impl ::cynic::schema::HasInputField<SlugIn, Option<Vec<super::String>>>
        for super::RemoteWhereInput
    {
    }
    pub struct SlugNotIn;
    impl ::cynic::schema::Field for SlugNotIn {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "slug_not_in";
    }
    impl ::cynic::schema::HasInputField<SlugNotIn, Option<Vec<super::String>>>
        for super::RemoteWhereInput
    {
    }
    pub struct SlugLt;
    impl ::cynic::schema::Field for SlugLt {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_lt";
    }
    impl ::cynic::schema::HasInputField<SlugLt, Option<super::String>> for super::RemoteWhereInput {}
    pub struct SlugLte;
    impl ::cynic::schema::Field for SlugLte {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_lte";
    }
    impl ::cynic::schema::HasInputField<SlugLte, Option<super::String>> for super::RemoteWhereInput {}
    pub struct SlugGt;
    impl ::cynic::schema::Field for SlugGt {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_gt";
    }
    impl ::cynic::schema::HasInputField<SlugGt, Option<super::String>> for super::RemoteWhereInput {}
    pub struct SlugGte;
    impl ::cynic::schema::Field for SlugGte {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_gte";
    }
    impl ::cynic::schema::HasInputField<SlugGte, Option<super::String>> for super::RemoteWhereInput {}
    pub struct SlugContains;
    impl ::cynic::schema::Field for SlugContains {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_contains";
    }
    impl ::cynic::schema::HasInputField<SlugContains, Option<super::String>>
        for super::RemoteWhereInput
    {
    }
    pub struct SlugNotContains;
    impl ::cynic::schema::Field for SlugNotContains {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_not_contains";
    }
    impl ::cynic::schema::HasInputField<SlugNotContains, Option<super::String>>
        for super::RemoteWhereInput
    {
    }
    pub struct SlugStartsWith;
    impl ::cynic::schema::Field for SlugStartsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_starts_with";
    }
    impl ::cynic::schema::HasInputField<SlugStartsWith, Option<super::String>>
        for super::RemoteWhereInput
    {
    }
    pub struct SlugNotStartsWith;
    impl ::cynic::schema::Field for SlugNotStartsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_not_starts_with";
    }
    impl ::cynic::schema::HasInputField<SlugNotStartsWith, Option<super::String>>
        for super::RemoteWhereInput
    {
    }
    pub struct SlugEndsWith;
    impl ::cynic::schema::Field for SlugEndsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_ends_with";
    }
    impl ::cynic::schema::HasInputField<SlugEndsWith, Option<super::String>>
        for super::RemoteWhereInput
    {
    }
    pub struct SlugNotEndsWith;
    impl ::cynic::schema::Field for SlugNotEndsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_not_ends_with";
    }
    impl ::cynic::schema::HasInputField<SlugNotEndsWith, Option<super::String>>
        for super::RemoteWhereInput
    {
    }
    pub struct Type;
    impl ::cynic::schema::Field for Type {
        type Type = Option<super::String>;
        const NAME: &'static str = "type";
    }
    impl ::cynic::schema::HasInputField<Type, Option<super::String>> for super::RemoteWhereInput {}
    pub struct TypeNot;
    impl ::cynic::schema::Field for TypeNot {
        type Type = Option<super::String>;
        const NAME: &'static str = "type_not";
    }
    impl ::cynic::schema::HasInputField<TypeNot, Option<super::String>> for super::RemoteWhereInput {}
    pub struct TypeIn;
    impl ::cynic::schema::Field for TypeIn {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "type_in";
    }
    impl ::cynic::schema::HasInputField<TypeIn, Option<Vec<super::String>>>
        for super::RemoteWhereInput
    {
    }
    pub struct TypeNotIn;
    impl ::cynic::schema::Field for TypeNotIn {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "type_not_in";
    }
    impl ::cynic::schema::HasInputField<TypeNotIn, Option<Vec<super::String>>>
        for super::RemoteWhereInput
    {
    }
    pub struct TypeLt;
    impl ::cynic::schema::Field for TypeLt {
        type Type = Option<super::String>;
        const NAME: &'static str = "type_lt";
    }
    impl ::cynic::schema::HasInputField<TypeLt, Option<super::String>> for super::RemoteWhereInput {}
    pub struct TypeLte;
    impl ::cynic::schema::Field for TypeLte {
        type Type = Option<super::String>;
        const NAME: &'static str = "type_lte";
    }
    impl ::cynic::schema::HasInputField<TypeLte, Option<super::String>> for super::RemoteWhereInput {}
    pub struct TypeGt;
    impl ::cynic::schema::Field for TypeGt {
        type Type = Option<super::String>;
        const NAME: &'static str = "type_gt";
    }
    impl ::cynic::schema::HasInputField<TypeGt, Option<super::String>> for super::RemoteWhereInput {}
    pub struct TypeGte;
    impl ::cynic::schema::Field for TypeGte {
        type Type = Option<super::String>;
        const NAME: &'static str = "type_gte";
    }
    impl ::cynic::schema::HasInputField<TypeGte, Option<super::String>> for super::RemoteWhereInput {}
    pub struct TypeContains;
    impl ::cynic::schema::Field for TypeContains {
        type Type = Option<super::String>;
        const NAME: &'static str = "type_contains";
    }
    impl ::cynic::schema::HasInputField<TypeContains, Option<super::String>>
        for super::RemoteWhereInput
    {
    }
    pub struct TypeNotContains;
    impl ::cynic::schema::Field for TypeNotContains {
        type Type = Option<super::String>;
        const NAME: &'static str = "type_not_contains";
    }
    impl ::cynic::schema::HasInputField<TypeNotContains, Option<super::String>>
        for super::RemoteWhereInput
    {
    }
    pub struct TypeStartsWith;
    impl ::cynic::schema::Field for TypeStartsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "type_starts_with";
    }
    impl ::cynic::schema::HasInputField<TypeStartsWith, Option<super::String>>
        for super::RemoteWhereInput
    {
    }
    pub struct TypeNotStartsWith;
    impl ::cynic::schema::Field for TypeNotStartsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "type_not_starts_with";
    }
    impl ::cynic::schema::HasInputField<TypeNotStartsWith, Option<super::String>>
        for super::RemoteWhereInput
    {
    }
    pub struct TypeEndsWith;
    impl ::cynic::schema::Field for TypeEndsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "type_ends_with";
    }
    impl ::cynic::schema::HasInputField<TypeEndsWith, Option<super::String>>
        for super::RemoteWhereInput
    {
    }
    pub struct TypeNotEndsWith;
    impl ::cynic::schema::Field for TypeNotEndsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "type_not_ends_with";
    }
    impl ::cynic::schema::HasInputField<TypeNotEndsWith, Option<super::String>>
        for super::RemoteWhereInput
    {
    }
    pub struct JobsEvery;
    impl ::cynic::schema::Field for JobsEvery {
        type Type = Option<super::JobWhereInput>;
        const NAME: &'static str = "jobs_every";
    }
    impl ::cynic::schema::HasInputField<JobsEvery, Option<super::JobWhereInput>>
        for super::RemoteWhereInput
    {
    }
    pub struct JobsSome;
    impl ::cynic::schema::Field for JobsSome {
        type Type = Option<super::JobWhereInput>;
        const NAME: &'static str = "jobs_some";
    }
    impl ::cynic::schema::HasInputField<JobsSome, Option<super::JobWhereInput>>
        for super::RemoteWhereInput
    {
    }
    pub struct JobsNone;
    impl ::cynic::schema::Field for JobsNone {
        type Type = Option<super::JobWhereInput>;
        const NAME: &'static str = "jobs_none";
    }
    impl ::cynic::schema::HasInputField<JobsNone, Option<super::JobWhereInput>>
        for super::RemoteWhereInput
    {
    }
    pub struct CreatedAt;
    impl ::cynic::schema::Field for CreatedAt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt";
    }
    impl ::cynic::schema::HasInputField<CreatedAt, Option<super::DateTime>>
        for super::RemoteWhereInput
    {
    }
    pub struct CreatedAtNot;
    impl ::cynic::schema::Field for CreatedAtNot {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt_not";
    }
    impl ::cynic::schema::HasInputField<CreatedAtNot, Option<super::DateTime>>
        for super::RemoteWhereInput
    {
    }
    pub struct CreatedAtIn;
    impl ::cynic::schema::Field for CreatedAtIn {
        type Type = Option<Vec<super::DateTime>>;
        const NAME: &'static str = "createdAt_in";
    }
    impl ::cynic::schema::HasInputField<CreatedAtIn, Option<Vec<super::DateTime>>>
        for super::RemoteWhereInput
    {
    }
    pub struct CreatedAtNotIn;
    impl ::cynic::schema::Field for CreatedAtNotIn {
        type Type = Option<Vec<super::DateTime>>;
        const NAME: &'static str = "createdAt_not_in";
    }
    impl ::cynic::schema::HasInputField<CreatedAtNotIn, Option<Vec<super::DateTime>>>
        for super::RemoteWhereInput
    {
    }
    pub struct CreatedAtLt;
    impl ::cynic::schema::Field for CreatedAtLt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt_lt";
    }
    impl ::cynic::schema::HasInputField<CreatedAtLt, Option<super::DateTime>>
        for super::RemoteWhereInput
    {
    }
    pub struct CreatedAtLte;
    impl ::cynic::schema::Field for CreatedAtLte {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt_lte";
    }
    impl ::cynic::schema::HasInputField<CreatedAtLte, Option<super::DateTime>>
        for super::RemoteWhereInput
    {
    }
    pub struct CreatedAtGt;
    impl ::cynic::schema::Field for CreatedAtGt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt_gt";
    }
    impl ::cynic::schema::HasInputField<CreatedAtGt, Option<super::DateTime>>
        for super::RemoteWhereInput
    {
    }
    pub struct CreatedAtGte;
    impl ::cynic::schema::Field for CreatedAtGte {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt_gte";
    }
    impl ::cynic::schema::HasInputField<CreatedAtGte, Option<super::DateTime>>
        for super::RemoteWhereInput
    {
    }
    pub struct UpdatedAt;
    impl ::cynic::schema::Field for UpdatedAt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt";
    }
    impl ::cynic::schema::HasInputField<UpdatedAt, Option<super::DateTime>>
        for super::RemoteWhereInput
    {
    }
    pub struct UpdatedAtNot;
    impl ::cynic::schema::Field for UpdatedAtNot {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt_not";
    }
    impl ::cynic::schema::HasInputField<UpdatedAtNot, Option<super::DateTime>>
        for super::RemoteWhereInput
    {
    }
    pub struct UpdatedAtIn;
    impl ::cynic::schema::Field for UpdatedAtIn {
        type Type = Option<Vec<super::DateTime>>;
        const NAME: &'static str = "updatedAt_in";
    }
    impl ::cynic::schema::HasInputField<UpdatedAtIn, Option<Vec<super::DateTime>>>
        for super::RemoteWhereInput
    {
    }
    pub struct UpdatedAtNotIn;
    impl ::cynic::schema::Field for UpdatedAtNotIn {
        type Type = Option<Vec<super::DateTime>>;
        const NAME: &'static str = "updatedAt_not_in";
    }
    impl ::cynic::schema::HasInputField<UpdatedAtNotIn, Option<Vec<super::DateTime>>>
        for super::RemoteWhereInput
    {
    }
    pub struct UpdatedAtLt;
    impl ::cynic::schema::Field for UpdatedAtLt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt_lt";
    }
    impl ::cynic::schema::HasInputField<UpdatedAtLt, Option<super::DateTime>>
        for super::RemoteWhereInput
    {
    }
    pub struct UpdatedAtLte;
    impl ::cynic::schema::Field for UpdatedAtLte {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt_lte";
    }
    impl ::cynic::schema::HasInputField<UpdatedAtLte, Option<super::DateTime>>
        for super::RemoteWhereInput
    {
    }
    pub struct UpdatedAtGt;
    impl ::cynic::schema::Field for UpdatedAtGt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt_gt";
    }
    impl ::cynic::schema::HasInputField<UpdatedAtGt, Option<super::DateTime>>
        for super::RemoteWhereInput
    {
    }
    pub struct UpdatedAtGte;
    impl ::cynic::schema::Field for UpdatedAtGte {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt_gte";
    }
    impl ::cynic::schema::HasInputField<UpdatedAtGte, Option<super::DateTime>>
        for super::RemoteWhereInput
    {
    }
    pub struct And;
    impl ::cynic::schema::Field for And {
        type Type = Option<Vec<super::RemoteWhereInput>>;
        const NAME: &'static str = "AND";
    }
    impl ::cynic::schema::HasInputField<And, Option<Vec<super::RemoteWhereInput>>>
        for super::RemoteWhereInput
    {
    }
    pub struct Or;
    impl ::cynic::schema::Field for Or {
        type Type = Option<Vec<super::RemoteWhereInput>>;
        const NAME: &'static str = "OR";
    }
    impl ::cynic::schema::HasInputField<Or, Option<Vec<super::RemoteWhereInput>>>
        for super::RemoteWhereInput
    {
    }
    pub struct Not;
    impl ::cynic::schema::Field for Not {
        type Type = Option<Vec<super::RemoteWhereInput>>;
        const NAME: &'static str = "NOT";
    }
    impl ::cynic::schema::HasInputField<Not, Option<Vec<super::RemoteWhereInput>>>
        for super::RemoteWhereInput
    {
    }
}
pub struct SubscribeInput;
impl ::cynic::schema::InputObjectMarker for SubscribeInput {}
pub mod subscribe_input_fields {
    pub struct Name;
    impl ::cynic::schema::Field for Name {
        type Type = super::String;
        const NAME: &'static str = "name";
    }
    impl ::cynic::schema::HasInputField<Name, super::String> for super::SubscribeInput {}
    pub struct Email;
    impl ::cynic::schema::Field for Email {
        type Type = super::String;
        const NAME: &'static str = "email";
    }
    impl ::cynic::schema::HasInputField<Email, super::String> for super::SubscribeInput {}
}
pub struct Tag;
pub mod tag_fields {
    pub struct Id;
    impl ::cynic::schema::Field for Id {
        type Type = super::Id;
        const NAME: &'static str = "id";
    }
    impl ::cynic::schema::HasField<Id> for super::Tag {
        type Type = super::Id;
    }
    pub struct Name;
    impl ::cynic::schema::Field for Name {
        type Type = super::String;
        const NAME: &'static str = "name";
    }
    impl ::cynic::schema::HasField<Name> for super::Tag {
        type Type = super::String;
    }
    pub struct Slug;
    impl ::cynic::schema::Field for Slug {
        type Type = super::String;
        const NAME: &'static str = "slug";
    }
    impl ::cynic::schema::HasField<Slug> for super::Tag {
        type Type = super::String;
    }
    pub struct Jobs;
    impl ::cynic::schema::Field for Jobs {
        type Type = Option<Vec<super::Job>>;
        const NAME: &'static str = "jobs";
    }
    impl ::cynic::schema::HasField<Jobs> for super::Tag {
        type Type = Option<Vec<super::Job>>;
    }
    pub mod jobs_arguments {
        pub struct Where;
        impl ::cynic::schema::HasArgument<Where> for super::Jobs {
            type ArgumentType = Option<super::super::JobWhereInput>;
            const NAME: &'static str = "where";
        }
        pub struct OrderBy;
        impl ::cynic::schema::HasArgument<OrderBy> for super::Jobs {
            type ArgumentType = Option<super::super::JobOrderByInput>;
            const NAME: &'static str = "orderBy";
        }
        pub struct Skip;
        impl ::cynic::schema::HasArgument<Skip> for super::Jobs {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "skip";
        }
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::Jobs {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "after";
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::Jobs {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "before";
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::Jobs {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "first";
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::Jobs {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "last";
        }
    }
    pub struct CreatedAt;
    impl ::cynic::schema::Field for CreatedAt {
        type Type = super::DateTime;
        const NAME: &'static str = "createdAt";
    }
    impl ::cynic::schema::HasField<CreatedAt> for super::Tag {
        type Type = super::DateTime;
    }
    pub struct UpdatedAt;
    impl ::cynic::schema::Field for UpdatedAt {
        type Type = super::DateTime;
        const NAME: &'static str = "updatedAt";
    }
    impl ::cynic::schema::HasField<UpdatedAt> for super::Tag {
        type Type = super::DateTime;
    }
}
pub struct TagOrderByInput {}
pub struct TagWhereInput;
impl ::cynic::schema::InputObjectMarker for TagWhereInput {}
pub mod tag_where_input_fields {
    pub struct Id;
    impl ::cynic::schema::Field for Id {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id";
    }
    impl ::cynic::schema::HasInputField<Id, Option<super::Id>> for super::TagWhereInput {}
    pub struct IdNot;
    impl ::cynic::schema::Field for IdNot {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_not";
    }
    impl ::cynic::schema::HasInputField<IdNot, Option<super::Id>> for super::TagWhereInput {}
    pub struct IdIn;
    impl ::cynic::schema::Field for IdIn {
        type Type = Option<Vec<super::Id>>;
        const NAME: &'static str = "id_in";
    }
    impl ::cynic::schema::HasInputField<IdIn, Option<Vec<super::Id>>> for super::TagWhereInput {}
    pub struct IdNotIn;
    impl ::cynic::schema::Field for IdNotIn {
        type Type = Option<Vec<super::Id>>;
        const NAME: &'static str = "id_not_in";
    }
    impl ::cynic::schema::HasInputField<IdNotIn, Option<Vec<super::Id>>> for super::TagWhereInput {}
    pub struct IdLt;
    impl ::cynic::schema::Field for IdLt {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_lt";
    }
    impl ::cynic::schema::HasInputField<IdLt, Option<super::Id>> for super::TagWhereInput {}
    pub struct IdLte;
    impl ::cynic::schema::Field for IdLte {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_lte";
    }
    impl ::cynic::schema::HasInputField<IdLte, Option<super::Id>> for super::TagWhereInput {}
    pub struct IdGt;
    impl ::cynic::schema::Field for IdGt {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_gt";
    }
    impl ::cynic::schema::HasInputField<IdGt, Option<super::Id>> for super::TagWhereInput {}
    pub struct IdGte;
    impl ::cynic::schema::Field for IdGte {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_gte";
    }
    impl ::cynic::schema::HasInputField<IdGte, Option<super::Id>> for super::TagWhereInput {}
    pub struct IdContains;
    impl ::cynic::schema::Field for IdContains {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_contains";
    }
    impl ::cynic::schema::HasInputField<IdContains, Option<super::Id>> for super::TagWhereInput {}
    pub struct IdNotContains;
    impl ::cynic::schema::Field for IdNotContains {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_not_contains";
    }
    impl ::cynic::schema::HasInputField<IdNotContains, Option<super::Id>> for super::TagWhereInput {}
    pub struct IdStartsWith;
    impl ::cynic::schema::Field for IdStartsWith {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_starts_with";
    }
    impl ::cynic::schema::HasInputField<IdStartsWith, Option<super::Id>> for super::TagWhereInput {}
    pub struct IdNotStartsWith;
    impl ::cynic::schema::Field for IdNotStartsWith {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_not_starts_with";
    }
    impl ::cynic::schema::HasInputField<IdNotStartsWith, Option<super::Id>> for super::TagWhereInput {}
    pub struct IdEndsWith;
    impl ::cynic::schema::Field for IdEndsWith {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_ends_with";
    }
    impl ::cynic::schema::HasInputField<IdEndsWith, Option<super::Id>> for super::TagWhereInput {}
    pub struct IdNotEndsWith;
    impl ::cynic::schema::Field for IdNotEndsWith {
        type Type = Option<super::Id>;
        const NAME: &'static str = "id_not_ends_with";
    }
    impl ::cynic::schema::HasInputField<IdNotEndsWith, Option<super::Id>> for super::TagWhereInput {}
    pub struct Name;
    impl ::cynic::schema::Field for Name {
        type Type = Option<super::String>;
        const NAME: &'static str = "name";
    }
    impl ::cynic::schema::HasInputField<Name, Option<super::String>> for super::TagWhereInput {}
    pub struct NameNot;
    impl ::cynic::schema::Field for NameNot {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_not";
    }
    impl ::cynic::schema::HasInputField<NameNot, Option<super::String>> for super::TagWhereInput {}
    pub struct NameIn;
    impl ::cynic::schema::Field for NameIn {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "name_in";
    }
    impl ::cynic::schema::HasInputField<NameIn, Option<Vec<super::String>>> for super::TagWhereInput {}
    pub struct NameNotIn;
    impl ::cynic::schema::Field for NameNotIn {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "name_not_in";
    }
    impl ::cynic::schema::HasInputField<NameNotIn, Option<Vec<super::String>>>
        for super::TagWhereInput
    {
    }
    pub struct NameLt;
    impl ::cynic::schema::Field for NameLt {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_lt";
    }
    impl ::cynic::schema::HasInputField<NameLt, Option<super::String>> for super::TagWhereInput {}
    pub struct NameLte;
    impl ::cynic::schema::Field for NameLte {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_lte";
    }
    impl ::cynic::schema::HasInputField<NameLte, Option<super::String>> for super::TagWhereInput {}
    pub struct NameGt;
    impl ::cynic::schema::Field for NameGt {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_gt";
    }
    impl ::cynic::schema::HasInputField<NameGt, Option<super::String>> for super::TagWhereInput {}
    pub struct NameGte;
    impl ::cynic::schema::Field for NameGte {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_gte";
    }
    impl ::cynic::schema::HasInputField<NameGte, Option<super::String>> for super::TagWhereInput {}
    pub struct NameContains;
    impl ::cynic::schema::Field for NameContains {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_contains";
    }
    impl ::cynic::schema::HasInputField<NameContains, Option<super::String>> for super::TagWhereInput {}
    pub struct NameNotContains;
    impl ::cynic::schema::Field for NameNotContains {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_not_contains";
    }
    impl ::cynic::schema::HasInputField<NameNotContains, Option<super::String>>
        for super::TagWhereInput
    {
    }
    pub struct NameStartsWith;
    impl ::cynic::schema::Field for NameStartsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_starts_with";
    }
    impl ::cynic::schema::HasInputField<NameStartsWith, Option<super::String>>
        for super::TagWhereInput
    {
    }
    pub struct NameNotStartsWith;
    impl ::cynic::schema::Field for NameNotStartsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_not_starts_with";
    }
    impl ::cynic::schema::HasInputField<NameNotStartsWith, Option<super::String>>
        for super::TagWhereInput
    {
    }
    pub struct NameEndsWith;
    impl ::cynic::schema::Field for NameEndsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_ends_with";
    }
    impl ::cynic::schema::HasInputField<NameEndsWith, Option<super::String>> for super::TagWhereInput {}
    pub struct NameNotEndsWith;
    impl ::cynic::schema::Field for NameNotEndsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "name_not_ends_with";
    }
    impl ::cynic::schema::HasInputField<NameNotEndsWith, Option<super::String>>
        for super::TagWhereInput
    {
    }
    pub struct Slug;
    impl ::cynic::schema::Field for Slug {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug";
    }
    impl ::cynic::schema::HasInputField<Slug, Option<super::String>> for super::TagWhereInput {}
    pub struct SlugNot;
    impl ::cynic::schema::Field for SlugNot {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_not";
    }
    impl ::cynic::schema::HasInputField<SlugNot, Option<super::String>> for super::TagWhereInput {}
    pub struct SlugIn;
    impl ::cynic::schema::Field for SlugIn {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "slug_in";
    }
    impl ::cynic::schema::HasInputField<SlugIn, Option<Vec<super::String>>> for super::TagWhereInput {}
    pub struct SlugNotIn;
    impl ::cynic::schema::Field for SlugNotIn {
        type Type = Option<Vec<super::String>>;
        const NAME: &'static str = "slug_not_in";
    }
    impl ::cynic::schema::HasInputField<SlugNotIn, Option<Vec<super::String>>>
        for super::TagWhereInput
    {
    }
    pub struct SlugLt;
    impl ::cynic::schema::Field for SlugLt {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_lt";
    }
    impl ::cynic::schema::HasInputField<SlugLt, Option<super::String>> for super::TagWhereInput {}
    pub struct SlugLte;
    impl ::cynic::schema::Field for SlugLte {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_lte";
    }
    impl ::cynic::schema::HasInputField<SlugLte, Option<super::String>> for super::TagWhereInput {}
    pub struct SlugGt;
    impl ::cynic::schema::Field for SlugGt {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_gt";
    }
    impl ::cynic::schema::HasInputField<SlugGt, Option<super::String>> for super::TagWhereInput {}
    pub struct SlugGte;
    impl ::cynic::schema::Field for SlugGte {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_gte";
    }
    impl ::cynic::schema::HasInputField<SlugGte, Option<super::String>> for super::TagWhereInput {}
    pub struct SlugContains;
    impl ::cynic::schema::Field for SlugContains {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_contains";
    }
    impl ::cynic::schema::HasInputField<SlugContains, Option<super::String>> for super::TagWhereInput {}
    pub struct SlugNotContains;
    impl ::cynic::schema::Field for SlugNotContains {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_not_contains";
    }
    impl ::cynic::schema::HasInputField<SlugNotContains, Option<super::String>>
        for super::TagWhereInput
    {
    }
    pub struct SlugStartsWith;
    impl ::cynic::schema::Field for SlugStartsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_starts_with";
    }
    impl ::cynic::schema::HasInputField<SlugStartsWith, Option<super::String>>
        for super::TagWhereInput
    {
    }
    pub struct SlugNotStartsWith;
    impl ::cynic::schema::Field for SlugNotStartsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_not_starts_with";
    }
    impl ::cynic::schema::HasInputField<SlugNotStartsWith, Option<super::String>>
        for super::TagWhereInput
    {
    }
    pub struct SlugEndsWith;
    impl ::cynic::schema::Field for SlugEndsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_ends_with";
    }
    impl ::cynic::schema::HasInputField<SlugEndsWith, Option<super::String>> for super::TagWhereInput {}
    pub struct SlugNotEndsWith;
    impl ::cynic::schema::Field for SlugNotEndsWith {
        type Type = Option<super::String>;
        const NAME: &'static str = "slug_not_ends_with";
    }
    impl ::cynic::schema::HasInputField<SlugNotEndsWith, Option<super::String>>
        for super::TagWhereInput
    {
    }
    pub struct JobsEvery;
    impl ::cynic::schema::Field for JobsEvery {
        type Type = Option<super::JobWhereInput>;
        const NAME: &'static str = "jobs_every";
    }
    impl ::cynic::schema::HasInputField<JobsEvery, Option<super::JobWhereInput>>
        for super::TagWhereInput
    {
    }
    pub struct JobsSome;
    impl ::cynic::schema::Field for JobsSome {
        type Type = Option<super::JobWhereInput>;
        const NAME: &'static str = "jobs_some";
    }
    impl ::cynic::schema::HasInputField<JobsSome, Option<super::JobWhereInput>>
        for super::TagWhereInput
    {
    }
    pub struct JobsNone;
    impl ::cynic::schema::Field for JobsNone {
        type Type = Option<super::JobWhereInput>;
        const NAME: &'static str = "jobs_none";
    }
    impl ::cynic::schema::HasInputField<JobsNone, Option<super::JobWhereInput>>
        for super::TagWhereInput
    {
    }
    pub struct CreatedAt;
    impl ::cynic::schema::Field for CreatedAt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt";
    }
    impl ::cynic::schema::HasInputField<CreatedAt, Option<super::DateTime>> for super::TagWhereInput {}
    pub struct CreatedAtNot;
    impl ::cynic::schema::Field for CreatedAtNot {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt_not";
    }
    impl ::cynic::schema::HasInputField<CreatedAtNot, Option<super::DateTime>>
        for super::TagWhereInput
    {
    }
    pub struct CreatedAtIn;
    impl ::cynic::schema::Field for CreatedAtIn {
        type Type = Option<Vec<super::DateTime>>;
        const NAME: &'static str = "createdAt_in";
    }
    impl ::cynic::schema::HasInputField<CreatedAtIn, Option<Vec<super::DateTime>>>
        for super::TagWhereInput
    {
    }
    pub struct CreatedAtNotIn;
    impl ::cynic::schema::Field for CreatedAtNotIn {
        type Type = Option<Vec<super::DateTime>>;
        const NAME: &'static str = "createdAt_not_in";
    }
    impl ::cynic::schema::HasInputField<CreatedAtNotIn, Option<Vec<super::DateTime>>>
        for super::TagWhereInput
    {
    }
    pub struct CreatedAtLt;
    impl ::cynic::schema::Field for CreatedAtLt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt_lt";
    }
    impl ::cynic::schema::HasInputField<CreatedAtLt, Option<super::DateTime>> for super::TagWhereInput {}
    pub struct CreatedAtLte;
    impl ::cynic::schema::Field for CreatedAtLte {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt_lte";
    }
    impl ::cynic::schema::HasInputField<CreatedAtLte, Option<super::DateTime>>
        for super::TagWhereInput
    {
    }
    pub struct CreatedAtGt;
    impl ::cynic::schema::Field for CreatedAtGt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt_gt";
    }
    impl ::cynic::schema::HasInputField<CreatedAtGt, Option<super::DateTime>> for super::TagWhereInput {}
    pub struct CreatedAtGte;
    impl ::cynic::schema::Field for CreatedAtGte {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "createdAt_gte";
    }
    impl ::cynic::schema::HasInputField<CreatedAtGte, Option<super::DateTime>>
        for super::TagWhereInput
    {
    }
    pub struct UpdatedAt;
    impl ::cynic::schema::Field for UpdatedAt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt";
    }
    impl ::cynic::schema::HasInputField<UpdatedAt, Option<super::DateTime>> for super::TagWhereInput {}
    pub struct UpdatedAtNot;
    impl ::cynic::schema::Field for UpdatedAtNot {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt_not";
    }
    impl ::cynic::schema::HasInputField<UpdatedAtNot, Option<super::DateTime>>
        for super::TagWhereInput
    {
    }
    pub struct UpdatedAtIn;
    impl ::cynic::schema::Field for UpdatedAtIn {
        type Type = Option<Vec<super::DateTime>>;
        const NAME: &'static str = "updatedAt_in";
    }
    impl ::cynic::schema::HasInputField<UpdatedAtIn, Option<Vec<super::DateTime>>>
        for super::TagWhereInput
    {
    }
    pub struct UpdatedAtNotIn;
    impl ::cynic::schema::Field for UpdatedAtNotIn {
        type Type = Option<Vec<super::DateTime>>;
        const NAME: &'static str = "updatedAt_not_in";
    }
    impl ::cynic::schema::HasInputField<UpdatedAtNotIn, Option<Vec<super::DateTime>>>
        for super::TagWhereInput
    {
    }
    pub struct UpdatedAtLt;
    impl ::cynic::schema::Field for UpdatedAtLt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt_lt";
    }
    impl ::cynic::schema::HasInputField<UpdatedAtLt, Option<super::DateTime>> for super::TagWhereInput {}
    pub struct UpdatedAtLte;
    impl ::cynic::schema::Field for UpdatedAtLte {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt_lte";
    }
    impl ::cynic::schema::HasInputField<UpdatedAtLte, Option<super::DateTime>>
        for super::TagWhereInput
    {
    }
    pub struct UpdatedAtGt;
    impl ::cynic::schema::Field for UpdatedAtGt {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt_gt";
    }
    impl ::cynic::schema::HasInputField<UpdatedAtGt, Option<super::DateTime>> for super::TagWhereInput {}
    pub struct UpdatedAtGte;
    impl ::cynic::schema::Field for UpdatedAtGte {
        type Type = Option<super::DateTime>;
        const NAME: &'static str = "updatedAt_gte";
    }
    impl ::cynic::schema::HasInputField<UpdatedAtGte, Option<super::DateTime>>
        for super::TagWhereInput
    {
    }
    pub struct And;
    impl ::cynic::schema::Field for And {
        type Type = Option<Vec<super::TagWhereInput>>;
        const NAME: &'static str = "AND";
    }
    impl ::cynic::schema::HasInputField<And, Option<Vec<super::TagWhereInput>>>
        for super::TagWhereInput
    {
    }
    pub struct Or;
    impl ::cynic::schema::Field for Or {
        type Type = Option<Vec<super::TagWhereInput>>;
        const NAME: &'static str = "OR";
    }
    impl ::cynic::schema::HasInputField<Or, Option<Vec<super::TagWhereInput>>>
        for super::TagWhereInput
    {
    }
    pub struct Not;
    impl ::cynic::schema::Field for Not {
        type Type = Option<Vec<super::TagWhereInput>>;
        const NAME: &'static str = "NOT";
    }
    impl ::cynic::schema::HasInputField<Not, Option<Vec<super::TagWhereInput>>>
        for super::TagWhereInput
    {
    }
}
pub struct UpdateCompanyInput;
impl ::cynic::schema::InputObjectMarker for UpdateCompanyInput {}
pub mod update_company_input_fields {
    pub struct Id;
    impl ::cynic::schema::Field for Id {
        type Type = super::Id;
        const NAME: &'static str = "id";
    }
    impl ::cynic::schema::HasInputField<Id, super::Id> for super::UpdateCompanyInput {}
    pub struct LogoUrl;
    impl ::cynic::schema::Field for LogoUrl {
        type Type = super::String;
        const NAME: &'static str = "logoUrl";
    }
    impl ::cynic::schema::HasInputField<LogoUrl, super::String> for super::UpdateCompanyInput {}
}
pub struct UpdateJobInput;
impl ::cynic::schema::InputObjectMarker for UpdateJobInput {}
pub mod update_job_input_fields {
    pub struct Id;
    impl ::cynic::schema::Field for Id {
        type Type = super::Id;
        const NAME: &'static str = "id";
    }
    impl ::cynic::schema::HasInputField<Id, super::Id> for super::UpdateJobInput {}
    pub struct Description;
    impl ::cynic::schema::Field for Description {
        type Type = super::String;
        const NAME: &'static str = "description";
    }
    impl ::cynic::schema::HasInputField<Description, super::String> for super::UpdateJobInput {}
}
pub struct User;
pub mod user_fields {
    pub struct Id;
    impl ::cynic::schema::Field for Id {
        type Type = super::Id;
        const NAME: &'static str = "id";
    }
    impl ::cynic::schema::HasField<Id> for super::User {
        type Type = super::Id;
    }
    pub struct Name;
    impl ::cynic::schema::Field for Name {
        type Type = Option<super::String>;
        const NAME: &'static str = "name";
    }
    impl ::cynic::schema::HasField<Name> for super::User {
        type Type = Option<super::String>;
    }
    pub struct Email;
    impl ::cynic::schema::Field for Email {
        type Type = super::String;
        const NAME: &'static str = "email";
    }
    impl ::cynic::schema::HasField<Email> for super::User {
        type Type = super::String;
    }
    pub struct Subscribe;
    impl ::cynic::schema::Field for Subscribe {
        type Type = super::Boolean;
        const NAME: &'static str = "subscribe";
    }
    impl ::cynic::schema::HasField<Subscribe> for super::User {
        type Type = super::Boolean;
    }
    pub struct CreatedAt;
    impl ::cynic::schema::Field for CreatedAt {
        type Type = super::DateTime;
        const NAME: &'static str = "createdAt";
    }
    impl ::cynic::schema::HasField<CreatedAt> for super::User {
        type Type = super::DateTime;
    }
    pub struct UpdatedAt;
    impl ::cynic::schema::Field for UpdatedAt {
        type Type = super::DateTime;
        const NAME: &'static str = "updatedAt";
    }
    impl ::cynic::schema::HasField<UpdatedAt> for super::User {
        type Type = super::DateTime;
    }
}
impl ::cynic::schema::NamedType for City {
    const NAME: &'static str = "City";
}
impl ::cynic::schema::NamedType for Commitment {
    const NAME: &'static str = "Commitment";
}
impl ::cynic::schema::NamedType for Company {
    const NAME: &'static str = "Company";
}
impl ::cynic::schema::NamedType for Country {
    const NAME: &'static str = "Country";
}
impl ::cynic::schema::NamedType for Job {
    const NAME: &'static str = "Job";
}
impl ::cynic::schema::NamedType for Location {
    const NAME: &'static str = "Location";
}
impl ::cynic::schema::NamedType for Mutation {
    const NAME: &'static str = "Mutation";
}
impl ::cynic::schema::NamedType for Query {
    const NAME: &'static str = "Query";
}
impl ::cynic::schema::NamedType for Remote {
    const NAME: &'static str = "Remote";
}
impl ::cynic::schema::NamedType for Tag {
    const NAME: &'static str = "Tag";
}
impl ::cynic::schema::NamedType for User {
    const NAME: &'static str = "User";
}
pub type Boolean = bool;
pub type String = std::string::String;
pub type Float = f64;
pub type Int = i32;
pub type Id = ::cynic::Id;
pub mod variable {
    use cynic::variables::VariableType;
    #[doc = r" Used to determine the type of a given variable that"]
    #[doc = r" appears in an argument struct."]
    pub trait Variable {
        const TYPE: VariableType;
    }
    impl<T> Variable for &T
    where
        T: Variable,
    {
        const TYPE: VariableType = T::TYPE;
    }
    impl<T> Variable for Option<T>
    where
        T: Variable,
    {
        const TYPE: VariableType = VariableType::Nullable(&T::TYPE);
    }
    impl<T> Variable for Vec<T>
    where
        T: Variable,
    {
        const TYPE: VariableType = VariableType::List(&T::TYPE);
    }
    impl<T> Variable for Box<T>
    where
        T: Variable,
    {
        const TYPE: VariableType = T::TYPE;
    }
    impl<T> Variable for std::rc::Rc<T>
    where
        T: Variable,
    {
        const TYPE: VariableType = T::TYPE;
    }
    impl<T> Variable for std::sync::Arc<T>
    where
        T: Variable,
    {
        const TYPE: VariableType = T::TYPE;
    }
    impl Variable for bool {
        const TYPE: VariableType = VariableType::Named("Boolean");
    }
    impl Variable for String {
        const TYPE: VariableType = VariableType::Named("String");
    }
    impl Variable for f64 {
        const TYPE: VariableType = VariableType::Named("Float");
    }
    impl Variable for i32 {
        const TYPE: VariableType = VariableType::Named("Int");
    }
    impl Variable for ::cynic::Id {
        const TYPE: VariableType = VariableType::Named("ID");
    }
}

