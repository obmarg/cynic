---
source: cynic-codegen/tests/use-schema.rs
assertion_line: 25
expression: "format_code(format!(\"{}\", tokens))"

---
impl ::cynic::schema::QueryRoot for Root {}
pub struct Film;
pub mod film_fields {
    pub struct Title;
    impl ::cynic::schema::Field for Title {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "title"
        }
    }
    impl ::cynic::schema::HasField<Title> for super::Film {
        type Type = Option<super::String>;
    }
    pub struct EpisodeId;
    impl ::cynic::schema::Field for EpisodeId {
        type SchemaType = Option<super::Int>;
        fn name() -> &'static str {
            "episodeID"
        }
    }
    impl ::cynic::schema::HasField<EpisodeId> for super::Film {
        type Type = Option<super::Int>;
    }
    pub struct OpeningCrawl;
    impl ::cynic::schema::Field for OpeningCrawl {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "openingCrawl"
        }
    }
    impl ::cynic::schema::HasField<OpeningCrawl> for super::Film {
        type Type = Option<super::String>;
    }
    pub struct Director;
    impl ::cynic::schema::Field for Director {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "director"
        }
    }
    impl ::cynic::schema::HasField<Director> for super::Film {
        type Type = Option<super::String>;
    }
    pub struct Producers;
    impl ::cynic::schema::Field for Producers {
        type SchemaType = Option<Vec<Option<super::String>>>;
        fn name() -> &'static str {
            "producers"
        }
    }
    impl ::cynic::schema::HasField<Producers> for super::Film {
        type Type = Option<Vec<Option<super::String>>>;
    }
    pub struct ReleaseDate;
    impl ::cynic::schema::Field for ReleaseDate {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "releaseDate"
        }
    }
    impl ::cynic::schema::HasField<ReleaseDate> for super::Film {
        type Type = Option<super::String>;
    }
    pub struct SpeciesConnection;
    impl ::cynic::schema::Field for SpeciesConnection {
        type SchemaType = Option<super::FilmSpeciesConnection>;
        fn name() -> &'static str {
            "speciesConnection"
        }
    }
    impl ::cynic::schema::HasField<SpeciesConnection> for super::Film {
        type Type = Option<super::FilmSpeciesConnection>;
    }
    pub mod species_connection_arguments {
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::SpeciesConnection {
            type ArgumentSchemaType = Option<super::super::String>;
            fn name() -> &'static str {
                "after"
            }
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::SpeciesConnection {
            type ArgumentSchemaType = Option<super::super::Int>;
            fn name() -> &'static str {
                "first"
            }
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::SpeciesConnection {
            type ArgumentSchemaType = Option<super::super::String>;
            fn name() -> &'static str {
                "before"
            }
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::SpeciesConnection {
            type ArgumentSchemaType = Option<super::super::Int>;
            fn name() -> &'static str {
                "last"
            }
        }
    }
    pub struct StarshipConnection;
    impl ::cynic::schema::Field for StarshipConnection {
        type SchemaType = Option<super::FilmStarshipsConnection>;
        fn name() -> &'static str {
            "starshipConnection"
        }
    }
    impl ::cynic::schema::HasField<StarshipConnection> for super::Film {
        type Type = Option<super::FilmStarshipsConnection>;
    }
    pub mod starship_connection_arguments {
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::StarshipConnection {
            type ArgumentSchemaType = Option<super::super::String>;
            fn name() -> &'static str {
                "after"
            }
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::StarshipConnection {
            type ArgumentSchemaType = Option<super::super::Int>;
            fn name() -> &'static str {
                "first"
            }
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::StarshipConnection {
            type ArgumentSchemaType = Option<super::super::String>;
            fn name() -> &'static str {
                "before"
            }
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::StarshipConnection {
            type ArgumentSchemaType = Option<super::super::Int>;
            fn name() -> &'static str {
                "last"
            }
        }
    }
    pub struct VehicleConnection;
    impl ::cynic::schema::Field for VehicleConnection {
        type SchemaType = Option<super::FilmVehiclesConnection>;
        fn name() -> &'static str {
            "vehicleConnection"
        }
    }
    impl ::cynic::schema::HasField<VehicleConnection> for super::Film {
        type Type = Option<super::FilmVehiclesConnection>;
    }
    pub mod vehicle_connection_arguments {
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::VehicleConnection {
            type ArgumentSchemaType = Option<super::super::String>;
            fn name() -> &'static str {
                "after"
            }
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::VehicleConnection {
            type ArgumentSchemaType = Option<super::super::Int>;
            fn name() -> &'static str {
                "first"
            }
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::VehicleConnection {
            type ArgumentSchemaType = Option<super::super::String>;
            fn name() -> &'static str {
                "before"
            }
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::VehicleConnection {
            type ArgumentSchemaType = Option<super::super::Int>;
            fn name() -> &'static str {
                "last"
            }
        }
    }
    pub struct CharacterConnection;
    impl ::cynic::schema::Field for CharacterConnection {
        type SchemaType = Option<super::FilmCharactersConnection>;
        fn name() -> &'static str {
            "characterConnection"
        }
    }
    impl ::cynic::schema::HasField<CharacterConnection> for super::Film {
        type Type = Option<super::FilmCharactersConnection>;
    }
    pub mod character_connection_arguments {
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::CharacterConnection {
            type ArgumentSchemaType = Option<super::super::String>;
            fn name() -> &'static str {
                "after"
            }
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::CharacterConnection {
            type ArgumentSchemaType = Option<super::super::Int>;
            fn name() -> &'static str {
                "first"
            }
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::CharacterConnection {
            type ArgumentSchemaType = Option<super::super::String>;
            fn name() -> &'static str {
                "before"
            }
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::CharacterConnection {
            type ArgumentSchemaType = Option<super::super::Int>;
            fn name() -> &'static str {
                "last"
            }
        }
    }
    pub struct PlanetConnection;
    impl ::cynic::schema::Field for PlanetConnection {
        type SchemaType = Option<super::FilmPlanetsConnection>;
        fn name() -> &'static str {
            "planetConnection"
        }
    }
    impl ::cynic::schema::HasField<PlanetConnection> for super::Film {
        type Type = Option<super::FilmPlanetsConnection>;
    }
    pub mod planet_connection_arguments {
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::PlanetConnection {
            type ArgumentSchemaType = Option<super::super::String>;
            fn name() -> &'static str {
                "after"
            }
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::PlanetConnection {
            type ArgumentSchemaType = Option<super::super::Int>;
            fn name() -> &'static str {
                "first"
            }
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::PlanetConnection {
            type ArgumentSchemaType = Option<super::super::String>;
            fn name() -> &'static str {
                "before"
            }
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::PlanetConnection {
            type ArgumentSchemaType = Option<super::super::Int>;
            fn name() -> &'static str {
                "last"
            }
        }
    }
    pub struct Created;
    impl ::cynic::schema::Field for Created {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "created"
        }
    }
    impl ::cynic::schema::HasField<Created> for super::Film {
        type Type = Option<super::String>;
    }
    pub struct Edited;
    impl ::cynic::schema::Field for Edited {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "edited"
        }
    }
    impl ::cynic::schema::HasField<Edited> for super::Film {
        type Type = Option<super::String>;
    }
    pub struct Id;
    impl ::cynic::schema::Field for Id {
        type SchemaType = super::Id;
        fn name() -> &'static str {
            "id"
        }
    }
    impl ::cynic::schema::HasField<Id> for super::Film {
        type Type = super::Id;
    }
}
pub struct FilmCharactersConnection;
pub mod film_characters_connection_fields {
    pub struct PageInfo;
    impl ::cynic::schema::Field for PageInfo {
        type SchemaType = super::PageInfo;
        fn name() -> &'static str {
            "pageInfo"
        }
    }
    impl ::cynic::schema::HasField<PageInfo> for super::FilmCharactersConnection {
        type Type = super::PageInfo;
    }
    pub struct Edges;
    impl ::cynic::schema::Field for Edges {
        type SchemaType = Option<Vec<Option<super::FilmCharactersEdge>>>;
        fn name() -> &'static str {
            "edges"
        }
    }
    impl ::cynic::schema::HasField<Edges> for super::FilmCharactersConnection {
        type Type = Option<Vec<Option<super::FilmCharactersEdge>>>;
    }
    pub struct TotalCount;
    impl ::cynic::schema::Field for TotalCount {
        type SchemaType = Option<super::Int>;
        fn name() -> &'static str {
            "totalCount"
        }
    }
    impl ::cynic::schema::HasField<TotalCount> for super::FilmCharactersConnection {
        type Type = Option<super::Int>;
    }
    pub struct Characters;
    impl ::cynic::schema::Field for Characters {
        type SchemaType = Option<Vec<Option<super::Person>>>;
        fn name() -> &'static str {
            "characters"
        }
    }
    impl ::cynic::schema::HasField<Characters> for super::FilmCharactersConnection {
        type Type = Option<Vec<Option<super::Person>>>;
    }
}
pub struct FilmCharactersEdge;
pub mod film_characters_edge_fields {
    pub struct Node;
    impl ::cynic::schema::Field for Node {
        type SchemaType = Option<super::Person>;
        fn name() -> &'static str {
            "node"
        }
    }
    impl ::cynic::schema::HasField<Node> for super::FilmCharactersEdge {
        type Type = Option<super::Person>;
    }
    pub struct Cursor;
    impl ::cynic::schema::Field for Cursor {
        type SchemaType = super::String;
        fn name() -> &'static str {
            "cursor"
        }
    }
    impl ::cynic::schema::HasField<Cursor> for super::FilmCharactersEdge {
        type Type = super::String;
    }
}
pub struct FilmPlanetsConnection;
pub mod film_planets_connection_fields {
    pub struct PageInfo;
    impl ::cynic::schema::Field for PageInfo {
        type SchemaType = super::PageInfo;
        fn name() -> &'static str {
            "pageInfo"
        }
    }
    impl ::cynic::schema::HasField<PageInfo> for super::FilmPlanetsConnection {
        type Type = super::PageInfo;
    }
    pub struct Edges;
    impl ::cynic::schema::Field for Edges {
        type SchemaType = Option<Vec<Option<super::FilmPlanetsEdge>>>;
        fn name() -> &'static str {
            "edges"
        }
    }
    impl ::cynic::schema::HasField<Edges> for super::FilmPlanetsConnection {
        type Type = Option<Vec<Option<super::FilmPlanetsEdge>>>;
    }
    pub struct TotalCount;
    impl ::cynic::schema::Field for TotalCount {
        type SchemaType = Option<super::Int>;
        fn name() -> &'static str {
            "totalCount"
        }
    }
    impl ::cynic::schema::HasField<TotalCount> for super::FilmPlanetsConnection {
        type Type = Option<super::Int>;
    }
    pub struct Planets;
    impl ::cynic::schema::Field for Planets {
        type SchemaType = Option<Vec<Option<super::Planet>>>;
        fn name() -> &'static str {
            "planets"
        }
    }
    impl ::cynic::schema::HasField<Planets> for super::FilmPlanetsConnection {
        type Type = Option<Vec<Option<super::Planet>>>;
    }
}
pub struct FilmPlanetsEdge;
pub mod film_planets_edge_fields {
    pub struct Node;
    impl ::cynic::schema::Field for Node {
        type SchemaType = Option<super::Planet>;
        fn name() -> &'static str {
            "node"
        }
    }
    impl ::cynic::schema::HasField<Node> for super::FilmPlanetsEdge {
        type Type = Option<super::Planet>;
    }
    pub struct Cursor;
    impl ::cynic::schema::Field for Cursor {
        type SchemaType = super::String;
        fn name() -> &'static str {
            "cursor"
        }
    }
    impl ::cynic::schema::HasField<Cursor> for super::FilmPlanetsEdge {
        type Type = super::String;
    }
}
pub struct FilmSpeciesConnection;
pub mod film_species_connection_fields {
    pub struct PageInfo;
    impl ::cynic::schema::Field for PageInfo {
        type SchemaType = super::PageInfo;
        fn name() -> &'static str {
            "pageInfo"
        }
    }
    impl ::cynic::schema::HasField<PageInfo> for super::FilmSpeciesConnection {
        type Type = super::PageInfo;
    }
    pub struct Edges;
    impl ::cynic::schema::Field for Edges {
        type SchemaType = Option<Vec<Option<super::FilmSpeciesEdge>>>;
        fn name() -> &'static str {
            "edges"
        }
    }
    impl ::cynic::schema::HasField<Edges> for super::FilmSpeciesConnection {
        type Type = Option<Vec<Option<super::FilmSpeciesEdge>>>;
    }
    pub struct TotalCount;
    impl ::cynic::schema::Field for TotalCount {
        type SchemaType = Option<super::Int>;
        fn name() -> &'static str {
            "totalCount"
        }
    }
    impl ::cynic::schema::HasField<TotalCount> for super::FilmSpeciesConnection {
        type Type = Option<super::Int>;
    }
    pub struct Species;
    impl ::cynic::schema::Field for Species {
        type SchemaType = Option<Vec<Option<super::Species>>>;
        fn name() -> &'static str {
            "species"
        }
    }
    impl ::cynic::schema::HasField<Species> for super::FilmSpeciesConnection {
        type Type = Option<Vec<Option<super::Species>>>;
    }
}
pub struct FilmSpeciesEdge;
pub mod film_species_edge_fields {
    pub struct Node;
    impl ::cynic::schema::Field for Node {
        type SchemaType = Option<super::Species>;
        fn name() -> &'static str {
            "node"
        }
    }
    impl ::cynic::schema::HasField<Node> for super::FilmSpeciesEdge {
        type Type = Option<super::Species>;
    }
    pub struct Cursor;
    impl ::cynic::schema::Field for Cursor {
        type SchemaType = super::String;
        fn name() -> &'static str {
            "cursor"
        }
    }
    impl ::cynic::schema::HasField<Cursor> for super::FilmSpeciesEdge {
        type Type = super::String;
    }
}
pub struct FilmStarshipsConnection;
pub mod film_starships_connection_fields {
    pub struct PageInfo;
    impl ::cynic::schema::Field for PageInfo {
        type SchemaType = super::PageInfo;
        fn name() -> &'static str {
            "pageInfo"
        }
    }
    impl ::cynic::schema::HasField<PageInfo> for super::FilmStarshipsConnection {
        type Type = super::PageInfo;
    }
    pub struct Edges;
    impl ::cynic::schema::Field for Edges {
        type SchemaType = Option<Vec<Option<super::FilmStarshipsEdge>>>;
        fn name() -> &'static str {
            "edges"
        }
    }
    impl ::cynic::schema::HasField<Edges> for super::FilmStarshipsConnection {
        type Type = Option<Vec<Option<super::FilmStarshipsEdge>>>;
    }
    pub struct TotalCount;
    impl ::cynic::schema::Field for TotalCount {
        type SchemaType = Option<super::Int>;
        fn name() -> &'static str {
            "totalCount"
        }
    }
    impl ::cynic::schema::HasField<TotalCount> for super::FilmStarshipsConnection {
        type Type = Option<super::Int>;
    }
    pub struct Starships;
    impl ::cynic::schema::Field for Starships {
        type SchemaType = Option<Vec<Option<super::Starship>>>;
        fn name() -> &'static str {
            "starships"
        }
    }
    impl ::cynic::schema::HasField<Starships> for super::FilmStarshipsConnection {
        type Type = Option<Vec<Option<super::Starship>>>;
    }
}
pub struct FilmStarshipsEdge;
pub mod film_starships_edge_fields {
    pub struct Node;
    impl ::cynic::schema::Field for Node {
        type SchemaType = Option<super::Starship>;
        fn name() -> &'static str {
            "node"
        }
    }
    impl ::cynic::schema::HasField<Node> for super::FilmStarshipsEdge {
        type Type = Option<super::Starship>;
    }
    pub struct Cursor;
    impl ::cynic::schema::Field for Cursor {
        type SchemaType = super::String;
        fn name() -> &'static str {
            "cursor"
        }
    }
    impl ::cynic::schema::HasField<Cursor> for super::FilmStarshipsEdge {
        type Type = super::String;
    }
}
pub struct FilmVehiclesConnection;
pub mod film_vehicles_connection_fields {
    pub struct PageInfo;
    impl ::cynic::schema::Field for PageInfo {
        type SchemaType = super::PageInfo;
        fn name() -> &'static str {
            "pageInfo"
        }
    }
    impl ::cynic::schema::HasField<PageInfo> for super::FilmVehiclesConnection {
        type Type = super::PageInfo;
    }
    pub struct Edges;
    impl ::cynic::schema::Field for Edges {
        type SchemaType = Option<Vec<Option<super::FilmVehiclesEdge>>>;
        fn name() -> &'static str {
            "edges"
        }
    }
    impl ::cynic::schema::HasField<Edges> for super::FilmVehiclesConnection {
        type Type = Option<Vec<Option<super::FilmVehiclesEdge>>>;
    }
    pub struct TotalCount;
    impl ::cynic::schema::Field for TotalCount {
        type SchemaType = Option<super::Int>;
        fn name() -> &'static str {
            "totalCount"
        }
    }
    impl ::cynic::schema::HasField<TotalCount> for super::FilmVehiclesConnection {
        type Type = Option<super::Int>;
    }
    pub struct Vehicles;
    impl ::cynic::schema::Field for Vehicles {
        type SchemaType = Option<Vec<Option<super::Vehicle>>>;
        fn name() -> &'static str {
            "vehicles"
        }
    }
    impl ::cynic::schema::HasField<Vehicles> for super::FilmVehiclesConnection {
        type Type = Option<Vec<Option<super::Vehicle>>>;
    }
}
pub struct FilmVehiclesEdge;
pub mod film_vehicles_edge_fields {
    pub struct Node;
    impl ::cynic::schema::Field for Node {
        type SchemaType = Option<super::Vehicle>;
        fn name() -> &'static str {
            "node"
        }
    }
    impl ::cynic::schema::HasField<Node> for super::FilmVehiclesEdge {
        type Type = Option<super::Vehicle>;
    }
    pub struct Cursor;
    impl ::cynic::schema::Field for Cursor {
        type SchemaType = super::String;
        fn name() -> &'static str {
            "cursor"
        }
    }
    impl ::cynic::schema::HasField<Cursor> for super::FilmVehiclesEdge {
        type Type = super::String;
    }
}
pub struct FilmsConnection;
pub mod films_connection_fields {
    pub struct PageInfo;
    impl ::cynic::schema::Field for PageInfo {
        type SchemaType = super::PageInfo;
        fn name() -> &'static str {
            "pageInfo"
        }
    }
    impl ::cynic::schema::HasField<PageInfo> for super::FilmsConnection {
        type Type = super::PageInfo;
    }
    pub struct Edges;
    impl ::cynic::schema::Field for Edges {
        type SchemaType = Option<Vec<Option<super::FilmsEdge>>>;
        fn name() -> &'static str {
            "edges"
        }
    }
    impl ::cynic::schema::HasField<Edges> for super::FilmsConnection {
        type Type = Option<Vec<Option<super::FilmsEdge>>>;
    }
    pub struct TotalCount;
    impl ::cynic::schema::Field for TotalCount {
        type SchemaType = Option<super::Int>;
        fn name() -> &'static str {
            "totalCount"
        }
    }
    impl ::cynic::schema::HasField<TotalCount> for super::FilmsConnection {
        type Type = Option<super::Int>;
    }
    pub struct Films;
    impl ::cynic::schema::Field for Films {
        type SchemaType = Option<Vec<Option<super::Film>>>;
        fn name() -> &'static str {
            "films"
        }
    }
    impl ::cynic::schema::HasField<Films> for super::FilmsConnection {
        type Type = Option<Vec<Option<super::Film>>>;
    }
}
pub struct FilmsEdge;
pub mod films_edge_fields {
    pub struct Node;
    impl ::cynic::schema::Field for Node {
        type SchemaType = Option<super::Film>;
        fn name() -> &'static str {
            "node"
        }
    }
    impl ::cynic::schema::HasField<Node> for super::FilmsEdge {
        type Type = Option<super::Film>;
    }
    pub struct Cursor;
    impl ::cynic::schema::Field for Cursor {
        type SchemaType = super::String;
        fn name() -> &'static str {
            "cursor"
        }
    }
    impl ::cynic::schema::HasField<Cursor> for super::FilmsEdge {
        type Type = super::String;
    }
}
pub struct Node;
pub mod node_fields {
    pub struct Id;
    impl ::cynic::schema::Field for Id {
        type SchemaType = super::Id;
        fn name() -> &'static str {
            "id"
        }
    }
    impl ::cynic::schema::HasField<Id> for super::Node {
        type Type = super::Id;
    }
}
pub struct PageInfo;
pub mod page_info_fields {
    pub struct HasNextPage;
    impl ::cynic::schema::Field for HasNextPage {
        type SchemaType = super::Boolean;
        fn name() -> &'static str {
            "hasNextPage"
        }
    }
    impl ::cynic::schema::HasField<HasNextPage> for super::PageInfo {
        type Type = super::Boolean;
    }
    pub struct HasPreviousPage;
    impl ::cynic::schema::Field for HasPreviousPage {
        type SchemaType = super::Boolean;
        fn name() -> &'static str {
            "hasPreviousPage"
        }
    }
    impl ::cynic::schema::HasField<HasPreviousPage> for super::PageInfo {
        type Type = super::Boolean;
    }
    pub struct StartCursor;
    impl ::cynic::schema::Field for StartCursor {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "startCursor"
        }
    }
    impl ::cynic::schema::HasField<StartCursor> for super::PageInfo {
        type Type = Option<super::String>;
    }
    pub struct EndCursor;
    impl ::cynic::schema::Field for EndCursor {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "endCursor"
        }
    }
    impl ::cynic::schema::HasField<EndCursor> for super::PageInfo {
        type Type = Option<super::String>;
    }
}
pub struct PeopleConnection;
pub mod people_connection_fields {
    pub struct PageInfo;
    impl ::cynic::schema::Field for PageInfo {
        type SchemaType = super::PageInfo;
        fn name() -> &'static str {
            "pageInfo"
        }
    }
    impl ::cynic::schema::HasField<PageInfo> for super::PeopleConnection {
        type Type = super::PageInfo;
    }
    pub struct Edges;
    impl ::cynic::schema::Field for Edges {
        type SchemaType = Option<Vec<Option<super::PeopleEdge>>>;
        fn name() -> &'static str {
            "edges"
        }
    }
    impl ::cynic::schema::HasField<Edges> for super::PeopleConnection {
        type Type = Option<Vec<Option<super::PeopleEdge>>>;
    }
    pub struct TotalCount;
    impl ::cynic::schema::Field for TotalCount {
        type SchemaType = Option<super::Int>;
        fn name() -> &'static str {
            "totalCount"
        }
    }
    impl ::cynic::schema::HasField<TotalCount> for super::PeopleConnection {
        type Type = Option<super::Int>;
    }
    pub struct People;
    impl ::cynic::schema::Field for People {
        type SchemaType = Option<Vec<Option<super::Person>>>;
        fn name() -> &'static str {
            "people"
        }
    }
    impl ::cynic::schema::HasField<People> for super::PeopleConnection {
        type Type = Option<Vec<Option<super::Person>>>;
    }
}
pub struct PeopleEdge;
pub mod people_edge_fields {
    pub struct Node;
    impl ::cynic::schema::Field for Node {
        type SchemaType = Option<super::Person>;
        fn name() -> &'static str {
            "node"
        }
    }
    impl ::cynic::schema::HasField<Node> for super::PeopleEdge {
        type Type = Option<super::Person>;
    }
    pub struct Cursor;
    impl ::cynic::schema::Field for Cursor {
        type SchemaType = super::String;
        fn name() -> &'static str {
            "cursor"
        }
    }
    impl ::cynic::schema::HasField<Cursor> for super::PeopleEdge {
        type Type = super::String;
    }
}
pub struct Person;
pub mod person_fields {
    pub struct Name;
    impl ::cynic::schema::Field for Name {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "name"
        }
    }
    impl ::cynic::schema::HasField<Name> for super::Person {
        type Type = Option<super::String>;
    }
    pub struct BirthYear;
    impl ::cynic::schema::Field for BirthYear {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "birthYear"
        }
    }
    impl ::cynic::schema::HasField<BirthYear> for super::Person {
        type Type = Option<super::String>;
    }
    pub struct EyeColor;
    impl ::cynic::schema::Field for EyeColor {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "eyeColor"
        }
    }
    impl ::cynic::schema::HasField<EyeColor> for super::Person {
        type Type = Option<super::String>;
    }
    pub struct Gender;
    impl ::cynic::schema::Field for Gender {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "gender"
        }
    }
    impl ::cynic::schema::HasField<Gender> for super::Person {
        type Type = Option<super::String>;
    }
    pub struct HairColor;
    impl ::cynic::schema::Field for HairColor {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "hairColor"
        }
    }
    impl ::cynic::schema::HasField<HairColor> for super::Person {
        type Type = Option<super::String>;
    }
    pub struct Height;
    impl ::cynic::schema::Field for Height {
        type SchemaType = Option<super::Int>;
        fn name() -> &'static str {
            "height"
        }
    }
    impl ::cynic::schema::HasField<Height> for super::Person {
        type Type = Option<super::Int>;
    }
    pub struct Mass;
    impl ::cynic::schema::Field for Mass {
        type SchemaType = Option<super::Float>;
        fn name() -> &'static str {
            "mass"
        }
    }
    impl ::cynic::schema::HasField<Mass> for super::Person {
        type Type = Option<super::Float>;
    }
    pub struct SkinColor;
    impl ::cynic::schema::Field for SkinColor {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "skinColor"
        }
    }
    impl ::cynic::schema::HasField<SkinColor> for super::Person {
        type Type = Option<super::String>;
    }
    pub struct Homeworld;
    impl ::cynic::schema::Field for Homeworld {
        type SchemaType = Option<super::Planet>;
        fn name() -> &'static str {
            "homeworld"
        }
    }
    impl ::cynic::schema::HasField<Homeworld> for super::Person {
        type Type = Option<super::Planet>;
    }
    pub struct FilmConnection;
    impl ::cynic::schema::Field for FilmConnection {
        type SchemaType = Option<super::PersonFilmsConnection>;
        fn name() -> &'static str {
            "filmConnection"
        }
    }
    impl ::cynic::schema::HasField<FilmConnection> for super::Person {
        type Type = Option<super::PersonFilmsConnection>;
    }
    pub mod film_connection_arguments {
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::FilmConnection {
            type ArgumentSchemaType = Option<super::super::String>;
            fn name() -> &'static str {
                "after"
            }
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::FilmConnection {
            type ArgumentSchemaType = Option<super::super::Int>;
            fn name() -> &'static str {
                "first"
            }
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::FilmConnection {
            type ArgumentSchemaType = Option<super::super::String>;
            fn name() -> &'static str {
                "before"
            }
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::FilmConnection {
            type ArgumentSchemaType = Option<super::super::Int>;
            fn name() -> &'static str {
                "last"
            }
        }
    }
    pub struct Species;
    impl ::cynic::schema::Field for Species {
        type SchemaType = Option<super::Species>;
        fn name() -> &'static str {
            "species"
        }
    }
    impl ::cynic::schema::HasField<Species> for super::Person {
        type Type = Option<super::Species>;
    }
    pub struct StarshipConnection;
    impl ::cynic::schema::Field for StarshipConnection {
        type SchemaType = Option<super::PersonStarshipsConnection>;
        fn name() -> &'static str {
            "starshipConnection"
        }
    }
    impl ::cynic::schema::HasField<StarshipConnection> for super::Person {
        type Type = Option<super::PersonStarshipsConnection>;
    }
    pub mod starship_connection_arguments {
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::StarshipConnection {
            type ArgumentSchemaType = Option<super::super::String>;
            fn name() -> &'static str {
                "after"
            }
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::StarshipConnection {
            type ArgumentSchemaType = Option<super::super::Int>;
            fn name() -> &'static str {
                "first"
            }
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::StarshipConnection {
            type ArgumentSchemaType = Option<super::super::String>;
            fn name() -> &'static str {
                "before"
            }
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::StarshipConnection {
            type ArgumentSchemaType = Option<super::super::Int>;
            fn name() -> &'static str {
                "last"
            }
        }
    }
    pub struct VehicleConnection;
    impl ::cynic::schema::Field for VehicleConnection {
        type SchemaType = Option<super::PersonVehiclesConnection>;
        fn name() -> &'static str {
            "vehicleConnection"
        }
    }
    impl ::cynic::schema::HasField<VehicleConnection> for super::Person {
        type Type = Option<super::PersonVehiclesConnection>;
    }
    pub mod vehicle_connection_arguments {
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::VehicleConnection {
            type ArgumentSchemaType = Option<super::super::String>;
            fn name() -> &'static str {
                "after"
            }
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::VehicleConnection {
            type ArgumentSchemaType = Option<super::super::Int>;
            fn name() -> &'static str {
                "first"
            }
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::VehicleConnection {
            type ArgumentSchemaType = Option<super::super::String>;
            fn name() -> &'static str {
                "before"
            }
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::VehicleConnection {
            type ArgumentSchemaType = Option<super::super::Int>;
            fn name() -> &'static str {
                "last"
            }
        }
    }
    pub struct Created;
    impl ::cynic::schema::Field for Created {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "created"
        }
    }
    impl ::cynic::schema::HasField<Created> for super::Person {
        type Type = Option<super::String>;
    }
    pub struct Edited;
    impl ::cynic::schema::Field for Edited {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "edited"
        }
    }
    impl ::cynic::schema::HasField<Edited> for super::Person {
        type Type = Option<super::String>;
    }
    pub struct Id;
    impl ::cynic::schema::Field for Id {
        type SchemaType = super::Id;
        fn name() -> &'static str {
            "id"
        }
    }
    impl ::cynic::schema::HasField<Id> for super::Person {
        type Type = super::Id;
    }
}
pub struct PersonFilmsConnection;
pub mod person_films_connection_fields {
    pub struct PageInfo;
    impl ::cynic::schema::Field for PageInfo {
        type SchemaType = super::PageInfo;
        fn name() -> &'static str {
            "pageInfo"
        }
    }
    impl ::cynic::schema::HasField<PageInfo> for super::PersonFilmsConnection {
        type Type = super::PageInfo;
    }
    pub struct Edges;
    impl ::cynic::schema::Field for Edges {
        type SchemaType = Option<Vec<Option<super::PersonFilmsEdge>>>;
        fn name() -> &'static str {
            "edges"
        }
    }
    impl ::cynic::schema::HasField<Edges> for super::PersonFilmsConnection {
        type Type = Option<Vec<Option<super::PersonFilmsEdge>>>;
    }
    pub struct TotalCount;
    impl ::cynic::schema::Field for TotalCount {
        type SchemaType = Option<super::Int>;
        fn name() -> &'static str {
            "totalCount"
        }
    }
    impl ::cynic::schema::HasField<TotalCount> for super::PersonFilmsConnection {
        type Type = Option<super::Int>;
    }
    pub struct Films;
    impl ::cynic::schema::Field for Films {
        type SchemaType = Option<Vec<Option<super::Film>>>;
        fn name() -> &'static str {
            "films"
        }
    }
    impl ::cynic::schema::HasField<Films> for super::PersonFilmsConnection {
        type Type = Option<Vec<Option<super::Film>>>;
    }
}
pub struct PersonFilmsEdge;
pub mod person_films_edge_fields {
    pub struct Node;
    impl ::cynic::schema::Field for Node {
        type SchemaType = Option<super::Film>;
        fn name() -> &'static str {
            "node"
        }
    }
    impl ::cynic::schema::HasField<Node> for super::PersonFilmsEdge {
        type Type = Option<super::Film>;
    }
    pub struct Cursor;
    impl ::cynic::schema::Field for Cursor {
        type SchemaType = super::String;
        fn name() -> &'static str {
            "cursor"
        }
    }
    impl ::cynic::schema::HasField<Cursor> for super::PersonFilmsEdge {
        type Type = super::String;
    }
}
pub struct PersonStarshipsConnection;
pub mod person_starships_connection_fields {
    pub struct PageInfo;
    impl ::cynic::schema::Field for PageInfo {
        type SchemaType = super::PageInfo;
        fn name() -> &'static str {
            "pageInfo"
        }
    }
    impl ::cynic::schema::HasField<PageInfo> for super::PersonStarshipsConnection {
        type Type = super::PageInfo;
    }
    pub struct Edges;
    impl ::cynic::schema::Field for Edges {
        type SchemaType = Option<Vec<Option<super::PersonStarshipsEdge>>>;
        fn name() -> &'static str {
            "edges"
        }
    }
    impl ::cynic::schema::HasField<Edges> for super::PersonStarshipsConnection {
        type Type = Option<Vec<Option<super::PersonStarshipsEdge>>>;
    }
    pub struct TotalCount;
    impl ::cynic::schema::Field for TotalCount {
        type SchemaType = Option<super::Int>;
        fn name() -> &'static str {
            "totalCount"
        }
    }
    impl ::cynic::schema::HasField<TotalCount> for super::PersonStarshipsConnection {
        type Type = Option<super::Int>;
    }
    pub struct Starships;
    impl ::cynic::schema::Field for Starships {
        type SchemaType = Option<Vec<Option<super::Starship>>>;
        fn name() -> &'static str {
            "starships"
        }
    }
    impl ::cynic::schema::HasField<Starships> for super::PersonStarshipsConnection {
        type Type = Option<Vec<Option<super::Starship>>>;
    }
}
pub struct PersonStarshipsEdge;
pub mod person_starships_edge_fields {
    pub struct Node;
    impl ::cynic::schema::Field for Node {
        type SchemaType = Option<super::Starship>;
        fn name() -> &'static str {
            "node"
        }
    }
    impl ::cynic::schema::HasField<Node> for super::PersonStarshipsEdge {
        type Type = Option<super::Starship>;
    }
    pub struct Cursor;
    impl ::cynic::schema::Field for Cursor {
        type SchemaType = super::String;
        fn name() -> &'static str {
            "cursor"
        }
    }
    impl ::cynic::schema::HasField<Cursor> for super::PersonStarshipsEdge {
        type Type = super::String;
    }
}
pub struct PersonVehiclesConnection;
pub mod person_vehicles_connection_fields {
    pub struct PageInfo;
    impl ::cynic::schema::Field for PageInfo {
        type SchemaType = super::PageInfo;
        fn name() -> &'static str {
            "pageInfo"
        }
    }
    impl ::cynic::schema::HasField<PageInfo> for super::PersonVehiclesConnection {
        type Type = super::PageInfo;
    }
    pub struct Edges;
    impl ::cynic::schema::Field for Edges {
        type SchemaType = Option<Vec<Option<super::PersonVehiclesEdge>>>;
        fn name() -> &'static str {
            "edges"
        }
    }
    impl ::cynic::schema::HasField<Edges> for super::PersonVehiclesConnection {
        type Type = Option<Vec<Option<super::PersonVehiclesEdge>>>;
    }
    pub struct TotalCount;
    impl ::cynic::schema::Field for TotalCount {
        type SchemaType = Option<super::Int>;
        fn name() -> &'static str {
            "totalCount"
        }
    }
    impl ::cynic::schema::HasField<TotalCount> for super::PersonVehiclesConnection {
        type Type = Option<super::Int>;
    }
    pub struct Vehicles;
    impl ::cynic::schema::Field for Vehicles {
        type SchemaType = Option<Vec<Option<super::Vehicle>>>;
        fn name() -> &'static str {
            "vehicles"
        }
    }
    impl ::cynic::schema::HasField<Vehicles> for super::PersonVehiclesConnection {
        type Type = Option<Vec<Option<super::Vehicle>>>;
    }
}
pub struct PersonVehiclesEdge;
pub mod person_vehicles_edge_fields {
    pub struct Node;
    impl ::cynic::schema::Field for Node {
        type SchemaType = Option<super::Vehicle>;
        fn name() -> &'static str {
            "node"
        }
    }
    impl ::cynic::schema::HasField<Node> for super::PersonVehiclesEdge {
        type Type = Option<super::Vehicle>;
    }
    pub struct Cursor;
    impl ::cynic::schema::Field for Cursor {
        type SchemaType = super::String;
        fn name() -> &'static str {
            "cursor"
        }
    }
    impl ::cynic::schema::HasField<Cursor> for super::PersonVehiclesEdge {
        type Type = super::String;
    }
}
pub struct Planet;
pub mod planet_fields {
    pub struct Name;
    impl ::cynic::schema::Field for Name {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "name"
        }
    }
    impl ::cynic::schema::HasField<Name> for super::Planet {
        type Type = Option<super::String>;
    }
    pub struct Diameter;
    impl ::cynic::schema::Field for Diameter {
        type SchemaType = Option<super::Int>;
        fn name() -> &'static str {
            "diameter"
        }
    }
    impl ::cynic::schema::HasField<Diameter> for super::Planet {
        type Type = Option<super::Int>;
    }
    pub struct RotationPeriod;
    impl ::cynic::schema::Field for RotationPeriod {
        type SchemaType = Option<super::Int>;
        fn name() -> &'static str {
            "rotationPeriod"
        }
    }
    impl ::cynic::schema::HasField<RotationPeriod> for super::Planet {
        type Type = Option<super::Int>;
    }
    pub struct OrbitalPeriod;
    impl ::cynic::schema::Field for OrbitalPeriod {
        type SchemaType = Option<super::Int>;
        fn name() -> &'static str {
            "orbitalPeriod"
        }
    }
    impl ::cynic::schema::HasField<OrbitalPeriod> for super::Planet {
        type Type = Option<super::Int>;
    }
    pub struct Gravity;
    impl ::cynic::schema::Field for Gravity {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "gravity"
        }
    }
    impl ::cynic::schema::HasField<Gravity> for super::Planet {
        type Type = Option<super::String>;
    }
    pub struct Population;
    impl ::cynic::schema::Field for Population {
        type SchemaType = Option<super::Float>;
        fn name() -> &'static str {
            "population"
        }
    }
    impl ::cynic::schema::HasField<Population> for super::Planet {
        type Type = Option<super::Float>;
    }
    pub struct Climates;
    impl ::cynic::schema::Field for Climates {
        type SchemaType = Option<Vec<Option<super::String>>>;
        fn name() -> &'static str {
            "climates"
        }
    }
    impl ::cynic::schema::HasField<Climates> for super::Planet {
        type Type = Option<Vec<Option<super::String>>>;
    }
    pub struct Terrains;
    impl ::cynic::schema::Field for Terrains {
        type SchemaType = Option<Vec<Option<super::String>>>;
        fn name() -> &'static str {
            "terrains"
        }
    }
    impl ::cynic::schema::HasField<Terrains> for super::Planet {
        type Type = Option<Vec<Option<super::String>>>;
    }
    pub struct SurfaceWater;
    impl ::cynic::schema::Field for SurfaceWater {
        type SchemaType = Option<super::Float>;
        fn name() -> &'static str {
            "surfaceWater"
        }
    }
    impl ::cynic::schema::HasField<SurfaceWater> for super::Planet {
        type Type = Option<super::Float>;
    }
    pub struct ResidentConnection;
    impl ::cynic::schema::Field for ResidentConnection {
        type SchemaType = Option<super::PlanetResidentsConnection>;
        fn name() -> &'static str {
            "residentConnection"
        }
    }
    impl ::cynic::schema::HasField<ResidentConnection> for super::Planet {
        type Type = Option<super::PlanetResidentsConnection>;
    }
    pub mod resident_connection_arguments {
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::ResidentConnection {
            type ArgumentSchemaType = Option<super::super::String>;
            fn name() -> &'static str {
                "after"
            }
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::ResidentConnection {
            type ArgumentSchemaType = Option<super::super::Int>;
            fn name() -> &'static str {
                "first"
            }
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::ResidentConnection {
            type ArgumentSchemaType = Option<super::super::String>;
            fn name() -> &'static str {
                "before"
            }
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::ResidentConnection {
            type ArgumentSchemaType = Option<super::super::Int>;
            fn name() -> &'static str {
                "last"
            }
        }
    }
    pub struct FilmConnection;
    impl ::cynic::schema::Field for FilmConnection {
        type SchemaType = Option<super::PlanetFilmsConnection>;
        fn name() -> &'static str {
            "filmConnection"
        }
    }
    impl ::cynic::schema::HasField<FilmConnection> for super::Planet {
        type Type = Option<super::PlanetFilmsConnection>;
    }
    pub mod film_connection_arguments {
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::FilmConnection {
            type ArgumentSchemaType = Option<super::super::String>;
            fn name() -> &'static str {
                "after"
            }
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::FilmConnection {
            type ArgumentSchemaType = Option<super::super::Int>;
            fn name() -> &'static str {
                "first"
            }
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::FilmConnection {
            type ArgumentSchemaType = Option<super::super::String>;
            fn name() -> &'static str {
                "before"
            }
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::FilmConnection {
            type ArgumentSchemaType = Option<super::super::Int>;
            fn name() -> &'static str {
                "last"
            }
        }
    }
    pub struct Created;
    impl ::cynic::schema::Field for Created {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "created"
        }
    }
    impl ::cynic::schema::HasField<Created> for super::Planet {
        type Type = Option<super::String>;
    }
    pub struct Edited;
    impl ::cynic::schema::Field for Edited {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "edited"
        }
    }
    impl ::cynic::schema::HasField<Edited> for super::Planet {
        type Type = Option<super::String>;
    }
    pub struct Id;
    impl ::cynic::schema::Field for Id {
        type SchemaType = super::Id;
        fn name() -> &'static str {
            "id"
        }
    }
    impl ::cynic::schema::HasField<Id> for super::Planet {
        type Type = super::Id;
    }
}
pub struct PlanetFilmsConnection;
pub mod planet_films_connection_fields {
    pub struct PageInfo;
    impl ::cynic::schema::Field for PageInfo {
        type SchemaType = super::PageInfo;
        fn name() -> &'static str {
            "pageInfo"
        }
    }
    impl ::cynic::schema::HasField<PageInfo> for super::PlanetFilmsConnection {
        type Type = super::PageInfo;
    }
    pub struct Edges;
    impl ::cynic::schema::Field for Edges {
        type SchemaType = Option<Vec<Option<super::PlanetFilmsEdge>>>;
        fn name() -> &'static str {
            "edges"
        }
    }
    impl ::cynic::schema::HasField<Edges> for super::PlanetFilmsConnection {
        type Type = Option<Vec<Option<super::PlanetFilmsEdge>>>;
    }
    pub struct TotalCount;
    impl ::cynic::schema::Field for TotalCount {
        type SchemaType = Option<super::Int>;
        fn name() -> &'static str {
            "totalCount"
        }
    }
    impl ::cynic::schema::HasField<TotalCount> for super::PlanetFilmsConnection {
        type Type = Option<super::Int>;
    }
    pub struct Films;
    impl ::cynic::schema::Field for Films {
        type SchemaType = Option<Vec<Option<super::Film>>>;
        fn name() -> &'static str {
            "films"
        }
    }
    impl ::cynic::schema::HasField<Films> for super::PlanetFilmsConnection {
        type Type = Option<Vec<Option<super::Film>>>;
    }
}
pub struct PlanetFilmsEdge;
pub mod planet_films_edge_fields {
    pub struct Node;
    impl ::cynic::schema::Field for Node {
        type SchemaType = Option<super::Film>;
        fn name() -> &'static str {
            "node"
        }
    }
    impl ::cynic::schema::HasField<Node> for super::PlanetFilmsEdge {
        type Type = Option<super::Film>;
    }
    pub struct Cursor;
    impl ::cynic::schema::Field for Cursor {
        type SchemaType = super::String;
        fn name() -> &'static str {
            "cursor"
        }
    }
    impl ::cynic::schema::HasField<Cursor> for super::PlanetFilmsEdge {
        type Type = super::String;
    }
}
pub struct PlanetResidentsConnection;
pub mod planet_residents_connection_fields {
    pub struct PageInfo;
    impl ::cynic::schema::Field for PageInfo {
        type SchemaType = super::PageInfo;
        fn name() -> &'static str {
            "pageInfo"
        }
    }
    impl ::cynic::schema::HasField<PageInfo> for super::PlanetResidentsConnection {
        type Type = super::PageInfo;
    }
    pub struct Edges;
    impl ::cynic::schema::Field for Edges {
        type SchemaType = Option<Vec<Option<super::PlanetResidentsEdge>>>;
        fn name() -> &'static str {
            "edges"
        }
    }
    impl ::cynic::schema::HasField<Edges> for super::PlanetResidentsConnection {
        type Type = Option<Vec<Option<super::PlanetResidentsEdge>>>;
    }
    pub struct TotalCount;
    impl ::cynic::schema::Field for TotalCount {
        type SchemaType = Option<super::Int>;
        fn name() -> &'static str {
            "totalCount"
        }
    }
    impl ::cynic::schema::HasField<TotalCount> for super::PlanetResidentsConnection {
        type Type = Option<super::Int>;
    }
    pub struct Residents;
    impl ::cynic::schema::Field for Residents {
        type SchemaType = Option<Vec<Option<super::Person>>>;
        fn name() -> &'static str {
            "residents"
        }
    }
    impl ::cynic::schema::HasField<Residents> for super::PlanetResidentsConnection {
        type Type = Option<Vec<Option<super::Person>>>;
    }
}
pub struct PlanetResidentsEdge;
pub mod planet_residents_edge_fields {
    pub struct Node;
    impl ::cynic::schema::Field for Node {
        type SchemaType = Option<super::Person>;
        fn name() -> &'static str {
            "node"
        }
    }
    impl ::cynic::schema::HasField<Node> for super::PlanetResidentsEdge {
        type Type = Option<super::Person>;
    }
    pub struct Cursor;
    impl ::cynic::schema::Field for Cursor {
        type SchemaType = super::String;
        fn name() -> &'static str {
            "cursor"
        }
    }
    impl ::cynic::schema::HasField<Cursor> for super::PlanetResidentsEdge {
        type Type = super::String;
    }
}
pub struct PlanetsConnection;
pub mod planets_connection_fields {
    pub struct PageInfo;
    impl ::cynic::schema::Field for PageInfo {
        type SchemaType = super::PageInfo;
        fn name() -> &'static str {
            "pageInfo"
        }
    }
    impl ::cynic::schema::HasField<PageInfo> for super::PlanetsConnection {
        type Type = super::PageInfo;
    }
    pub struct Edges;
    impl ::cynic::schema::Field for Edges {
        type SchemaType = Option<Vec<Option<super::PlanetsEdge>>>;
        fn name() -> &'static str {
            "edges"
        }
    }
    impl ::cynic::schema::HasField<Edges> for super::PlanetsConnection {
        type Type = Option<Vec<Option<super::PlanetsEdge>>>;
    }
    pub struct TotalCount;
    impl ::cynic::schema::Field for TotalCount {
        type SchemaType = Option<super::Int>;
        fn name() -> &'static str {
            "totalCount"
        }
    }
    impl ::cynic::schema::HasField<TotalCount> for super::PlanetsConnection {
        type Type = Option<super::Int>;
    }
    pub struct Planets;
    impl ::cynic::schema::Field for Planets {
        type SchemaType = Option<Vec<Option<super::Planet>>>;
        fn name() -> &'static str {
            "planets"
        }
    }
    impl ::cynic::schema::HasField<Planets> for super::PlanetsConnection {
        type Type = Option<Vec<Option<super::Planet>>>;
    }
}
pub struct PlanetsEdge;
pub mod planets_edge_fields {
    pub struct Node;
    impl ::cynic::schema::Field for Node {
        type SchemaType = Option<super::Planet>;
        fn name() -> &'static str {
            "node"
        }
    }
    impl ::cynic::schema::HasField<Node> for super::PlanetsEdge {
        type Type = Option<super::Planet>;
    }
    pub struct Cursor;
    impl ::cynic::schema::Field for Cursor {
        type SchemaType = super::String;
        fn name() -> &'static str {
            "cursor"
        }
    }
    impl ::cynic::schema::HasField<Cursor> for super::PlanetsEdge {
        type Type = super::String;
    }
}
pub struct Root;
pub mod root_fields {
    pub struct AllFilms;
    impl ::cynic::schema::Field for AllFilms {
        type SchemaType = Option<super::FilmsConnection>;
        fn name() -> &'static str {
            "allFilms"
        }
    }
    impl ::cynic::schema::HasField<AllFilms> for super::Root {
        type Type = Option<super::FilmsConnection>;
    }
    pub mod all_films_arguments {
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::AllFilms {
            type ArgumentSchemaType = Option<super::super::String>;
            fn name() -> &'static str {
                "after"
            }
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::AllFilms {
            type ArgumentSchemaType = Option<super::super::Int>;
            fn name() -> &'static str {
                "first"
            }
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::AllFilms {
            type ArgumentSchemaType = Option<super::super::String>;
            fn name() -> &'static str {
                "before"
            }
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::AllFilms {
            type ArgumentSchemaType = Option<super::super::Int>;
            fn name() -> &'static str {
                "last"
            }
        }
    }
    pub struct Film;
    impl ::cynic::schema::Field for Film {
        type SchemaType = Option<super::Film>;
        fn name() -> &'static str {
            "film"
        }
    }
    impl ::cynic::schema::HasField<Film> for super::Root {
        type Type = Option<super::Film>;
    }
    pub mod film_arguments {
        pub struct Id;
        impl ::cynic::schema::HasArgument<Id> for super::Film {
            type ArgumentSchemaType = Option<super::super::Id>;
            fn name() -> &'static str {
                "id"
            }
        }
        pub struct FilmId;
        impl ::cynic::schema::HasArgument<FilmId> for super::Film {
            type ArgumentSchemaType = Option<super::super::Id>;
            fn name() -> &'static str {
                "filmID"
            }
        }
    }
    pub struct AllPeople;
    impl ::cynic::schema::Field for AllPeople {
        type SchemaType = Option<super::PeopleConnection>;
        fn name() -> &'static str {
            "allPeople"
        }
    }
    impl ::cynic::schema::HasField<AllPeople> for super::Root {
        type Type = Option<super::PeopleConnection>;
    }
    pub mod all_people_arguments {
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::AllPeople {
            type ArgumentSchemaType = Option<super::super::String>;
            fn name() -> &'static str {
                "after"
            }
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::AllPeople {
            type ArgumentSchemaType = Option<super::super::Int>;
            fn name() -> &'static str {
                "first"
            }
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::AllPeople {
            type ArgumentSchemaType = Option<super::super::String>;
            fn name() -> &'static str {
                "before"
            }
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::AllPeople {
            type ArgumentSchemaType = Option<super::super::Int>;
            fn name() -> &'static str {
                "last"
            }
        }
    }
    pub struct Person;
    impl ::cynic::schema::Field for Person {
        type SchemaType = Option<super::Person>;
        fn name() -> &'static str {
            "person"
        }
    }
    impl ::cynic::schema::HasField<Person> for super::Root {
        type Type = Option<super::Person>;
    }
    pub mod person_arguments {
        pub struct Id;
        impl ::cynic::schema::HasArgument<Id> for super::Person {
            type ArgumentSchemaType = Option<super::super::Id>;
            fn name() -> &'static str {
                "id"
            }
        }
        pub struct PersonId;
        impl ::cynic::schema::HasArgument<PersonId> for super::Person {
            type ArgumentSchemaType = Option<super::super::Id>;
            fn name() -> &'static str {
                "personID"
            }
        }
    }
    pub struct AllPlanets;
    impl ::cynic::schema::Field for AllPlanets {
        type SchemaType = Option<super::PlanetsConnection>;
        fn name() -> &'static str {
            "allPlanets"
        }
    }
    impl ::cynic::schema::HasField<AllPlanets> for super::Root {
        type Type = Option<super::PlanetsConnection>;
    }
    pub mod all_planets_arguments {
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::AllPlanets {
            type ArgumentSchemaType = Option<super::super::String>;
            fn name() -> &'static str {
                "after"
            }
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::AllPlanets {
            type ArgumentSchemaType = Option<super::super::Int>;
            fn name() -> &'static str {
                "first"
            }
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::AllPlanets {
            type ArgumentSchemaType = Option<super::super::String>;
            fn name() -> &'static str {
                "before"
            }
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::AllPlanets {
            type ArgumentSchemaType = Option<super::super::Int>;
            fn name() -> &'static str {
                "last"
            }
        }
    }
    pub struct Planet;
    impl ::cynic::schema::Field for Planet {
        type SchemaType = Option<super::Planet>;
        fn name() -> &'static str {
            "planet"
        }
    }
    impl ::cynic::schema::HasField<Planet> for super::Root {
        type Type = Option<super::Planet>;
    }
    pub mod planet_arguments {
        pub struct Id;
        impl ::cynic::schema::HasArgument<Id> for super::Planet {
            type ArgumentSchemaType = Option<super::super::Id>;
            fn name() -> &'static str {
                "id"
            }
        }
        pub struct PlanetId;
        impl ::cynic::schema::HasArgument<PlanetId> for super::Planet {
            type ArgumentSchemaType = Option<super::super::Id>;
            fn name() -> &'static str {
                "planetID"
            }
        }
    }
    pub struct AllSpecies;
    impl ::cynic::schema::Field for AllSpecies {
        type SchemaType = Option<super::SpeciesConnection>;
        fn name() -> &'static str {
            "allSpecies"
        }
    }
    impl ::cynic::schema::HasField<AllSpecies> for super::Root {
        type Type = Option<super::SpeciesConnection>;
    }
    pub mod all_species_arguments {
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::AllSpecies {
            type ArgumentSchemaType = Option<super::super::String>;
            fn name() -> &'static str {
                "after"
            }
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::AllSpecies {
            type ArgumentSchemaType = Option<super::super::Int>;
            fn name() -> &'static str {
                "first"
            }
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::AllSpecies {
            type ArgumentSchemaType = Option<super::super::String>;
            fn name() -> &'static str {
                "before"
            }
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::AllSpecies {
            type ArgumentSchemaType = Option<super::super::Int>;
            fn name() -> &'static str {
                "last"
            }
        }
    }
    pub struct Species;
    impl ::cynic::schema::Field for Species {
        type SchemaType = Option<super::Species>;
        fn name() -> &'static str {
            "species"
        }
    }
    impl ::cynic::schema::HasField<Species> for super::Root {
        type Type = Option<super::Species>;
    }
    pub mod species_arguments {
        pub struct Id;
        impl ::cynic::schema::HasArgument<Id> for super::Species {
            type ArgumentSchemaType = Option<super::super::Id>;
            fn name() -> &'static str {
                "id"
            }
        }
        pub struct SpeciesId;
        impl ::cynic::schema::HasArgument<SpeciesId> for super::Species {
            type ArgumentSchemaType = Option<super::super::Id>;
            fn name() -> &'static str {
                "speciesID"
            }
        }
    }
    pub struct AllStarships;
    impl ::cynic::schema::Field for AllStarships {
        type SchemaType = Option<super::StarshipsConnection>;
        fn name() -> &'static str {
            "allStarships"
        }
    }
    impl ::cynic::schema::HasField<AllStarships> for super::Root {
        type Type = Option<super::StarshipsConnection>;
    }
    pub mod all_starships_arguments {
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::AllStarships {
            type ArgumentSchemaType = Option<super::super::String>;
            fn name() -> &'static str {
                "after"
            }
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::AllStarships {
            type ArgumentSchemaType = Option<super::super::Int>;
            fn name() -> &'static str {
                "first"
            }
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::AllStarships {
            type ArgumentSchemaType = Option<super::super::String>;
            fn name() -> &'static str {
                "before"
            }
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::AllStarships {
            type ArgumentSchemaType = Option<super::super::Int>;
            fn name() -> &'static str {
                "last"
            }
        }
    }
    pub struct Starship;
    impl ::cynic::schema::Field for Starship {
        type SchemaType = Option<super::Starship>;
        fn name() -> &'static str {
            "starship"
        }
    }
    impl ::cynic::schema::HasField<Starship> for super::Root {
        type Type = Option<super::Starship>;
    }
    pub mod starship_arguments {
        pub struct Id;
        impl ::cynic::schema::HasArgument<Id> for super::Starship {
            type ArgumentSchemaType = Option<super::super::Id>;
            fn name() -> &'static str {
                "id"
            }
        }
        pub struct StarshipId;
        impl ::cynic::schema::HasArgument<StarshipId> for super::Starship {
            type ArgumentSchemaType = Option<super::super::Id>;
            fn name() -> &'static str {
                "starshipID"
            }
        }
    }
    pub struct AllVehicles;
    impl ::cynic::schema::Field for AllVehicles {
        type SchemaType = Option<super::VehiclesConnection>;
        fn name() -> &'static str {
            "allVehicles"
        }
    }
    impl ::cynic::schema::HasField<AllVehicles> for super::Root {
        type Type = Option<super::VehiclesConnection>;
    }
    pub mod all_vehicles_arguments {
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::AllVehicles {
            type ArgumentSchemaType = Option<super::super::String>;
            fn name() -> &'static str {
                "after"
            }
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::AllVehicles {
            type ArgumentSchemaType = Option<super::super::Int>;
            fn name() -> &'static str {
                "first"
            }
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::AllVehicles {
            type ArgumentSchemaType = Option<super::super::String>;
            fn name() -> &'static str {
                "before"
            }
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::AllVehicles {
            type ArgumentSchemaType = Option<super::super::Int>;
            fn name() -> &'static str {
                "last"
            }
        }
    }
    pub struct Vehicle;
    impl ::cynic::schema::Field for Vehicle {
        type SchemaType = Option<super::Vehicle>;
        fn name() -> &'static str {
            "vehicle"
        }
    }
    impl ::cynic::schema::HasField<Vehicle> for super::Root {
        type Type = Option<super::Vehicle>;
    }
    pub mod vehicle_arguments {
        pub struct Id;
        impl ::cynic::schema::HasArgument<Id> for super::Vehicle {
            type ArgumentSchemaType = Option<super::super::Id>;
            fn name() -> &'static str {
                "id"
            }
        }
        pub struct VehicleId;
        impl ::cynic::schema::HasArgument<VehicleId> for super::Vehicle {
            type ArgumentSchemaType = Option<super::super::Id>;
            fn name() -> &'static str {
                "vehicleID"
            }
        }
    }
    pub struct Node;
    impl ::cynic::schema::Field for Node {
        type SchemaType = Option<super::Node>;
        fn name() -> &'static str {
            "node"
        }
    }
    impl ::cynic::schema::HasField<Node> for super::Root {
        type Type = Option<super::Node>;
    }
    pub mod node_arguments {
        pub struct Id;
        impl ::cynic::schema::HasArgument<Id> for super::Node {
            type ArgumentSchemaType = super::super::Id;
            fn name() -> &'static str {
                "id"
            }
        }
    }
}
pub struct Species;
pub mod species_fields {
    pub struct Name;
    impl ::cynic::schema::Field for Name {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "name"
        }
    }
    impl ::cynic::schema::HasField<Name> for super::Species {
        type Type = Option<super::String>;
    }
    pub struct Classification;
    impl ::cynic::schema::Field for Classification {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "classification"
        }
    }
    impl ::cynic::schema::HasField<Classification> for super::Species {
        type Type = Option<super::String>;
    }
    pub struct Designation;
    impl ::cynic::schema::Field for Designation {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "designation"
        }
    }
    impl ::cynic::schema::HasField<Designation> for super::Species {
        type Type = Option<super::String>;
    }
    pub struct AverageHeight;
    impl ::cynic::schema::Field for AverageHeight {
        type SchemaType = Option<super::Float>;
        fn name() -> &'static str {
            "averageHeight"
        }
    }
    impl ::cynic::schema::HasField<AverageHeight> for super::Species {
        type Type = Option<super::Float>;
    }
    pub struct AverageLifespan;
    impl ::cynic::schema::Field for AverageLifespan {
        type SchemaType = Option<super::Int>;
        fn name() -> &'static str {
            "averageLifespan"
        }
    }
    impl ::cynic::schema::HasField<AverageLifespan> for super::Species {
        type Type = Option<super::Int>;
    }
    pub struct EyeColors;
    impl ::cynic::schema::Field for EyeColors {
        type SchemaType = Option<Vec<Option<super::String>>>;
        fn name() -> &'static str {
            "eyeColors"
        }
    }
    impl ::cynic::schema::HasField<EyeColors> for super::Species {
        type Type = Option<Vec<Option<super::String>>>;
    }
    pub struct HairColors;
    impl ::cynic::schema::Field for HairColors {
        type SchemaType = Option<Vec<Option<super::String>>>;
        fn name() -> &'static str {
            "hairColors"
        }
    }
    impl ::cynic::schema::HasField<HairColors> for super::Species {
        type Type = Option<Vec<Option<super::String>>>;
    }
    pub struct SkinColors;
    impl ::cynic::schema::Field for SkinColors {
        type SchemaType = Option<Vec<Option<super::String>>>;
        fn name() -> &'static str {
            "skinColors"
        }
    }
    impl ::cynic::schema::HasField<SkinColors> for super::Species {
        type Type = Option<Vec<Option<super::String>>>;
    }
    pub struct Language;
    impl ::cynic::schema::Field for Language {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "language"
        }
    }
    impl ::cynic::schema::HasField<Language> for super::Species {
        type Type = Option<super::String>;
    }
    pub struct Homeworld;
    impl ::cynic::schema::Field for Homeworld {
        type SchemaType = Option<super::Planet>;
        fn name() -> &'static str {
            "homeworld"
        }
    }
    impl ::cynic::schema::HasField<Homeworld> for super::Species {
        type Type = Option<super::Planet>;
    }
    pub struct PersonConnection;
    impl ::cynic::schema::Field for PersonConnection {
        type SchemaType = Option<super::SpeciesPeopleConnection>;
        fn name() -> &'static str {
            "personConnection"
        }
    }
    impl ::cynic::schema::HasField<PersonConnection> for super::Species {
        type Type = Option<super::SpeciesPeopleConnection>;
    }
    pub mod person_connection_arguments {
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::PersonConnection {
            type ArgumentSchemaType = Option<super::super::String>;
            fn name() -> &'static str {
                "after"
            }
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::PersonConnection {
            type ArgumentSchemaType = Option<super::super::Int>;
            fn name() -> &'static str {
                "first"
            }
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::PersonConnection {
            type ArgumentSchemaType = Option<super::super::String>;
            fn name() -> &'static str {
                "before"
            }
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::PersonConnection {
            type ArgumentSchemaType = Option<super::super::Int>;
            fn name() -> &'static str {
                "last"
            }
        }
    }
    pub struct FilmConnection;
    impl ::cynic::schema::Field for FilmConnection {
        type SchemaType = Option<super::SpeciesFilmsConnection>;
        fn name() -> &'static str {
            "filmConnection"
        }
    }
    impl ::cynic::schema::HasField<FilmConnection> for super::Species {
        type Type = Option<super::SpeciesFilmsConnection>;
    }
    pub mod film_connection_arguments {
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::FilmConnection {
            type ArgumentSchemaType = Option<super::super::String>;
            fn name() -> &'static str {
                "after"
            }
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::FilmConnection {
            type ArgumentSchemaType = Option<super::super::Int>;
            fn name() -> &'static str {
                "first"
            }
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::FilmConnection {
            type ArgumentSchemaType = Option<super::super::String>;
            fn name() -> &'static str {
                "before"
            }
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::FilmConnection {
            type ArgumentSchemaType = Option<super::super::Int>;
            fn name() -> &'static str {
                "last"
            }
        }
    }
    pub struct Created;
    impl ::cynic::schema::Field for Created {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "created"
        }
    }
    impl ::cynic::schema::HasField<Created> for super::Species {
        type Type = Option<super::String>;
    }
    pub struct Edited;
    impl ::cynic::schema::Field for Edited {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "edited"
        }
    }
    impl ::cynic::schema::HasField<Edited> for super::Species {
        type Type = Option<super::String>;
    }
    pub struct Id;
    impl ::cynic::schema::Field for Id {
        type SchemaType = super::Id;
        fn name() -> &'static str {
            "id"
        }
    }
    impl ::cynic::schema::HasField<Id> for super::Species {
        type Type = super::Id;
    }
}
pub struct SpeciesConnection;
pub mod species_connection_fields {
    pub struct PageInfo;
    impl ::cynic::schema::Field for PageInfo {
        type SchemaType = super::PageInfo;
        fn name() -> &'static str {
            "pageInfo"
        }
    }
    impl ::cynic::schema::HasField<PageInfo> for super::SpeciesConnection {
        type Type = super::PageInfo;
    }
    pub struct Edges;
    impl ::cynic::schema::Field for Edges {
        type SchemaType = Option<Vec<Option<super::SpeciesEdge>>>;
        fn name() -> &'static str {
            "edges"
        }
    }
    impl ::cynic::schema::HasField<Edges> for super::SpeciesConnection {
        type Type = Option<Vec<Option<super::SpeciesEdge>>>;
    }
    pub struct TotalCount;
    impl ::cynic::schema::Field for TotalCount {
        type SchemaType = Option<super::Int>;
        fn name() -> &'static str {
            "totalCount"
        }
    }
    impl ::cynic::schema::HasField<TotalCount> for super::SpeciesConnection {
        type Type = Option<super::Int>;
    }
    pub struct Species;
    impl ::cynic::schema::Field for Species {
        type SchemaType = Option<Vec<Option<super::Species>>>;
        fn name() -> &'static str {
            "species"
        }
    }
    impl ::cynic::schema::HasField<Species> for super::SpeciesConnection {
        type Type = Option<Vec<Option<super::Species>>>;
    }
}
pub struct SpeciesEdge;
pub mod species_edge_fields {
    pub struct Node;
    impl ::cynic::schema::Field for Node {
        type SchemaType = Option<super::Species>;
        fn name() -> &'static str {
            "node"
        }
    }
    impl ::cynic::schema::HasField<Node> for super::SpeciesEdge {
        type Type = Option<super::Species>;
    }
    pub struct Cursor;
    impl ::cynic::schema::Field for Cursor {
        type SchemaType = super::String;
        fn name() -> &'static str {
            "cursor"
        }
    }
    impl ::cynic::schema::HasField<Cursor> for super::SpeciesEdge {
        type Type = super::String;
    }
}
pub struct SpeciesFilmsConnection;
pub mod species_films_connection_fields {
    pub struct PageInfo;
    impl ::cynic::schema::Field for PageInfo {
        type SchemaType = super::PageInfo;
        fn name() -> &'static str {
            "pageInfo"
        }
    }
    impl ::cynic::schema::HasField<PageInfo> for super::SpeciesFilmsConnection {
        type Type = super::PageInfo;
    }
    pub struct Edges;
    impl ::cynic::schema::Field for Edges {
        type SchemaType = Option<Vec<Option<super::SpeciesFilmsEdge>>>;
        fn name() -> &'static str {
            "edges"
        }
    }
    impl ::cynic::schema::HasField<Edges> for super::SpeciesFilmsConnection {
        type Type = Option<Vec<Option<super::SpeciesFilmsEdge>>>;
    }
    pub struct TotalCount;
    impl ::cynic::schema::Field for TotalCount {
        type SchemaType = Option<super::Int>;
        fn name() -> &'static str {
            "totalCount"
        }
    }
    impl ::cynic::schema::HasField<TotalCount> for super::SpeciesFilmsConnection {
        type Type = Option<super::Int>;
    }
    pub struct Films;
    impl ::cynic::schema::Field for Films {
        type SchemaType = Option<Vec<Option<super::Film>>>;
        fn name() -> &'static str {
            "films"
        }
    }
    impl ::cynic::schema::HasField<Films> for super::SpeciesFilmsConnection {
        type Type = Option<Vec<Option<super::Film>>>;
    }
}
pub struct SpeciesFilmsEdge;
pub mod species_films_edge_fields {
    pub struct Node;
    impl ::cynic::schema::Field for Node {
        type SchemaType = Option<super::Film>;
        fn name() -> &'static str {
            "node"
        }
    }
    impl ::cynic::schema::HasField<Node> for super::SpeciesFilmsEdge {
        type Type = Option<super::Film>;
    }
    pub struct Cursor;
    impl ::cynic::schema::Field for Cursor {
        type SchemaType = super::String;
        fn name() -> &'static str {
            "cursor"
        }
    }
    impl ::cynic::schema::HasField<Cursor> for super::SpeciesFilmsEdge {
        type Type = super::String;
    }
}
pub struct SpeciesPeopleConnection;
pub mod species_people_connection_fields {
    pub struct PageInfo;
    impl ::cynic::schema::Field for PageInfo {
        type SchemaType = super::PageInfo;
        fn name() -> &'static str {
            "pageInfo"
        }
    }
    impl ::cynic::schema::HasField<PageInfo> for super::SpeciesPeopleConnection {
        type Type = super::PageInfo;
    }
    pub struct Edges;
    impl ::cynic::schema::Field for Edges {
        type SchemaType = Option<Vec<Option<super::SpeciesPeopleEdge>>>;
        fn name() -> &'static str {
            "edges"
        }
    }
    impl ::cynic::schema::HasField<Edges> for super::SpeciesPeopleConnection {
        type Type = Option<Vec<Option<super::SpeciesPeopleEdge>>>;
    }
    pub struct TotalCount;
    impl ::cynic::schema::Field for TotalCount {
        type SchemaType = Option<super::Int>;
        fn name() -> &'static str {
            "totalCount"
        }
    }
    impl ::cynic::schema::HasField<TotalCount> for super::SpeciesPeopleConnection {
        type Type = Option<super::Int>;
    }
    pub struct People;
    impl ::cynic::schema::Field for People {
        type SchemaType = Option<Vec<Option<super::Person>>>;
        fn name() -> &'static str {
            "people"
        }
    }
    impl ::cynic::schema::HasField<People> for super::SpeciesPeopleConnection {
        type Type = Option<Vec<Option<super::Person>>>;
    }
}
pub struct SpeciesPeopleEdge;
pub mod species_people_edge_fields {
    pub struct Node;
    impl ::cynic::schema::Field for Node {
        type SchemaType = Option<super::Person>;
        fn name() -> &'static str {
            "node"
        }
    }
    impl ::cynic::schema::HasField<Node> for super::SpeciesPeopleEdge {
        type Type = Option<super::Person>;
    }
    pub struct Cursor;
    impl ::cynic::schema::Field for Cursor {
        type SchemaType = super::String;
        fn name() -> &'static str {
            "cursor"
        }
    }
    impl ::cynic::schema::HasField<Cursor> for super::SpeciesPeopleEdge {
        type Type = super::String;
    }
}
pub struct Starship;
pub mod starship_fields {
    pub struct Name;
    impl ::cynic::schema::Field for Name {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "name"
        }
    }
    impl ::cynic::schema::HasField<Name> for super::Starship {
        type Type = Option<super::String>;
    }
    pub struct Model;
    impl ::cynic::schema::Field for Model {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "model"
        }
    }
    impl ::cynic::schema::HasField<Model> for super::Starship {
        type Type = Option<super::String>;
    }
    pub struct StarshipClass;
    impl ::cynic::schema::Field for StarshipClass {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "starshipClass"
        }
    }
    impl ::cynic::schema::HasField<StarshipClass> for super::Starship {
        type Type = Option<super::String>;
    }
    pub struct Manufacturers;
    impl ::cynic::schema::Field for Manufacturers {
        type SchemaType = Option<Vec<Option<super::String>>>;
        fn name() -> &'static str {
            "manufacturers"
        }
    }
    impl ::cynic::schema::HasField<Manufacturers> for super::Starship {
        type Type = Option<Vec<Option<super::String>>>;
    }
    pub struct CostInCredits;
    impl ::cynic::schema::Field for CostInCredits {
        type SchemaType = Option<super::Float>;
        fn name() -> &'static str {
            "costInCredits"
        }
    }
    impl ::cynic::schema::HasField<CostInCredits> for super::Starship {
        type Type = Option<super::Float>;
    }
    pub struct Length;
    impl ::cynic::schema::Field for Length {
        type SchemaType = Option<super::Float>;
        fn name() -> &'static str {
            "length"
        }
    }
    impl ::cynic::schema::HasField<Length> for super::Starship {
        type Type = Option<super::Float>;
    }
    pub struct Crew;
    impl ::cynic::schema::Field for Crew {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "crew"
        }
    }
    impl ::cynic::schema::HasField<Crew> for super::Starship {
        type Type = Option<super::String>;
    }
    pub struct Passengers;
    impl ::cynic::schema::Field for Passengers {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "passengers"
        }
    }
    impl ::cynic::schema::HasField<Passengers> for super::Starship {
        type Type = Option<super::String>;
    }
    pub struct MaxAtmospheringSpeed;
    impl ::cynic::schema::Field for MaxAtmospheringSpeed {
        type SchemaType = Option<super::Int>;
        fn name() -> &'static str {
            "maxAtmospheringSpeed"
        }
    }
    impl ::cynic::schema::HasField<MaxAtmospheringSpeed> for super::Starship {
        type Type = Option<super::Int>;
    }
    pub struct HyperdriveRating;
    impl ::cynic::schema::Field for HyperdriveRating {
        type SchemaType = Option<super::Float>;
        fn name() -> &'static str {
            "hyperdriveRating"
        }
    }
    impl ::cynic::schema::HasField<HyperdriveRating> for super::Starship {
        type Type = Option<super::Float>;
    }
    pub struct Mglt;
    impl ::cynic::schema::Field for Mglt {
        type SchemaType = Option<super::Int>;
        fn name() -> &'static str {
            "MGLT"
        }
    }
    impl ::cynic::schema::HasField<Mglt> for super::Starship {
        type Type = Option<super::Int>;
    }
    pub struct CargoCapacity;
    impl ::cynic::schema::Field for CargoCapacity {
        type SchemaType = Option<super::Float>;
        fn name() -> &'static str {
            "cargoCapacity"
        }
    }
    impl ::cynic::schema::HasField<CargoCapacity> for super::Starship {
        type Type = Option<super::Float>;
    }
    pub struct Consumables;
    impl ::cynic::schema::Field for Consumables {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "consumables"
        }
    }
    impl ::cynic::schema::HasField<Consumables> for super::Starship {
        type Type = Option<super::String>;
    }
    pub struct PilotConnection;
    impl ::cynic::schema::Field for PilotConnection {
        type SchemaType = Option<super::StarshipPilotsConnection>;
        fn name() -> &'static str {
            "pilotConnection"
        }
    }
    impl ::cynic::schema::HasField<PilotConnection> for super::Starship {
        type Type = Option<super::StarshipPilotsConnection>;
    }
    pub mod pilot_connection_arguments {
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::PilotConnection {
            type ArgumentSchemaType = Option<super::super::String>;
            fn name() -> &'static str {
                "after"
            }
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::PilotConnection {
            type ArgumentSchemaType = Option<super::super::Int>;
            fn name() -> &'static str {
                "first"
            }
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::PilotConnection {
            type ArgumentSchemaType = Option<super::super::String>;
            fn name() -> &'static str {
                "before"
            }
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::PilotConnection {
            type ArgumentSchemaType = Option<super::super::Int>;
            fn name() -> &'static str {
                "last"
            }
        }
    }
    pub struct FilmConnection;
    impl ::cynic::schema::Field for FilmConnection {
        type SchemaType = Option<super::StarshipFilmsConnection>;
        fn name() -> &'static str {
            "filmConnection"
        }
    }
    impl ::cynic::schema::HasField<FilmConnection> for super::Starship {
        type Type = Option<super::StarshipFilmsConnection>;
    }
    pub mod film_connection_arguments {
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::FilmConnection {
            type ArgumentSchemaType = Option<super::super::String>;
            fn name() -> &'static str {
                "after"
            }
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::FilmConnection {
            type ArgumentSchemaType = Option<super::super::Int>;
            fn name() -> &'static str {
                "first"
            }
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::FilmConnection {
            type ArgumentSchemaType = Option<super::super::String>;
            fn name() -> &'static str {
                "before"
            }
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::FilmConnection {
            type ArgumentSchemaType = Option<super::super::Int>;
            fn name() -> &'static str {
                "last"
            }
        }
    }
    pub struct Created;
    impl ::cynic::schema::Field for Created {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "created"
        }
    }
    impl ::cynic::schema::HasField<Created> for super::Starship {
        type Type = Option<super::String>;
    }
    pub struct Edited;
    impl ::cynic::schema::Field for Edited {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "edited"
        }
    }
    impl ::cynic::schema::HasField<Edited> for super::Starship {
        type Type = Option<super::String>;
    }
    pub struct Id;
    impl ::cynic::schema::Field for Id {
        type SchemaType = super::Id;
        fn name() -> &'static str {
            "id"
        }
    }
    impl ::cynic::schema::HasField<Id> for super::Starship {
        type Type = super::Id;
    }
}
pub struct StarshipFilmsConnection;
pub mod starship_films_connection_fields {
    pub struct PageInfo;
    impl ::cynic::schema::Field for PageInfo {
        type SchemaType = super::PageInfo;
        fn name() -> &'static str {
            "pageInfo"
        }
    }
    impl ::cynic::schema::HasField<PageInfo> for super::StarshipFilmsConnection {
        type Type = super::PageInfo;
    }
    pub struct Edges;
    impl ::cynic::schema::Field for Edges {
        type SchemaType = Option<Vec<Option<super::StarshipFilmsEdge>>>;
        fn name() -> &'static str {
            "edges"
        }
    }
    impl ::cynic::schema::HasField<Edges> for super::StarshipFilmsConnection {
        type Type = Option<Vec<Option<super::StarshipFilmsEdge>>>;
    }
    pub struct TotalCount;
    impl ::cynic::schema::Field for TotalCount {
        type SchemaType = Option<super::Int>;
        fn name() -> &'static str {
            "totalCount"
        }
    }
    impl ::cynic::schema::HasField<TotalCount> for super::StarshipFilmsConnection {
        type Type = Option<super::Int>;
    }
    pub struct Films;
    impl ::cynic::schema::Field for Films {
        type SchemaType = Option<Vec<Option<super::Film>>>;
        fn name() -> &'static str {
            "films"
        }
    }
    impl ::cynic::schema::HasField<Films> for super::StarshipFilmsConnection {
        type Type = Option<Vec<Option<super::Film>>>;
    }
}
pub struct StarshipFilmsEdge;
pub mod starship_films_edge_fields {
    pub struct Node;
    impl ::cynic::schema::Field for Node {
        type SchemaType = Option<super::Film>;
        fn name() -> &'static str {
            "node"
        }
    }
    impl ::cynic::schema::HasField<Node> for super::StarshipFilmsEdge {
        type Type = Option<super::Film>;
    }
    pub struct Cursor;
    impl ::cynic::schema::Field for Cursor {
        type SchemaType = super::String;
        fn name() -> &'static str {
            "cursor"
        }
    }
    impl ::cynic::schema::HasField<Cursor> for super::StarshipFilmsEdge {
        type Type = super::String;
    }
}
pub struct StarshipPilotsConnection;
pub mod starship_pilots_connection_fields {
    pub struct PageInfo;
    impl ::cynic::schema::Field for PageInfo {
        type SchemaType = super::PageInfo;
        fn name() -> &'static str {
            "pageInfo"
        }
    }
    impl ::cynic::schema::HasField<PageInfo> for super::StarshipPilotsConnection {
        type Type = super::PageInfo;
    }
    pub struct Edges;
    impl ::cynic::schema::Field for Edges {
        type SchemaType = Option<Vec<Option<super::StarshipPilotsEdge>>>;
        fn name() -> &'static str {
            "edges"
        }
    }
    impl ::cynic::schema::HasField<Edges> for super::StarshipPilotsConnection {
        type Type = Option<Vec<Option<super::StarshipPilotsEdge>>>;
    }
    pub struct TotalCount;
    impl ::cynic::schema::Field for TotalCount {
        type SchemaType = Option<super::Int>;
        fn name() -> &'static str {
            "totalCount"
        }
    }
    impl ::cynic::schema::HasField<TotalCount> for super::StarshipPilotsConnection {
        type Type = Option<super::Int>;
    }
    pub struct Pilots;
    impl ::cynic::schema::Field for Pilots {
        type SchemaType = Option<Vec<Option<super::Person>>>;
        fn name() -> &'static str {
            "pilots"
        }
    }
    impl ::cynic::schema::HasField<Pilots> for super::StarshipPilotsConnection {
        type Type = Option<Vec<Option<super::Person>>>;
    }
}
pub struct StarshipPilotsEdge;
pub mod starship_pilots_edge_fields {
    pub struct Node;
    impl ::cynic::schema::Field for Node {
        type SchemaType = Option<super::Person>;
        fn name() -> &'static str {
            "node"
        }
    }
    impl ::cynic::schema::HasField<Node> for super::StarshipPilotsEdge {
        type Type = Option<super::Person>;
    }
    pub struct Cursor;
    impl ::cynic::schema::Field for Cursor {
        type SchemaType = super::String;
        fn name() -> &'static str {
            "cursor"
        }
    }
    impl ::cynic::schema::HasField<Cursor> for super::StarshipPilotsEdge {
        type Type = super::String;
    }
}
pub struct StarshipsConnection;
pub mod starships_connection_fields {
    pub struct PageInfo;
    impl ::cynic::schema::Field for PageInfo {
        type SchemaType = super::PageInfo;
        fn name() -> &'static str {
            "pageInfo"
        }
    }
    impl ::cynic::schema::HasField<PageInfo> for super::StarshipsConnection {
        type Type = super::PageInfo;
    }
    pub struct Edges;
    impl ::cynic::schema::Field for Edges {
        type SchemaType = Option<Vec<Option<super::StarshipsEdge>>>;
        fn name() -> &'static str {
            "edges"
        }
    }
    impl ::cynic::schema::HasField<Edges> for super::StarshipsConnection {
        type Type = Option<Vec<Option<super::StarshipsEdge>>>;
    }
    pub struct TotalCount;
    impl ::cynic::schema::Field for TotalCount {
        type SchemaType = Option<super::Int>;
        fn name() -> &'static str {
            "totalCount"
        }
    }
    impl ::cynic::schema::HasField<TotalCount> for super::StarshipsConnection {
        type Type = Option<super::Int>;
    }
    pub struct Starships;
    impl ::cynic::schema::Field for Starships {
        type SchemaType = Option<Vec<Option<super::Starship>>>;
        fn name() -> &'static str {
            "starships"
        }
    }
    impl ::cynic::schema::HasField<Starships> for super::StarshipsConnection {
        type Type = Option<Vec<Option<super::Starship>>>;
    }
}
pub struct StarshipsEdge;
pub mod starships_edge_fields {
    pub struct Node;
    impl ::cynic::schema::Field for Node {
        type SchemaType = Option<super::Starship>;
        fn name() -> &'static str {
            "node"
        }
    }
    impl ::cynic::schema::HasField<Node> for super::StarshipsEdge {
        type Type = Option<super::Starship>;
    }
    pub struct Cursor;
    impl ::cynic::schema::Field for Cursor {
        type SchemaType = super::String;
        fn name() -> &'static str {
            "cursor"
        }
    }
    impl ::cynic::schema::HasField<Cursor> for super::StarshipsEdge {
        type Type = super::String;
    }
}
pub struct Vehicle;
pub mod vehicle_fields {
    pub struct Name;
    impl ::cynic::schema::Field for Name {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "name"
        }
    }
    impl ::cynic::schema::HasField<Name> for super::Vehicle {
        type Type = Option<super::String>;
    }
    pub struct Model;
    impl ::cynic::schema::Field for Model {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "model"
        }
    }
    impl ::cynic::schema::HasField<Model> for super::Vehicle {
        type Type = Option<super::String>;
    }
    pub struct VehicleClass;
    impl ::cynic::schema::Field for VehicleClass {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "vehicleClass"
        }
    }
    impl ::cynic::schema::HasField<VehicleClass> for super::Vehicle {
        type Type = Option<super::String>;
    }
    pub struct Manufacturers;
    impl ::cynic::schema::Field for Manufacturers {
        type SchemaType = Option<Vec<Option<super::String>>>;
        fn name() -> &'static str {
            "manufacturers"
        }
    }
    impl ::cynic::schema::HasField<Manufacturers> for super::Vehicle {
        type Type = Option<Vec<Option<super::String>>>;
    }
    pub struct CostInCredits;
    impl ::cynic::schema::Field for CostInCredits {
        type SchemaType = Option<super::Float>;
        fn name() -> &'static str {
            "costInCredits"
        }
    }
    impl ::cynic::schema::HasField<CostInCredits> for super::Vehicle {
        type Type = Option<super::Float>;
    }
    pub struct Length;
    impl ::cynic::schema::Field for Length {
        type SchemaType = Option<super::Float>;
        fn name() -> &'static str {
            "length"
        }
    }
    impl ::cynic::schema::HasField<Length> for super::Vehicle {
        type Type = Option<super::Float>;
    }
    pub struct Crew;
    impl ::cynic::schema::Field for Crew {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "crew"
        }
    }
    impl ::cynic::schema::HasField<Crew> for super::Vehicle {
        type Type = Option<super::String>;
    }
    pub struct Passengers;
    impl ::cynic::schema::Field for Passengers {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "passengers"
        }
    }
    impl ::cynic::schema::HasField<Passengers> for super::Vehicle {
        type Type = Option<super::String>;
    }
    pub struct MaxAtmospheringSpeed;
    impl ::cynic::schema::Field for MaxAtmospheringSpeed {
        type SchemaType = Option<super::Int>;
        fn name() -> &'static str {
            "maxAtmospheringSpeed"
        }
    }
    impl ::cynic::schema::HasField<MaxAtmospheringSpeed> for super::Vehicle {
        type Type = Option<super::Int>;
    }
    pub struct CargoCapacity;
    impl ::cynic::schema::Field for CargoCapacity {
        type SchemaType = Option<super::Float>;
        fn name() -> &'static str {
            "cargoCapacity"
        }
    }
    impl ::cynic::schema::HasField<CargoCapacity> for super::Vehicle {
        type Type = Option<super::Float>;
    }
    pub struct Consumables;
    impl ::cynic::schema::Field for Consumables {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "consumables"
        }
    }
    impl ::cynic::schema::HasField<Consumables> for super::Vehicle {
        type Type = Option<super::String>;
    }
    pub struct PilotConnection;
    impl ::cynic::schema::Field for PilotConnection {
        type SchemaType = Option<super::VehiclePilotsConnection>;
        fn name() -> &'static str {
            "pilotConnection"
        }
    }
    impl ::cynic::schema::HasField<PilotConnection> for super::Vehicle {
        type Type = Option<super::VehiclePilotsConnection>;
    }
    pub mod pilot_connection_arguments {
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::PilotConnection {
            type ArgumentSchemaType = Option<super::super::String>;
            fn name() -> &'static str {
                "after"
            }
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::PilotConnection {
            type ArgumentSchemaType = Option<super::super::Int>;
            fn name() -> &'static str {
                "first"
            }
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::PilotConnection {
            type ArgumentSchemaType = Option<super::super::String>;
            fn name() -> &'static str {
                "before"
            }
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::PilotConnection {
            type ArgumentSchemaType = Option<super::super::Int>;
            fn name() -> &'static str {
                "last"
            }
        }
    }
    pub struct FilmConnection;
    impl ::cynic::schema::Field for FilmConnection {
        type SchemaType = Option<super::VehicleFilmsConnection>;
        fn name() -> &'static str {
            "filmConnection"
        }
    }
    impl ::cynic::schema::HasField<FilmConnection> for super::Vehicle {
        type Type = Option<super::VehicleFilmsConnection>;
    }
    pub mod film_connection_arguments {
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::FilmConnection {
            type ArgumentSchemaType = Option<super::super::String>;
            fn name() -> &'static str {
                "after"
            }
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::FilmConnection {
            type ArgumentSchemaType = Option<super::super::Int>;
            fn name() -> &'static str {
                "first"
            }
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::FilmConnection {
            type ArgumentSchemaType = Option<super::super::String>;
            fn name() -> &'static str {
                "before"
            }
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::FilmConnection {
            type ArgumentSchemaType = Option<super::super::Int>;
            fn name() -> &'static str {
                "last"
            }
        }
    }
    pub struct Created;
    impl ::cynic::schema::Field for Created {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "created"
        }
    }
    impl ::cynic::schema::HasField<Created> for super::Vehicle {
        type Type = Option<super::String>;
    }
    pub struct Edited;
    impl ::cynic::schema::Field for Edited {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "edited"
        }
    }
    impl ::cynic::schema::HasField<Edited> for super::Vehicle {
        type Type = Option<super::String>;
    }
    pub struct Id;
    impl ::cynic::schema::Field for Id {
        type SchemaType = super::Id;
        fn name() -> &'static str {
            "id"
        }
    }
    impl ::cynic::schema::HasField<Id> for super::Vehicle {
        type Type = super::Id;
    }
}
pub struct VehicleFilmsConnection;
pub mod vehicle_films_connection_fields {
    pub struct PageInfo;
    impl ::cynic::schema::Field for PageInfo {
        type SchemaType = super::PageInfo;
        fn name() -> &'static str {
            "pageInfo"
        }
    }
    impl ::cynic::schema::HasField<PageInfo> for super::VehicleFilmsConnection {
        type Type = super::PageInfo;
    }
    pub struct Edges;
    impl ::cynic::schema::Field for Edges {
        type SchemaType = Option<Vec<Option<super::VehicleFilmsEdge>>>;
        fn name() -> &'static str {
            "edges"
        }
    }
    impl ::cynic::schema::HasField<Edges> for super::VehicleFilmsConnection {
        type Type = Option<Vec<Option<super::VehicleFilmsEdge>>>;
    }
    pub struct TotalCount;
    impl ::cynic::schema::Field for TotalCount {
        type SchemaType = Option<super::Int>;
        fn name() -> &'static str {
            "totalCount"
        }
    }
    impl ::cynic::schema::HasField<TotalCount> for super::VehicleFilmsConnection {
        type Type = Option<super::Int>;
    }
    pub struct Films;
    impl ::cynic::schema::Field for Films {
        type SchemaType = Option<Vec<Option<super::Film>>>;
        fn name() -> &'static str {
            "films"
        }
    }
    impl ::cynic::schema::HasField<Films> for super::VehicleFilmsConnection {
        type Type = Option<Vec<Option<super::Film>>>;
    }
}
pub struct VehicleFilmsEdge;
pub mod vehicle_films_edge_fields {
    pub struct Node;
    impl ::cynic::schema::Field for Node {
        type SchemaType = Option<super::Film>;
        fn name() -> &'static str {
            "node"
        }
    }
    impl ::cynic::schema::HasField<Node> for super::VehicleFilmsEdge {
        type Type = Option<super::Film>;
    }
    pub struct Cursor;
    impl ::cynic::schema::Field for Cursor {
        type SchemaType = super::String;
        fn name() -> &'static str {
            "cursor"
        }
    }
    impl ::cynic::schema::HasField<Cursor> for super::VehicleFilmsEdge {
        type Type = super::String;
    }
}
pub struct VehiclePilotsConnection;
pub mod vehicle_pilots_connection_fields {
    pub struct PageInfo;
    impl ::cynic::schema::Field for PageInfo {
        type SchemaType = super::PageInfo;
        fn name() -> &'static str {
            "pageInfo"
        }
    }
    impl ::cynic::schema::HasField<PageInfo> for super::VehiclePilotsConnection {
        type Type = super::PageInfo;
    }
    pub struct Edges;
    impl ::cynic::schema::Field for Edges {
        type SchemaType = Option<Vec<Option<super::VehiclePilotsEdge>>>;
        fn name() -> &'static str {
            "edges"
        }
    }
    impl ::cynic::schema::HasField<Edges> for super::VehiclePilotsConnection {
        type Type = Option<Vec<Option<super::VehiclePilotsEdge>>>;
    }
    pub struct TotalCount;
    impl ::cynic::schema::Field for TotalCount {
        type SchemaType = Option<super::Int>;
        fn name() -> &'static str {
            "totalCount"
        }
    }
    impl ::cynic::schema::HasField<TotalCount> for super::VehiclePilotsConnection {
        type Type = Option<super::Int>;
    }
    pub struct Pilots;
    impl ::cynic::schema::Field for Pilots {
        type SchemaType = Option<Vec<Option<super::Person>>>;
        fn name() -> &'static str {
            "pilots"
        }
    }
    impl ::cynic::schema::HasField<Pilots> for super::VehiclePilotsConnection {
        type Type = Option<Vec<Option<super::Person>>>;
    }
}
pub struct VehiclePilotsEdge;
pub mod vehicle_pilots_edge_fields {
    pub struct Node;
    impl ::cynic::schema::Field for Node {
        type SchemaType = Option<super::Person>;
        fn name() -> &'static str {
            "node"
        }
    }
    impl ::cynic::schema::HasField<Node> for super::VehiclePilotsEdge {
        type Type = Option<super::Person>;
    }
    pub struct Cursor;
    impl ::cynic::schema::Field for Cursor {
        type SchemaType = super::String;
        fn name() -> &'static str {
            "cursor"
        }
    }
    impl ::cynic::schema::HasField<Cursor> for super::VehiclePilotsEdge {
        type Type = super::String;
    }
}
pub struct VehiclesConnection;
pub mod vehicles_connection_fields {
    pub struct PageInfo;
    impl ::cynic::schema::Field for PageInfo {
        type SchemaType = super::PageInfo;
        fn name() -> &'static str {
            "pageInfo"
        }
    }
    impl ::cynic::schema::HasField<PageInfo> for super::VehiclesConnection {
        type Type = super::PageInfo;
    }
    pub struct Edges;
    impl ::cynic::schema::Field for Edges {
        type SchemaType = Option<Vec<Option<super::VehiclesEdge>>>;
        fn name() -> &'static str {
            "edges"
        }
    }
    impl ::cynic::schema::HasField<Edges> for super::VehiclesConnection {
        type Type = Option<Vec<Option<super::VehiclesEdge>>>;
    }
    pub struct TotalCount;
    impl ::cynic::schema::Field for TotalCount {
        type SchemaType = Option<super::Int>;
        fn name() -> &'static str {
            "totalCount"
        }
    }
    impl ::cynic::schema::HasField<TotalCount> for super::VehiclesConnection {
        type Type = Option<super::Int>;
    }
    pub struct Vehicles;
    impl ::cynic::schema::Field for Vehicles {
        type SchemaType = Option<Vec<Option<super::Vehicle>>>;
        fn name() -> &'static str {
            "vehicles"
        }
    }
    impl ::cynic::schema::HasField<Vehicles> for super::VehiclesConnection {
        type Type = Option<Vec<Option<super::Vehicle>>>;
    }
}
pub struct VehiclesEdge;
pub mod vehicles_edge_fields {
    pub struct Node;
    impl ::cynic::schema::Field for Node {
        type SchemaType = Option<super::Vehicle>;
        fn name() -> &'static str {
            "node"
        }
    }
    impl ::cynic::schema::HasField<Node> for super::VehiclesEdge {
        type Type = Option<super::Vehicle>;
    }
    pub struct Cursor;
    impl ::cynic::schema::Field for Cursor {
        type SchemaType = super::String;
        fn name() -> &'static str {
            "cursor"
        }
    }
    impl ::cynic::schema::HasField<Cursor> for super::VehiclesEdge {
        type Type = super::String;
    }
}
impl ::cynic::schema::HasSubtype<Film> for Node {}
impl ::cynic::schema::HasSubtype<Node> for Node {}
impl ::cynic::schema::HasSubtype<Person> for Node {}
impl ::cynic::schema::HasSubtype<Planet> for Node {}
impl ::cynic::schema::HasSubtype<Species> for Node {}
impl ::cynic::schema::HasSubtype<Starship> for Node {}
impl ::cynic::schema::HasSubtype<Vehicle> for Node {}
impl ::cynic::schema::NamedType for Film {
    fn name() -> &'static str {
        "Film"
    }
}
impl ::cynic::schema::NamedType for FilmCharactersConnection {
    fn name() -> &'static str {
        "FilmCharactersConnection"
    }
}
impl ::cynic::schema::NamedType for FilmCharactersEdge {
    fn name() -> &'static str {
        "FilmCharactersEdge"
    }
}
impl ::cynic::schema::NamedType for FilmPlanetsConnection {
    fn name() -> &'static str {
        "FilmPlanetsConnection"
    }
}
impl ::cynic::schema::NamedType for FilmPlanetsEdge {
    fn name() -> &'static str {
        "FilmPlanetsEdge"
    }
}
impl ::cynic::schema::NamedType for FilmSpeciesConnection {
    fn name() -> &'static str {
        "FilmSpeciesConnection"
    }
}
impl ::cynic::schema::NamedType for FilmSpeciesEdge {
    fn name() -> &'static str {
        "FilmSpeciesEdge"
    }
}
impl ::cynic::schema::NamedType for FilmStarshipsConnection {
    fn name() -> &'static str {
        "FilmStarshipsConnection"
    }
}
impl ::cynic::schema::NamedType for FilmStarshipsEdge {
    fn name() -> &'static str {
        "FilmStarshipsEdge"
    }
}
impl ::cynic::schema::NamedType for FilmVehiclesConnection {
    fn name() -> &'static str {
        "FilmVehiclesConnection"
    }
}
impl ::cynic::schema::NamedType for FilmVehiclesEdge {
    fn name() -> &'static str {
        "FilmVehiclesEdge"
    }
}
impl ::cynic::schema::NamedType for FilmsConnection {
    fn name() -> &'static str {
        "FilmsConnection"
    }
}
impl ::cynic::schema::NamedType for FilmsEdge {
    fn name() -> &'static str {
        "FilmsEdge"
    }
}
impl ::cynic::schema::NamedType for Node {
    fn name() -> &'static str {
        "Node"
    }
}
impl ::cynic::schema::NamedType for PageInfo {
    fn name() -> &'static str {
        "PageInfo"
    }
}
impl ::cynic::schema::NamedType for PeopleConnection {
    fn name() -> &'static str {
        "PeopleConnection"
    }
}
impl ::cynic::schema::NamedType for PeopleEdge {
    fn name() -> &'static str {
        "PeopleEdge"
    }
}
impl ::cynic::schema::NamedType for Person {
    fn name() -> &'static str {
        "Person"
    }
}
impl ::cynic::schema::NamedType for PersonFilmsConnection {
    fn name() -> &'static str {
        "PersonFilmsConnection"
    }
}
impl ::cynic::schema::NamedType for PersonFilmsEdge {
    fn name() -> &'static str {
        "PersonFilmsEdge"
    }
}
impl ::cynic::schema::NamedType for PersonStarshipsConnection {
    fn name() -> &'static str {
        "PersonStarshipsConnection"
    }
}
impl ::cynic::schema::NamedType for PersonStarshipsEdge {
    fn name() -> &'static str {
        "PersonStarshipsEdge"
    }
}
impl ::cynic::schema::NamedType for PersonVehiclesConnection {
    fn name() -> &'static str {
        "PersonVehiclesConnection"
    }
}
impl ::cynic::schema::NamedType for PersonVehiclesEdge {
    fn name() -> &'static str {
        "PersonVehiclesEdge"
    }
}
impl ::cynic::schema::NamedType for Planet {
    fn name() -> &'static str {
        "Planet"
    }
}
impl ::cynic::schema::NamedType for PlanetFilmsConnection {
    fn name() -> &'static str {
        "PlanetFilmsConnection"
    }
}
impl ::cynic::schema::NamedType for PlanetFilmsEdge {
    fn name() -> &'static str {
        "PlanetFilmsEdge"
    }
}
impl ::cynic::schema::NamedType for PlanetResidentsConnection {
    fn name() -> &'static str {
        "PlanetResidentsConnection"
    }
}
impl ::cynic::schema::NamedType for PlanetResidentsEdge {
    fn name() -> &'static str {
        "PlanetResidentsEdge"
    }
}
impl ::cynic::schema::NamedType for PlanetsConnection {
    fn name() -> &'static str {
        "PlanetsConnection"
    }
}
impl ::cynic::schema::NamedType for PlanetsEdge {
    fn name() -> &'static str {
        "PlanetsEdge"
    }
}
impl ::cynic::schema::NamedType for Root {
    fn name() -> &'static str {
        "Root"
    }
}
impl ::cynic::schema::NamedType for Species {
    fn name() -> &'static str {
        "Species"
    }
}
impl ::cynic::schema::NamedType for SpeciesConnection {
    fn name() -> &'static str {
        "SpeciesConnection"
    }
}
impl ::cynic::schema::NamedType for SpeciesEdge {
    fn name() -> &'static str {
        "SpeciesEdge"
    }
}
impl ::cynic::schema::NamedType for SpeciesFilmsConnection {
    fn name() -> &'static str {
        "SpeciesFilmsConnection"
    }
}
impl ::cynic::schema::NamedType for SpeciesFilmsEdge {
    fn name() -> &'static str {
        "SpeciesFilmsEdge"
    }
}
impl ::cynic::schema::NamedType for SpeciesPeopleConnection {
    fn name() -> &'static str {
        "SpeciesPeopleConnection"
    }
}
impl ::cynic::schema::NamedType for SpeciesPeopleEdge {
    fn name() -> &'static str {
        "SpeciesPeopleEdge"
    }
}
impl ::cynic::schema::NamedType for Starship {
    fn name() -> &'static str {
        "Starship"
    }
}
impl ::cynic::schema::NamedType for StarshipFilmsConnection {
    fn name() -> &'static str {
        "StarshipFilmsConnection"
    }
}
impl ::cynic::schema::NamedType for StarshipFilmsEdge {
    fn name() -> &'static str {
        "StarshipFilmsEdge"
    }
}
impl ::cynic::schema::NamedType for StarshipPilotsConnection {
    fn name() -> &'static str {
        "StarshipPilotsConnection"
    }
}
impl ::cynic::schema::NamedType for StarshipPilotsEdge {
    fn name() -> &'static str {
        "StarshipPilotsEdge"
    }
}
impl ::cynic::schema::NamedType for StarshipsConnection {
    fn name() -> &'static str {
        "StarshipsConnection"
    }
}
impl ::cynic::schema::NamedType for StarshipsEdge {
    fn name() -> &'static str {
        "StarshipsEdge"
    }
}
impl ::cynic::schema::NamedType for Vehicle {
    fn name() -> &'static str {
        "Vehicle"
    }
}
impl ::cynic::schema::NamedType for VehicleFilmsConnection {
    fn name() -> &'static str {
        "VehicleFilmsConnection"
    }
}
impl ::cynic::schema::NamedType for VehicleFilmsEdge {
    fn name() -> &'static str {
        "VehicleFilmsEdge"
    }
}
impl ::cynic::schema::NamedType for VehiclePilotsConnection {
    fn name() -> &'static str {
        "VehiclePilotsConnection"
    }
}
impl ::cynic::schema::NamedType for VehiclePilotsEdge {
    fn name() -> &'static str {
        "VehiclePilotsEdge"
    }
}
impl ::cynic::schema::NamedType for VehiclesConnection {
    fn name() -> &'static str {
        "VehiclesConnection"
    }
}
impl ::cynic::schema::NamedType for VehiclesEdge {
    fn name() -> &'static str {
        "VehiclesEdge"
    }
}
pub type Boolean = bool;
pub type String = std::string::String;
pub type Float = f64;
pub type Int = i32;
pub type Id = ::cynic::Id;
pub mod variable {
    use cynic::variables::VariableType;
    #[doc = r" Used to determine the type of a given variable that"]
    #[doc = r" appears in an argument struct."]
    pub trait Variable {
        const TYPE: VariableType;
    }
    impl<T> Variable for &T
    where
        T: Variable,
    {
        const TYPE: VariableType = T::TYPE;
    }
    impl<T> Variable for Option<T>
    where
        T: Variable,
    {
        const TYPE: VariableType = VariableType::Nullable(&T::TYPE);
    }
    impl<T> Variable for Vec<T>
    where
        T: Variable,
    {
        const TYPE: VariableType = VariableType::List(&T::TYPE);
    }
    impl<T> Variable for Box<T>
    where
        T: Variable,
    {
        const TYPE: VariableType = T::TYPE;
    }
    impl<T> Variable for std::rc::Rc<T>
    where
        T: Variable,
    {
        const TYPE: VariableType = T::TYPE;
    }
    impl<T> Variable for std::sync::Arc<T>
    where
        T: Variable,
    {
        const TYPE: VariableType = T::TYPE;
    }
    impl Variable for bool {
        const TYPE: VariableType = VariableType::Named("Boolean");
    }
    impl Variable for String {
        const TYPE: VariableType = VariableType::Named("String");
    }
    impl Variable for f64 {
        const TYPE: VariableType = VariableType::Named("Float");
    }
    impl Variable for i32 {
        const TYPE: VariableType = VariableType::Named("Int");
    }
    impl Variable for ::cynic::Id {
        const TYPE: VariableType = VariableType::Named("ID");
    }
}

