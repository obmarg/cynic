---
source: cynic-codegen/tests/use-schema.rs
assertion_line: 25
expression: "format_code(format!(\"{}\", tokens))"

---
impl ::cynic::schema::QueryRoot for Root {}
pub struct Film;
pub mod film_fields {
    pub struct Title;
    impl ::cynic::schema::Field for Title {
        type Type = Option<super::String>;
        const NAME: &'static str = "title";
    }
    impl ::cynic::schema::HasField<Title> for super::Film {
        type Type = Option<super::String>;
    }
    pub struct EpisodeId;
    impl ::cynic::schema::Field for EpisodeId {
        type Type = Option<super::Int>;
        const NAME: &'static str = "episodeID";
    }
    impl ::cynic::schema::HasField<EpisodeId> for super::Film {
        type Type = Option<super::Int>;
    }
    pub struct OpeningCrawl;
    impl ::cynic::schema::Field for OpeningCrawl {
        type Type = Option<super::String>;
        const NAME: &'static str = "openingCrawl";
    }
    impl ::cynic::schema::HasField<OpeningCrawl> for super::Film {
        type Type = Option<super::String>;
    }
    pub struct Director;
    impl ::cynic::schema::Field for Director {
        type Type = Option<super::String>;
        const NAME: &'static str = "director";
    }
    impl ::cynic::schema::HasField<Director> for super::Film {
        type Type = Option<super::String>;
    }
    pub struct Producers;
    impl ::cynic::schema::Field for Producers {
        type Type = Option<Vec<Option<super::String>>>;
        const NAME: &'static str = "producers";
    }
    impl ::cynic::schema::HasField<Producers> for super::Film {
        type Type = Option<Vec<Option<super::String>>>;
    }
    pub struct ReleaseDate;
    impl ::cynic::schema::Field for ReleaseDate {
        type Type = Option<super::String>;
        const NAME: &'static str = "releaseDate";
    }
    impl ::cynic::schema::HasField<ReleaseDate> for super::Film {
        type Type = Option<super::String>;
    }
    pub struct SpeciesConnection;
    impl ::cynic::schema::Field for SpeciesConnection {
        type Type = Option<super::FilmSpeciesConnection>;
        const NAME: &'static str = "speciesConnection";
    }
    impl ::cynic::schema::HasField<SpeciesConnection> for super::Film {
        type Type = Option<super::FilmSpeciesConnection>;
    }
    pub mod species_connection_arguments {
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::SpeciesConnection {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "after";
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::SpeciesConnection {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "first";
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::SpeciesConnection {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "before";
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::SpeciesConnection {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "last";
        }
    }
    pub struct StarshipConnection;
    impl ::cynic::schema::Field for StarshipConnection {
        type Type = Option<super::FilmStarshipsConnection>;
        const NAME: &'static str = "starshipConnection";
    }
    impl ::cynic::schema::HasField<StarshipConnection> for super::Film {
        type Type = Option<super::FilmStarshipsConnection>;
    }
    pub mod starship_connection_arguments {
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::StarshipConnection {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "after";
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::StarshipConnection {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "first";
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::StarshipConnection {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "before";
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::StarshipConnection {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "last";
        }
    }
    pub struct VehicleConnection;
    impl ::cynic::schema::Field for VehicleConnection {
        type Type = Option<super::FilmVehiclesConnection>;
        const NAME: &'static str = "vehicleConnection";
    }
    impl ::cynic::schema::HasField<VehicleConnection> for super::Film {
        type Type = Option<super::FilmVehiclesConnection>;
    }
    pub mod vehicle_connection_arguments {
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::VehicleConnection {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "after";
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::VehicleConnection {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "first";
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::VehicleConnection {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "before";
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::VehicleConnection {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "last";
        }
    }
    pub struct CharacterConnection;
    impl ::cynic::schema::Field for CharacterConnection {
        type Type = Option<super::FilmCharactersConnection>;
        const NAME: &'static str = "characterConnection";
    }
    impl ::cynic::schema::HasField<CharacterConnection> for super::Film {
        type Type = Option<super::FilmCharactersConnection>;
    }
    pub mod character_connection_arguments {
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::CharacterConnection {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "after";
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::CharacterConnection {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "first";
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::CharacterConnection {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "before";
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::CharacterConnection {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "last";
        }
    }
    pub struct PlanetConnection;
    impl ::cynic::schema::Field for PlanetConnection {
        type Type = Option<super::FilmPlanetsConnection>;
        const NAME: &'static str = "planetConnection";
    }
    impl ::cynic::schema::HasField<PlanetConnection> for super::Film {
        type Type = Option<super::FilmPlanetsConnection>;
    }
    pub mod planet_connection_arguments {
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::PlanetConnection {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "after";
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::PlanetConnection {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "first";
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::PlanetConnection {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "before";
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::PlanetConnection {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "last";
        }
    }
    pub struct Created;
    impl ::cynic::schema::Field for Created {
        type Type = Option<super::String>;
        const NAME: &'static str = "created";
    }
    impl ::cynic::schema::HasField<Created> for super::Film {
        type Type = Option<super::String>;
    }
    pub struct Edited;
    impl ::cynic::schema::Field for Edited {
        type Type = Option<super::String>;
        const NAME: &'static str = "edited";
    }
    impl ::cynic::schema::HasField<Edited> for super::Film {
        type Type = Option<super::String>;
    }
    pub struct Id;
    impl ::cynic::schema::Field for Id {
        type Type = super::Id;
        const NAME: &'static str = "id";
    }
    impl ::cynic::schema::HasField<Id> for super::Film {
        type Type = super::Id;
    }
}
pub struct FilmCharactersConnection;
pub mod film_characters_connection_fields {
    pub struct PageInfo;
    impl ::cynic::schema::Field for PageInfo {
        type Type = super::PageInfo;
        const NAME: &'static str = "pageInfo";
    }
    impl ::cynic::schema::HasField<PageInfo> for super::FilmCharactersConnection {
        type Type = super::PageInfo;
    }
    pub struct Edges;
    impl ::cynic::schema::Field for Edges {
        type Type = Option<Vec<Option<super::FilmCharactersEdge>>>;
        const NAME: &'static str = "edges";
    }
    impl ::cynic::schema::HasField<Edges> for super::FilmCharactersConnection {
        type Type = Option<Vec<Option<super::FilmCharactersEdge>>>;
    }
    pub struct TotalCount;
    impl ::cynic::schema::Field for TotalCount {
        type Type = Option<super::Int>;
        const NAME: &'static str = "totalCount";
    }
    impl ::cynic::schema::HasField<TotalCount> for super::FilmCharactersConnection {
        type Type = Option<super::Int>;
    }
    pub struct Characters;
    impl ::cynic::schema::Field for Characters {
        type Type = Option<Vec<Option<super::Person>>>;
        const NAME: &'static str = "characters";
    }
    impl ::cynic::schema::HasField<Characters> for super::FilmCharactersConnection {
        type Type = Option<Vec<Option<super::Person>>>;
    }
}
pub struct FilmCharactersEdge;
pub mod film_characters_edge_fields {
    pub struct Node;
    impl ::cynic::schema::Field for Node {
        type Type = Option<super::Person>;
        const NAME: &'static str = "node";
    }
    impl ::cynic::schema::HasField<Node> for super::FilmCharactersEdge {
        type Type = Option<super::Person>;
    }
    pub struct Cursor;
    impl ::cynic::schema::Field for Cursor {
        type Type = super::String;
        const NAME: &'static str = "cursor";
    }
    impl ::cynic::schema::HasField<Cursor> for super::FilmCharactersEdge {
        type Type = super::String;
    }
}
pub struct FilmPlanetsConnection;
pub mod film_planets_connection_fields {
    pub struct PageInfo;
    impl ::cynic::schema::Field for PageInfo {
        type Type = super::PageInfo;
        const NAME: &'static str = "pageInfo";
    }
    impl ::cynic::schema::HasField<PageInfo> for super::FilmPlanetsConnection {
        type Type = super::PageInfo;
    }
    pub struct Edges;
    impl ::cynic::schema::Field for Edges {
        type Type = Option<Vec<Option<super::FilmPlanetsEdge>>>;
        const NAME: &'static str = "edges";
    }
    impl ::cynic::schema::HasField<Edges> for super::FilmPlanetsConnection {
        type Type = Option<Vec<Option<super::FilmPlanetsEdge>>>;
    }
    pub struct TotalCount;
    impl ::cynic::schema::Field for TotalCount {
        type Type = Option<super::Int>;
        const NAME: &'static str = "totalCount";
    }
    impl ::cynic::schema::HasField<TotalCount> for super::FilmPlanetsConnection {
        type Type = Option<super::Int>;
    }
    pub struct Planets;
    impl ::cynic::schema::Field for Planets {
        type Type = Option<Vec<Option<super::Planet>>>;
        const NAME: &'static str = "planets";
    }
    impl ::cynic::schema::HasField<Planets> for super::FilmPlanetsConnection {
        type Type = Option<Vec<Option<super::Planet>>>;
    }
}
pub struct FilmPlanetsEdge;
pub mod film_planets_edge_fields {
    pub struct Node;
    impl ::cynic::schema::Field for Node {
        type Type = Option<super::Planet>;
        const NAME: &'static str = "node";
    }
    impl ::cynic::schema::HasField<Node> for super::FilmPlanetsEdge {
        type Type = Option<super::Planet>;
    }
    pub struct Cursor;
    impl ::cynic::schema::Field for Cursor {
        type Type = super::String;
        const NAME: &'static str = "cursor";
    }
    impl ::cynic::schema::HasField<Cursor> for super::FilmPlanetsEdge {
        type Type = super::String;
    }
}
pub struct FilmSpeciesConnection;
pub mod film_species_connection_fields {
    pub struct PageInfo;
    impl ::cynic::schema::Field for PageInfo {
        type Type = super::PageInfo;
        const NAME: &'static str = "pageInfo";
    }
    impl ::cynic::schema::HasField<PageInfo> for super::FilmSpeciesConnection {
        type Type = super::PageInfo;
    }
    pub struct Edges;
    impl ::cynic::schema::Field for Edges {
        type Type = Option<Vec<Option<super::FilmSpeciesEdge>>>;
        const NAME: &'static str = "edges";
    }
    impl ::cynic::schema::HasField<Edges> for super::FilmSpeciesConnection {
        type Type = Option<Vec<Option<super::FilmSpeciesEdge>>>;
    }
    pub struct TotalCount;
    impl ::cynic::schema::Field for TotalCount {
        type Type = Option<super::Int>;
        const NAME: &'static str = "totalCount";
    }
    impl ::cynic::schema::HasField<TotalCount> for super::FilmSpeciesConnection {
        type Type = Option<super::Int>;
    }
    pub struct Species;
    impl ::cynic::schema::Field for Species {
        type Type = Option<Vec<Option<super::Species>>>;
        const NAME: &'static str = "species";
    }
    impl ::cynic::schema::HasField<Species> for super::FilmSpeciesConnection {
        type Type = Option<Vec<Option<super::Species>>>;
    }
}
pub struct FilmSpeciesEdge;
pub mod film_species_edge_fields {
    pub struct Node;
    impl ::cynic::schema::Field for Node {
        type Type = Option<super::Species>;
        const NAME: &'static str = "node";
    }
    impl ::cynic::schema::HasField<Node> for super::FilmSpeciesEdge {
        type Type = Option<super::Species>;
    }
    pub struct Cursor;
    impl ::cynic::schema::Field for Cursor {
        type Type = super::String;
        const NAME: &'static str = "cursor";
    }
    impl ::cynic::schema::HasField<Cursor> for super::FilmSpeciesEdge {
        type Type = super::String;
    }
}
pub struct FilmStarshipsConnection;
pub mod film_starships_connection_fields {
    pub struct PageInfo;
    impl ::cynic::schema::Field for PageInfo {
        type Type = super::PageInfo;
        const NAME: &'static str = "pageInfo";
    }
    impl ::cynic::schema::HasField<PageInfo> for super::FilmStarshipsConnection {
        type Type = super::PageInfo;
    }
    pub struct Edges;
    impl ::cynic::schema::Field for Edges {
        type Type = Option<Vec<Option<super::FilmStarshipsEdge>>>;
        const NAME: &'static str = "edges";
    }
    impl ::cynic::schema::HasField<Edges> for super::FilmStarshipsConnection {
        type Type = Option<Vec<Option<super::FilmStarshipsEdge>>>;
    }
    pub struct TotalCount;
    impl ::cynic::schema::Field for TotalCount {
        type Type = Option<super::Int>;
        const NAME: &'static str = "totalCount";
    }
    impl ::cynic::schema::HasField<TotalCount> for super::FilmStarshipsConnection {
        type Type = Option<super::Int>;
    }
    pub struct Starships;
    impl ::cynic::schema::Field for Starships {
        type Type = Option<Vec<Option<super::Starship>>>;
        const NAME: &'static str = "starships";
    }
    impl ::cynic::schema::HasField<Starships> for super::FilmStarshipsConnection {
        type Type = Option<Vec<Option<super::Starship>>>;
    }
}
pub struct FilmStarshipsEdge;
pub mod film_starships_edge_fields {
    pub struct Node;
    impl ::cynic::schema::Field for Node {
        type Type = Option<super::Starship>;
        const NAME: &'static str = "node";
    }
    impl ::cynic::schema::HasField<Node> for super::FilmStarshipsEdge {
        type Type = Option<super::Starship>;
    }
    pub struct Cursor;
    impl ::cynic::schema::Field for Cursor {
        type Type = super::String;
        const NAME: &'static str = "cursor";
    }
    impl ::cynic::schema::HasField<Cursor> for super::FilmStarshipsEdge {
        type Type = super::String;
    }
}
pub struct FilmVehiclesConnection;
pub mod film_vehicles_connection_fields {
    pub struct PageInfo;
    impl ::cynic::schema::Field for PageInfo {
        type Type = super::PageInfo;
        const NAME: &'static str = "pageInfo";
    }
    impl ::cynic::schema::HasField<PageInfo> for super::FilmVehiclesConnection {
        type Type = super::PageInfo;
    }
    pub struct Edges;
    impl ::cynic::schema::Field for Edges {
        type Type = Option<Vec<Option<super::FilmVehiclesEdge>>>;
        const NAME: &'static str = "edges";
    }
    impl ::cynic::schema::HasField<Edges> for super::FilmVehiclesConnection {
        type Type = Option<Vec<Option<super::FilmVehiclesEdge>>>;
    }
    pub struct TotalCount;
    impl ::cynic::schema::Field for TotalCount {
        type Type = Option<super::Int>;
        const NAME: &'static str = "totalCount";
    }
    impl ::cynic::schema::HasField<TotalCount> for super::FilmVehiclesConnection {
        type Type = Option<super::Int>;
    }
    pub struct Vehicles;
    impl ::cynic::schema::Field for Vehicles {
        type Type = Option<Vec<Option<super::Vehicle>>>;
        const NAME: &'static str = "vehicles";
    }
    impl ::cynic::schema::HasField<Vehicles> for super::FilmVehiclesConnection {
        type Type = Option<Vec<Option<super::Vehicle>>>;
    }
}
pub struct FilmVehiclesEdge;
pub mod film_vehicles_edge_fields {
    pub struct Node;
    impl ::cynic::schema::Field for Node {
        type Type = Option<super::Vehicle>;
        const NAME: &'static str = "node";
    }
    impl ::cynic::schema::HasField<Node> for super::FilmVehiclesEdge {
        type Type = Option<super::Vehicle>;
    }
    pub struct Cursor;
    impl ::cynic::schema::Field for Cursor {
        type Type = super::String;
        const NAME: &'static str = "cursor";
    }
    impl ::cynic::schema::HasField<Cursor> for super::FilmVehiclesEdge {
        type Type = super::String;
    }
}
pub struct FilmsConnection;
pub mod films_connection_fields {
    pub struct PageInfo;
    impl ::cynic::schema::Field for PageInfo {
        type Type = super::PageInfo;
        const NAME: &'static str = "pageInfo";
    }
    impl ::cynic::schema::HasField<PageInfo> for super::FilmsConnection {
        type Type = super::PageInfo;
    }
    pub struct Edges;
    impl ::cynic::schema::Field for Edges {
        type Type = Option<Vec<Option<super::FilmsEdge>>>;
        const NAME: &'static str = "edges";
    }
    impl ::cynic::schema::HasField<Edges> for super::FilmsConnection {
        type Type = Option<Vec<Option<super::FilmsEdge>>>;
    }
    pub struct TotalCount;
    impl ::cynic::schema::Field for TotalCount {
        type Type = Option<super::Int>;
        const NAME: &'static str = "totalCount";
    }
    impl ::cynic::schema::HasField<TotalCount> for super::FilmsConnection {
        type Type = Option<super::Int>;
    }
    pub struct Films;
    impl ::cynic::schema::Field for Films {
        type Type = Option<Vec<Option<super::Film>>>;
        const NAME: &'static str = "films";
    }
    impl ::cynic::schema::HasField<Films> for super::FilmsConnection {
        type Type = Option<Vec<Option<super::Film>>>;
    }
}
pub struct FilmsEdge;
pub mod films_edge_fields {
    pub struct Node;
    impl ::cynic::schema::Field for Node {
        type Type = Option<super::Film>;
        const NAME: &'static str = "node";
    }
    impl ::cynic::schema::HasField<Node> for super::FilmsEdge {
        type Type = Option<super::Film>;
    }
    pub struct Cursor;
    impl ::cynic::schema::Field for Cursor {
        type Type = super::String;
        const NAME: &'static str = "cursor";
    }
    impl ::cynic::schema::HasField<Cursor> for super::FilmsEdge {
        type Type = super::String;
    }
}
pub struct Node;
pub mod node_fields {
    pub struct Id;
    impl ::cynic::schema::Field for Id {
        type Type = super::Id;
        const NAME: &'static str = "id";
    }
    impl ::cynic::schema::HasField<Id> for super::Node {
        type Type = super::Id;
    }
}
pub struct PageInfo;
pub mod page_info_fields {
    pub struct HasNextPage;
    impl ::cynic::schema::Field for HasNextPage {
        type Type = super::Boolean;
        const NAME: &'static str = "hasNextPage";
    }
    impl ::cynic::schema::HasField<HasNextPage> for super::PageInfo {
        type Type = super::Boolean;
    }
    pub struct HasPreviousPage;
    impl ::cynic::schema::Field for HasPreviousPage {
        type Type = super::Boolean;
        const NAME: &'static str = "hasPreviousPage";
    }
    impl ::cynic::schema::HasField<HasPreviousPage> for super::PageInfo {
        type Type = super::Boolean;
    }
    pub struct StartCursor;
    impl ::cynic::schema::Field for StartCursor {
        type Type = Option<super::String>;
        const NAME: &'static str = "startCursor";
    }
    impl ::cynic::schema::HasField<StartCursor> for super::PageInfo {
        type Type = Option<super::String>;
    }
    pub struct EndCursor;
    impl ::cynic::schema::Field for EndCursor {
        type Type = Option<super::String>;
        const NAME: &'static str = "endCursor";
    }
    impl ::cynic::schema::HasField<EndCursor> for super::PageInfo {
        type Type = Option<super::String>;
    }
}
pub struct PeopleConnection;
pub mod people_connection_fields {
    pub struct PageInfo;
    impl ::cynic::schema::Field for PageInfo {
        type Type = super::PageInfo;
        const NAME: &'static str = "pageInfo";
    }
    impl ::cynic::schema::HasField<PageInfo> for super::PeopleConnection {
        type Type = super::PageInfo;
    }
    pub struct Edges;
    impl ::cynic::schema::Field for Edges {
        type Type = Option<Vec<Option<super::PeopleEdge>>>;
        const NAME: &'static str = "edges";
    }
    impl ::cynic::schema::HasField<Edges> for super::PeopleConnection {
        type Type = Option<Vec<Option<super::PeopleEdge>>>;
    }
    pub struct TotalCount;
    impl ::cynic::schema::Field for TotalCount {
        type Type = Option<super::Int>;
        const NAME: &'static str = "totalCount";
    }
    impl ::cynic::schema::HasField<TotalCount> for super::PeopleConnection {
        type Type = Option<super::Int>;
    }
    pub struct People;
    impl ::cynic::schema::Field for People {
        type Type = Option<Vec<Option<super::Person>>>;
        const NAME: &'static str = "people";
    }
    impl ::cynic::schema::HasField<People> for super::PeopleConnection {
        type Type = Option<Vec<Option<super::Person>>>;
    }
}
pub struct PeopleEdge;
pub mod people_edge_fields {
    pub struct Node;
    impl ::cynic::schema::Field for Node {
        type Type = Option<super::Person>;
        const NAME: &'static str = "node";
    }
    impl ::cynic::schema::HasField<Node> for super::PeopleEdge {
        type Type = Option<super::Person>;
    }
    pub struct Cursor;
    impl ::cynic::schema::Field for Cursor {
        type Type = super::String;
        const NAME: &'static str = "cursor";
    }
    impl ::cynic::schema::HasField<Cursor> for super::PeopleEdge {
        type Type = super::String;
    }
}
pub struct Person;
pub mod person_fields {
    pub struct Name;
    impl ::cynic::schema::Field for Name {
        type Type = Option<super::String>;
        const NAME: &'static str = "name";
    }
    impl ::cynic::schema::HasField<Name> for super::Person {
        type Type = Option<super::String>;
    }
    pub struct BirthYear;
    impl ::cynic::schema::Field for BirthYear {
        type Type = Option<super::String>;
        const NAME: &'static str = "birthYear";
    }
    impl ::cynic::schema::HasField<BirthYear> for super::Person {
        type Type = Option<super::String>;
    }
    pub struct EyeColor;
    impl ::cynic::schema::Field for EyeColor {
        type Type = Option<super::String>;
        const NAME: &'static str = "eyeColor";
    }
    impl ::cynic::schema::HasField<EyeColor> for super::Person {
        type Type = Option<super::String>;
    }
    pub struct Gender;
    impl ::cynic::schema::Field for Gender {
        type Type = Option<super::String>;
        const NAME: &'static str = "gender";
    }
    impl ::cynic::schema::HasField<Gender> for super::Person {
        type Type = Option<super::String>;
    }
    pub struct HairColor;
    impl ::cynic::schema::Field for HairColor {
        type Type = Option<super::String>;
        const NAME: &'static str = "hairColor";
    }
    impl ::cynic::schema::HasField<HairColor> for super::Person {
        type Type = Option<super::String>;
    }
    pub struct Height;
    impl ::cynic::schema::Field for Height {
        type Type = Option<super::Int>;
        const NAME: &'static str = "height";
    }
    impl ::cynic::schema::HasField<Height> for super::Person {
        type Type = Option<super::Int>;
    }
    pub struct Mass;
    impl ::cynic::schema::Field for Mass {
        type Type = Option<super::Float>;
        const NAME: &'static str = "mass";
    }
    impl ::cynic::schema::HasField<Mass> for super::Person {
        type Type = Option<super::Float>;
    }
    pub struct SkinColor;
    impl ::cynic::schema::Field for SkinColor {
        type Type = Option<super::String>;
        const NAME: &'static str = "skinColor";
    }
    impl ::cynic::schema::HasField<SkinColor> for super::Person {
        type Type = Option<super::String>;
    }
    pub struct Homeworld;
    impl ::cynic::schema::Field for Homeworld {
        type Type = Option<super::Planet>;
        const NAME: &'static str = "homeworld";
    }
    impl ::cynic::schema::HasField<Homeworld> for super::Person {
        type Type = Option<super::Planet>;
    }
    pub struct FilmConnection;
    impl ::cynic::schema::Field for FilmConnection {
        type Type = Option<super::PersonFilmsConnection>;
        const NAME: &'static str = "filmConnection";
    }
    impl ::cynic::schema::HasField<FilmConnection> for super::Person {
        type Type = Option<super::PersonFilmsConnection>;
    }
    pub mod film_connection_arguments {
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::FilmConnection {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "after";
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::FilmConnection {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "first";
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::FilmConnection {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "before";
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::FilmConnection {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "last";
        }
    }
    pub struct Species;
    impl ::cynic::schema::Field for Species {
        type Type = Option<super::Species>;
        const NAME: &'static str = "species";
    }
    impl ::cynic::schema::HasField<Species> for super::Person {
        type Type = Option<super::Species>;
    }
    pub struct StarshipConnection;
    impl ::cynic::schema::Field for StarshipConnection {
        type Type = Option<super::PersonStarshipsConnection>;
        const NAME: &'static str = "starshipConnection";
    }
    impl ::cynic::schema::HasField<StarshipConnection> for super::Person {
        type Type = Option<super::PersonStarshipsConnection>;
    }
    pub mod starship_connection_arguments {
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::StarshipConnection {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "after";
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::StarshipConnection {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "first";
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::StarshipConnection {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "before";
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::StarshipConnection {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "last";
        }
    }
    pub struct VehicleConnection;
    impl ::cynic::schema::Field for VehicleConnection {
        type Type = Option<super::PersonVehiclesConnection>;
        const NAME: &'static str = "vehicleConnection";
    }
    impl ::cynic::schema::HasField<VehicleConnection> for super::Person {
        type Type = Option<super::PersonVehiclesConnection>;
    }
    pub mod vehicle_connection_arguments {
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::VehicleConnection {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "after";
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::VehicleConnection {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "first";
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::VehicleConnection {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "before";
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::VehicleConnection {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "last";
        }
    }
    pub struct Created;
    impl ::cynic::schema::Field for Created {
        type Type = Option<super::String>;
        const NAME: &'static str = "created";
    }
    impl ::cynic::schema::HasField<Created> for super::Person {
        type Type = Option<super::String>;
    }
    pub struct Edited;
    impl ::cynic::schema::Field for Edited {
        type Type = Option<super::String>;
        const NAME: &'static str = "edited";
    }
    impl ::cynic::schema::HasField<Edited> for super::Person {
        type Type = Option<super::String>;
    }
    pub struct Id;
    impl ::cynic::schema::Field for Id {
        type Type = super::Id;
        const NAME: &'static str = "id";
    }
    impl ::cynic::schema::HasField<Id> for super::Person {
        type Type = super::Id;
    }
}
pub struct PersonFilmsConnection;
pub mod person_films_connection_fields {
    pub struct PageInfo;
    impl ::cynic::schema::Field for PageInfo {
        type Type = super::PageInfo;
        const NAME: &'static str = "pageInfo";
    }
    impl ::cynic::schema::HasField<PageInfo> for super::PersonFilmsConnection {
        type Type = super::PageInfo;
    }
    pub struct Edges;
    impl ::cynic::schema::Field for Edges {
        type Type = Option<Vec<Option<super::PersonFilmsEdge>>>;
        const NAME: &'static str = "edges";
    }
    impl ::cynic::schema::HasField<Edges> for super::PersonFilmsConnection {
        type Type = Option<Vec<Option<super::PersonFilmsEdge>>>;
    }
    pub struct TotalCount;
    impl ::cynic::schema::Field for TotalCount {
        type Type = Option<super::Int>;
        const NAME: &'static str = "totalCount";
    }
    impl ::cynic::schema::HasField<TotalCount> for super::PersonFilmsConnection {
        type Type = Option<super::Int>;
    }
    pub struct Films;
    impl ::cynic::schema::Field for Films {
        type Type = Option<Vec<Option<super::Film>>>;
        const NAME: &'static str = "films";
    }
    impl ::cynic::schema::HasField<Films> for super::PersonFilmsConnection {
        type Type = Option<Vec<Option<super::Film>>>;
    }
}
pub struct PersonFilmsEdge;
pub mod person_films_edge_fields {
    pub struct Node;
    impl ::cynic::schema::Field for Node {
        type Type = Option<super::Film>;
        const NAME: &'static str = "node";
    }
    impl ::cynic::schema::HasField<Node> for super::PersonFilmsEdge {
        type Type = Option<super::Film>;
    }
    pub struct Cursor;
    impl ::cynic::schema::Field for Cursor {
        type Type = super::String;
        const NAME: &'static str = "cursor";
    }
    impl ::cynic::schema::HasField<Cursor> for super::PersonFilmsEdge {
        type Type = super::String;
    }
}
pub struct PersonStarshipsConnection;
pub mod person_starships_connection_fields {
    pub struct PageInfo;
    impl ::cynic::schema::Field for PageInfo {
        type Type = super::PageInfo;
        const NAME: &'static str = "pageInfo";
    }
    impl ::cynic::schema::HasField<PageInfo> for super::PersonStarshipsConnection {
        type Type = super::PageInfo;
    }
    pub struct Edges;
    impl ::cynic::schema::Field for Edges {
        type Type = Option<Vec<Option<super::PersonStarshipsEdge>>>;
        const NAME: &'static str = "edges";
    }
    impl ::cynic::schema::HasField<Edges> for super::PersonStarshipsConnection {
        type Type = Option<Vec<Option<super::PersonStarshipsEdge>>>;
    }
    pub struct TotalCount;
    impl ::cynic::schema::Field for TotalCount {
        type Type = Option<super::Int>;
        const NAME: &'static str = "totalCount";
    }
    impl ::cynic::schema::HasField<TotalCount> for super::PersonStarshipsConnection {
        type Type = Option<super::Int>;
    }
    pub struct Starships;
    impl ::cynic::schema::Field for Starships {
        type Type = Option<Vec<Option<super::Starship>>>;
        const NAME: &'static str = "starships";
    }
    impl ::cynic::schema::HasField<Starships> for super::PersonStarshipsConnection {
        type Type = Option<Vec<Option<super::Starship>>>;
    }
}
pub struct PersonStarshipsEdge;
pub mod person_starships_edge_fields {
    pub struct Node;
    impl ::cynic::schema::Field for Node {
        type Type = Option<super::Starship>;
        const NAME: &'static str = "node";
    }
    impl ::cynic::schema::HasField<Node> for super::PersonStarshipsEdge {
        type Type = Option<super::Starship>;
    }
    pub struct Cursor;
    impl ::cynic::schema::Field for Cursor {
        type Type = super::String;
        const NAME: &'static str = "cursor";
    }
    impl ::cynic::schema::HasField<Cursor> for super::PersonStarshipsEdge {
        type Type = super::String;
    }
}
pub struct PersonVehiclesConnection;
pub mod person_vehicles_connection_fields {
    pub struct PageInfo;
    impl ::cynic::schema::Field for PageInfo {
        type Type = super::PageInfo;
        const NAME: &'static str = "pageInfo";
    }
    impl ::cynic::schema::HasField<PageInfo> for super::PersonVehiclesConnection {
        type Type = super::PageInfo;
    }
    pub struct Edges;
    impl ::cynic::schema::Field for Edges {
        type Type = Option<Vec<Option<super::PersonVehiclesEdge>>>;
        const NAME: &'static str = "edges";
    }
    impl ::cynic::schema::HasField<Edges> for super::PersonVehiclesConnection {
        type Type = Option<Vec<Option<super::PersonVehiclesEdge>>>;
    }
    pub struct TotalCount;
    impl ::cynic::schema::Field for TotalCount {
        type Type = Option<super::Int>;
        const NAME: &'static str = "totalCount";
    }
    impl ::cynic::schema::HasField<TotalCount> for super::PersonVehiclesConnection {
        type Type = Option<super::Int>;
    }
    pub struct Vehicles;
    impl ::cynic::schema::Field for Vehicles {
        type Type = Option<Vec<Option<super::Vehicle>>>;
        const NAME: &'static str = "vehicles";
    }
    impl ::cynic::schema::HasField<Vehicles> for super::PersonVehiclesConnection {
        type Type = Option<Vec<Option<super::Vehicle>>>;
    }
}
pub struct PersonVehiclesEdge;
pub mod person_vehicles_edge_fields {
    pub struct Node;
    impl ::cynic::schema::Field for Node {
        type Type = Option<super::Vehicle>;
        const NAME: &'static str = "node";
    }
    impl ::cynic::schema::HasField<Node> for super::PersonVehiclesEdge {
        type Type = Option<super::Vehicle>;
    }
    pub struct Cursor;
    impl ::cynic::schema::Field for Cursor {
        type Type = super::String;
        const NAME: &'static str = "cursor";
    }
    impl ::cynic::schema::HasField<Cursor> for super::PersonVehiclesEdge {
        type Type = super::String;
    }
}
pub struct Planet;
pub mod planet_fields {
    pub struct Name;
    impl ::cynic::schema::Field for Name {
        type Type = Option<super::String>;
        const NAME: &'static str = "name";
    }
    impl ::cynic::schema::HasField<Name> for super::Planet {
        type Type = Option<super::String>;
    }
    pub struct Diameter;
    impl ::cynic::schema::Field for Diameter {
        type Type = Option<super::Int>;
        const NAME: &'static str = "diameter";
    }
    impl ::cynic::schema::HasField<Diameter> for super::Planet {
        type Type = Option<super::Int>;
    }
    pub struct RotationPeriod;
    impl ::cynic::schema::Field for RotationPeriod {
        type Type = Option<super::Int>;
        const NAME: &'static str = "rotationPeriod";
    }
    impl ::cynic::schema::HasField<RotationPeriod> for super::Planet {
        type Type = Option<super::Int>;
    }
    pub struct OrbitalPeriod;
    impl ::cynic::schema::Field for OrbitalPeriod {
        type Type = Option<super::Int>;
        const NAME: &'static str = "orbitalPeriod";
    }
    impl ::cynic::schema::HasField<OrbitalPeriod> for super::Planet {
        type Type = Option<super::Int>;
    }
    pub struct Gravity;
    impl ::cynic::schema::Field for Gravity {
        type Type = Option<super::String>;
        const NAME: &'static str = "gravity";
    }
    impl ::cynic::schema::HasField<Gravity> for super::Planet {
        type Type = Option<super::String>;
    }
    pub struct Population;
    impl ::cynic::schema::Field for Population {
        type Type = Option<super::Float>;
        const NAME: &'static str = "population";
    }
    impl ::cynic::schema::HasField<Population> for super::Planet {
        type Type = Option<super::Float>;
    }
    pub struct Climates;
    impl ::cynic::schema::Field for Climates {
        type Type = Option<Vec<Option<super::String>>>;
        const NAME: &'static str = "climates";
    }
    impl ::cynic::schema::HasField<Climates> for super::Planet {
        type Type = Option<Vec<Option<super::String>>>;
    }
    pub struct Terrains;
    impl ::cynic::schema::Field for Terrains {
        type Type = Option<Vec<Option<super::String>>>;
        const NAME: &'static str = "terrains";
    }
    impl ::cynic::schema::HasField<Terrains> for super::Planet {
        type Type = Option<Vec<Option<super::String>>>;
    }
    pub struct SurfaceWater;
    impl ::cynic::schema::Field for SurfaceWater {
        type Type = Option<super::Float>;
        const NAME: &'static str = "surfaceWater";
    }
    impl ::cynic::schema::HasField<SurfaceWater> for super::Planet {
        type Type = Option<super::Float>;
    }
    pub struct ResidentConnection;
    impl ::cynic::schema::Field for ResidentConnection {
        type Type = Option<super::PlanetResidentsConnection>;
        const NAME: &'static str = "residentConnection";
    }
    impl ::cynic::schema::HasField<ResidentConnection> for super::Planet {
        type Type = Option<super::PlanetResidentsConnection>;
    }
    pub mod resident_connection_arguments {
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::ResidentConnection {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "after";
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::ResidentConnection {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "first";
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::ResidentConnection {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "before";
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::ResidentConnection {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "last";
        }
    }
    pub struct FilmConnection;
    impl ::cynic::schema::Field for FilmConnection {
        type Type = Option<super::PlanetFilmsConnection>;
        const NAME: &'static str = "filmConnection";
    }
    impl ::cynic::schema::HasField<FilmConnection> for super::Planet {
        type Type = Option<super::PlanetFilmsConnection>;
    }
    pub mod film_connection_arguments {
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::FilmConnection {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "after";
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::FilmConnection {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "first";
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::FilmConnection {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "before";
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::FilmConnection {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "last";
        }
    }
    pub struct Created;
    impl ::cynic::schema::Field for Created {
        type Type = Option<super::String>;
        const NAME: &'static str = "created";
    }
    impl ::cynic::schema::HasField<Created> for super::Planet {
        type Type = Option<super::String>;
    }
    pub struct Edited;
    impl ::cynic::schema::Field for Edited {
        type Type = Option<super::String>;
        const NAME: &'static str = "edited";
    }
    impl ::cynic::schema::HasField<Edited> for super::Planet {
        type Type = Option<super::String>;
    }
    pub struct Id;
    impl ::cynic::schema::Field for Id {
        type Type = super::Id;
        const NAME: &'static str = "id";
    }
    impl ::cynic::schema::HasField<Id> for super::Planet {
        type Type = super::Id;
    }
}
pub struct PlanetFilmsConnection;
pub mod planet_films_connection_fields {
    pub struct PageInfo;
    impl ::cynic::schema::Field for PageInfo {
        type Type = super::PageInfo;
        const NAME: &'static str = "pageInfo";
    }
    impl ::cynic::schema::HasField<PageInfo> for super::PlanetFilmsConnection {
        type Type = super::PageInfo;
    }
    pub struct Edges;
    impl ::cynic::schema::Field for Edges {
        type Type = Option<Vec<Option<super::PlanetFilmsEdge>>>;
        const NAME: &'static str = "edges";
    }
    impl ::cynic::schema::HasField<Edges> for super::PlanetFilmsConnection {
        type Type = Option<Vec<Option<super::PlanetFilmsEdge>>>;
    }
    pub struct TotalCount;
    impl ::cynic::schema::Field for TotalCount {
        type Type = Option<super::Int>;
        const NAME: &'static str = "totalCount";
    }
    impl ::cynic::schema::HasField<TotalCount> for super::PlanetFilmsConnection {
        type Type = Option<super::Int>;
    }
    pub struct Films;
    impl ::cynic::schema::Field for Films {
        type Type = Option<Vec<Option<super::Film>>>;
        const NAME: &'static str = "films";
    }
    impl ::cynic::schema::HasField<Films> for super::PlanetFilmsConnection {
        type Type = Option<Vec<Option<super::Film>>>;
    }
}
pub struct PlanetFilmsEdge;
pub mod planet_films_edge_fields {
    pub struct Node;
    impl ::cynic::schema::Field for Node {
        type Type = Option<super::Film>;
        const NAME: &'static str = "node";
    }
    impl ::cynic::schema::HasField<Node> for super::PlanetFilmsEdge {
        type Type = Option<super::Film>;
    }
    pub struct Cursor;
    impl ::cynic::schema::Field for Cursor {
        type Type = super::String;
        const NAME: &'static str = "cursor";
    }
    impl ::cynic::schema::HasField<Cursor> for super::PlanetFilmsEdge {
        type Type = super::String;
    }
}
pub struct PlanetResidentsConnection;
pub mod planet_residents_connection_fields {
    pub struct PageInfo;
    impl ::cynic::schema::Field for PageInfo {
        type Type = super::PageInfo;
        const NAME: &'static str = "pageInfo";
    }
    impl ::cynic::schema::HasField<PageInfo> for super::PlanetResidentsConnection {
        type Type = super::PageInfo;
    }
    pub struct Edges;
    impl ::cynic::schema::Field for Edges {
        type Type = Option<Vec<Option<super::PlanetResidentsEdge>>>;
        const NAME: &'static str = "edges";
    }
    impl ::cynic::schema::HasField<Edges> for super::PlanetResidentsConnection {
        type Type = Option<Vec<Option<super::PlanetResidentsEdge>>>;
    }
    pub struct TotalCount;
    impl ::cynic::schema::Field for TotalCount {
        type Type = Option<super::Int>;
        const NAME: &'static str = "totalCount";
    }
    impl ::cynic::schema::HasField<TotalCount> for super::PlanetResidentsConnection {
        type Type = Option<super::Int>;
    }
    pub struct Residents;
    impl ::cynic::schema::Field for Residents {
        type Type = Option<Vec<Option<super::Person>>>;
        const NAME: &'static str = "residents";
    }
    impl ::cynic::schema::HasField<Residents> for super::PlanetResidentsConnection {
        type Type = Option<Vec<Option<super::Person>>>;
    }
}
pub struct PlanetResidentsEdge;
pub mod planet_residents_edge_fields {
    pub struct Node;
    impl ::cynic::schema::Field for Node {
        type Type = Option<super::Person>;
        const NAME: &'static str = "node";
    }
    impl ::cynic::schema::HasField<Node> for super::PlanetResidentsEdge {
        type Type = Option<super::Person>;
    }
    pub struct Cursor;
    impl ::cynic::schema::Field for Cursor {
        type Type = super::String;
        const NAME: &'static str = "cursor";
    }
    impl ::cynic::schema::HasField<Cursor> for super::PlanetResidentsEdge {
        type Type = super::String;
    }
}
pub struct PlanetsConnection;
pub mod planets_connection_fields {
    pub struct PageInfo;
    impl ::cynic::schema::Field for PageInfo {
        type Type = super::PageInfo;
        const NAME: &'static str = "pageInfo";
    }
    impl ::cynic::schema::HasField<PageInfo> for super::PlanetsConnection {
        type Type = super::PageInfo;
    }
    pub struct Edges;
    impl ::cynic::schema::Field for Edges {
        type Type = Option<Vec<Option<super::PlanetsEdge>>>;
        const NAME: &'static str = "edges";
    }
    impl ::cynic::schema::HasField<Edges> for super::PlanetsConnection {
        type Type = Option<Vec<Option<super::PlanetsEdge>>>;
    }
    pub struct TotalCount;
    impl ::cynic::schema::Field for TotalCount {
        type Type = Option<super::Int>;
        const NAME: &'static str = "totalCount";
    }
    impl ::cynic::schema::HasField<TotalCount> for super::PlanetsConnection {
        type Type = Option<super::Int>;
    }
    pub struct Planets;
    impl ::cynic::schema::Field for Planets {
        type Type = Option<Vec<Option<super::Planet>>>;
        const NAME: &'static str = "planets";
    }
    impl ::cynic::schema::HasField<Planets> for super::PlanetsConnection {
        type Type = Option<Vec<Option<super::Planet>>>;
    }
}
pub struct PlanetsEdge;
pub mod planets_edge_fields {
    pub struct Node;
    impl ::cynic::schema::Field for Node {
        type Type = Option<super::Planet>;
        const NAME: &'static str = "node";
    }
    impl ::cynic::schema::HasField<Node> for super::PlanetsEdge {
        type Type = Option<super::Planet>;
    }
    pub struct Cursor;
    impl ::cynic::schema::Field for Cursor {
        type Type = super::String;
        const NAME: &'static str = "cursor";
    }
    impl ::cynic::schema::HasField<Cursor> for super::PlanetsEdge {
        type Type = super::String;
    }
}
pub struct Root;
pub mod root_fields {
    pub struct AllFilms;
    impl ::cynic::schema::Field for AllFilms {
        type Type = Option<super::FilmsConnection>;
        const NAME: &'static str = "allFilms";
    }
    impl ::cynic::schema::HasField<AllFilms> for super::Root {
        type Type = Option<super::FilmsConnection>;
    }
    pub mod all_films_arguments {
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::AllFilms {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "after";
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::AllFilms {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "first";
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::AllFilms {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "before";
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::AllFilms {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "last";
        }
    }
    pub struct Film;
    impl ::cynic::schema::Field for Film {
        type Type = Option<super::Film>;
        const NAME: &'static str = "film";
    }
    impl ::cynic::schema::HasField<Film> for super::Root {
        type Type = Option<super::Film>;
    }
    pub mod film_arguments {
        pub struct Id;
        impl ::cynic::schema::HasArgument<Id> for super::Film {
            type ArgumentType = Option<super::super::Id>;
            const NAME: &'static str = "id";
        }
        pub struct FilmId;
        impl ::cynic::schema::HasArgument<FilmId> for super::Film {
            type ArgumentType = Option<super::super::Id>;
            const NAME: &'static str = "filmID";
        }
    }
    pub struct AllPeople;
    impl ::cynic::schema::Field for AllPeople {
        type Type = Option<super::PeopleConnection>;
        const NAME: &'static str = "allPeople";
    }
    impl ::cynic::schema::HasField<AllPeople> for super::Root {
        type Type = Option<super::PeopleConnection>;
    }
    pub mod all_people_arguments {
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::AllPeople {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "after";
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::AllPeople {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "first";
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::AllPeople {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "before";
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::AllPeople {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "last";
        }
    }
    pub struct Person;
    impl ::cynic::schema::Field for Person {
        type Type = Option<super::Person>;
        const NAME: &'static str = "person";
    }
    impl ::cynic::schema::HasField<Person> for super::Root {
        type Type = Option<super::Person>;
    }
    pub mod person_arguments {
        pub struct Id;
        impl ::cynic::schema::HasArgument<Id> for super::Person {
            type ArgumentType = Option<super::super::Id>;
            const NAME: &'static str = "id";
        }
        pub struct PersonId;
        impl ::cynic::schema::HasArgument<PersonId> for super::Person {
            type ArgumentType = Option<super::super::Id>;
            const NAME: &'static str = "personID";
        }
    }
    pub struct AllPlanets;
    impl ::cynic::schema::Field for AllPlanets {
        type Type = Option<super::PlanetsConnection>;
        const NAME: &'static str = "allPlanets";
    }
    impl ::cynic::schema::HasField<AllPlanets> for super::Root {
        type Type = Option<super::PlanetsConnection>;
    }
    pub mod all_planets_arguments {
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::AllPlanets {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "after";
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::AllPlanets {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "first";
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::AllPlanets {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "before";
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::AllPlanets {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "last";
        }
    }
    pub struct Planet;
    impl ::cynic::schema::Field for Planet {
        type Type = Option<super::Planet>;
        const NAME: &'static str = "planet";
    }
    impl ::cynic::schema::HasField<Planet> for super::Root {
        type Type = Option<super::Planet>;
    }
    pub mod planet_arguments {
        pub struct Id;
        impl ::cynic::schema::HasArgument<Id> for super::Planet {
            type ArgumentType = Option<super::super::Id>;
            const NAME: &'static str = "id";
        }
        pub struct PlanetId;
        impl ::cynic::schema::HasArgument<PlanetId> for super::Planet {
            type ArgumentType = Option<super::super::Id>;
            const NAME: &'static str = "planetID";
        }
    }
    pub struct AllSpecies;
    impl ::cynic::schema::Field for AllSpecies {
        type Type = Option<super::SpeciesConnection>;
        const NAME: &'static str = "allSpecies";
    }
    impl ::cynic::schema::HasField<AllSpecies> for super::Root {
        type Type = Option<super::SpeciesConnection>;
    }
    pub mod all_species_arguments {
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::AllSpecies {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "after";
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::AllSpecies {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "first";
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::AllSpecies {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "before";
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::AllSpecies {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "last";
        }
    }
    pub struct Species;
    impl ::cynic::schema::Field for Species {
        type Type = Option<super::Species>;
        const NAME: &'static str = "species";
    }
    impl ::cynic::schema::HasField<Species> for super::Root {
        type Type = Option<super::Species>;
    }
    pub mod species_arguments {
        pub struct Id;
        impl ::cynic::schema::HasArgument<Id> for super::Species {
            type ArgumentType = Option<super::super::Id>;
            const NAME: &'static str = "id";
        }
        pub struct SpeciesId;
        impl ::cynic::schema::HasArgument<SpeciesId> for super::Species {
            type ArgumentType = Option<super::super::Id>;
            const NAME: &'static str = "speciesID";
        }
    }
    pub struct AllStarships;
    impl ::cynic::schema::Field for AllStarships {
        type Type = Option<super::StarshipsConnection>;
        const NAME: &'static str = "allStarships";
    }
    impl ::cynic::schema::HasField<AllStarships> for super::Root {
        type Type = Option<super::StarshipsConnection>;
    }
    pub mod all_starships_arguments {
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::AllStarships {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "after";
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::AllStarships {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "first";
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::AllStarships {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "before";
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::AllStarships {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "last";
        }
    }
    pub struct Starship;
    impl ::cynic::schema::Field for Starship {
        type Type = Option<super::Starship>;
        const NAME: &'static str = "starship";
    }
    impl ::cynic::schema::HasField<Starship> for super::Root {
        type Type = Option<super::Starship>;
    }
    pub mod starship_arguments {
        pub struct Id;
        impl ::cynic::schema::HasArgument<Id> for super::Starship {
            type ArgumentType = Option<super::super::Id>;
            const NAME: &'static str = "id";
        }
        pub struct StarshipId;
        impl ::cynic::schema::HasArgument<StarshipId> for super::Starship {
            type ArgumentType = Option<super::super::Id>;
            const NAME: &'static str = "starshipID";
        }
    }
    pub struct AllVehicles;
    impl ::cynic::schema::Field for AllVehicles {
        type Type = Option<super::VehiclesConnection>;
        const NAME: &'static str = "allVehicles";
    }
    impl ::cynic::schema::HasField<AllVehicles> for super::Root {
        type Type = Option<super::VehiclesConnection>;
    }
    pub mod all_vehicles_arguments {
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::AllVehicles {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "after";
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::AllVehicles {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "first";
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::AllVehicles {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "before";
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::AllVehicles {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "last";
        }
    }
    pub struct Vehicle;
    impl ::cynic::schema::Field for Vehicle {
        type Type = Option<super::Vehicle>;
        const NAME: &'static str = "vehicle";
    }
    impl ::cynic::schema::HasField<Vehicle> for super::Root {
        type Type = Option<super::Vehicle>;
    }
    pub mod vehicle_arguments {
        pub struct Id;
        impl ::cynic::schema::HasArgument<Id> for super::Vehicle {
            type ArgumentType = Option<super::super::Id>;
            const NAME: &'static str = "id";
        }
        pub struct VehicleId;
        impl ::cynic::schema::HasArgument<VehicleId> for super::Vehicle {
            type ArgumentType = Option<super::super::Id>;
            const NAME: &'static str = "vehicleID";
        }
    }
    pub struct Node;
    impl ::cynic::schema::Field for Node {
        type Type = Option<super::Node>;
        const NAME: &'static str = "node";
    }
    impl ::cynic::schema::HasField<Node> for super::Root {
        type Type = Option<super::Node>;
    }
    pub mod node_arguments {
        pub struct Id;
        impl ::cynic::schema::HasArgument<Id> for super::Node {
            type ArgumentType = super::super::Id;
            const NAME: &'static str = "id";
        }
    }
}
pub struct Species;
pub mod species_fields {
    pub struct Name;
    impl ::cynic::schema::Field for Name {
        type Type = Option<super::String>;
        const NAME: &'static str = "name";
    }
    impl ::cynic::schema::HasField<Name> for super::Species {
        type Type = Option<super::String>;
    }
    pub struct Classification;
    impl ::cynic::schema::Field for Classification {
        type Type = Option<super::String>;
        const NAME: &'static str = "classification";
    }
    impl ::cynic::schema::HasField<Classification> for super::Species {
        type Type = Option<super::String>;
    }
    pub struct Designation;
    impl ::cynic::schema::Field for Designation {
        type Type = Option<super::String>;
        const NAME: &'static str = "designation";
    }
    impl ::cynic::schema::HasField<Designation> for super::Species {
        type Type = Option<super::String>;
    }
    pub struct AverageHeight;
    impl ::cynic::schema::Field for AverageHeight {
        type Type = Option<super::Float>;
        const NAME: &'static str = "averageHeight";
    }
    impl ::cynic::schema::HasField<AverageHeight> for super::Species {
        type Type = Option<super::Float>;
    }
    pub struct AverageLifespan;
    impl ::cynic::schema::Field for AverageLifespan {
        type Type = Option<super::Int>;
        const NAME: &'static str = "averageLifespan";
    }
    impl ::cynic::schema::HasField<AverageLifespan> for super::Species {
        type Type = Option<super::Int>;
    }
    pub struct EyeColors;
    impl ::cynic::schema::Field for EyeColors {
        type Type = Option<Vec<Option<super::String>>>;
        const NAME: &'static str = "eyeColors";
    }
    impl ::cynic::schema::HasField<EyeColors> for super::Species {
        type Type = Option<Vec<Option<super::String>>>;
    }
    pub struct HairColors;
    impl ::cynic::schema::Field for HairColors {
        type Type = Option<Vec<Option<super::String>>>;
        const NAME: &'static str = "hairColors";
    }
    impl ::cynic::schema::HasField<HairColors> for super::Species {
        type Type = Option<Vec<Option<super::String>>>;
    }
    pub struct SkinColors;
    impl ::cynic::schema::Field for SkinColors {
        type Type = Option<Vec<Option<super::String>>>;
        const NAME: &'static str = "skinColors";
    }
    impl ::cynic::schema::HasField<SkinColors> for super::Species {
        type Type = Option<Vec<Option<super::String>>>;
    }
    pub struct Language;
    impl ::cynic::schema::Field for Language {
        type Type = Option<super::String>;
        const NAME: &'static str = "language";
    }
    impl ::cynic::schema::HasField<Language> for super::Species {
        type Type = Option<super::String>;
    }
    pub struct Homeworld;
    impl ::cynic::schema::Field for Homeworld {
        type Type = Option<super::Planet>;
        const NAME: &'static str = "homeworld";
    }
    impl ::cynic::schema::HasField<Homeworld> for super::Species {
        type Type = Option<super::Planet>;
    }
    pub struct PersonConnection;
    impl ::cynic::schema::Field for PersonConnection {
        type Type = Option<super::SpeciesPeopleConnection>;
        const NAME: &'static str = "personConnection";
    }
    impl ::cynic::schema::HasField<PersonConnection> for super::Species {
        type Type = Option<super::SpeciesPeopleConnection>;
    }
    pub mod person_connection_arguments {
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::PersonConnection {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "after";
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::PersonConnection {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "first";
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::PersonConnection {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "before";
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::PersonConnection {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "last";
        }
    }
    pub struct FilmConnection;
    impl ::cynic::schema::Field for FilmConnection {
        type Type = Option<super::SpeciesFilmsConnection>;
        const NAME: &'static str = "filmConnection";
    }
    impl ::cynic::schema::HasField<FilmConnection> for super::Species {
        type Type = Option<super::SpeciesFilmsConnection>;
    }
    pub mod film_connection_arguments {
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::FilmConnection {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "after";
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::FilmConnection {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "first";
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::FilmConnection {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "before";
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::FilmConnection {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "last";
        }
    }
    pub struct Created;
    impl ::cynic::schema::Field for Created {
        type Type = Option<super::String>;
        const NAME: &'static str = "created";
    }
    impl ::cynic::schema::HasField<Created> for super::Species {
        type Type = Option<super::String>;
    }
    pub struct Edited;
    impl ::cynic::schema::Field for Edited {
        type Type = Option<super::String>;
        const NAME: &'static str = "edited";
    }
    impl ::cynic::schema::HasField<Edited> for super::Species {
        type Type = Option<super::String>;
    }
    pub struct Id;
    impl ::cynic::schema::Field for Id {
        type Type = super::Id;
        const NAME: &'static str = "id";
    }
    impl ::cynic::schema::HasField<Id> for super::Species {
        type Type = super::Id;
    }
}
pub struct SpeciesConnection;
pub mod species_connection_fields {
    pub struct PageInfo;
    impl ::cynic::schema::Field for PageInfo {
        type Type = super::PageInfo;
        const NAME: &'static str = "pageInfo";
    }
    impl ::cynic::schema::HasField<PageInfo> for super::SpeciesConnection {
        type Type = super::PageInfo;
    }
    pub struct Edges;
    impl ::cynic::schema::Field for Edges {
        type Type = Option<Vec<Option<super::SpeciesEdge>>>;
        const NAME: &'static str = "edges";
    }
    impl ::cynic::schema::HasField<Edges> for super::SpeciesConnection {
        type Type = Option<Vec<Option<super::SpeciesEdge>>>;
    }
    pub struct TotalCount;
    impl ::cynic::schema::Field for TotalCount {
        type Type = Option<super::Int>;
        const NAME: &'static str = "totalCount";
    }
    impl ::cynic::schema::HasField<TotalCount> for super::SpeciesConnection {
        type Type = Option<super::Int>;
    }
    pub struct Species;
    impl ::cynic::schema::Field for Species {
        type Type = Option<Vec<Option<super::Species>>>;
        const NAME: &'static str = "species";
    }
    impl ::cynic::schema::HasField<Species> for super::SpeciesConnection {
        type Type = Option<Vec<Option<super::Species>>>;
    }
}
pub struct SpeciesEdge;
pub mod species_edge_fields {
    pub struct Node;
    impl ::cynic::schema::Field for Node {
        type Type = Option<super::Species>;
        const NAME: &'static str = "node";
    }
    impl ::cynic::schema::HasField<Node> for super::SpeciesEdge {
        type Type = Option<super::Species>;
    }
    pub struct Cursor;
    impl ::cynic::schema::Field for Cursor {
        type Type = super::String;
        const NAME: &'static str = "cursor";
    }
    impl ::cynic::schema::HasField<Cursor> for super::SpeciesEdge {
        type Type = super::String;
    }
}
pub struct SpeciesFilmsConnection;
pub mod species_films_connection_fields {
    pub struct PageInfo;
    impl ::cynic::schema::Field for PageInfo {
        type Type = super::PageInfo;
        const NAME: &'static str = "pageInfo";
    }
    impl ::cynic::schema::HasField<PageInfo> for super::SpeciesFilmsConnection {
        type Type = super::PageInfo;
    }
    pub struct Edges;
    impl ::cynic::schema::Field for Edges {
        type Type = Option<Vec<Option<super::SpeciesFilmsEdge>>>;
        const NAME: &'static str = "edges";
    }
    impl ::cynic::schema::HasField<Edges> for super::SpeciesFilmsConnection {
        type Type = Option<Vec<Option<super::SpeciesFilmsEdge>>>;
    }
    pub struct TotalCount;
    impl ::cynic::schema::Field for TotalCount {
        type Type = Option<super::Int>;
        const NAME: &'static str = "totalCount";
    }
    impl ::cynic::schema::HasField<TotalCount> for super::SpeciesFilmsConnection {
        type Type = Option<super::Int>;
    }
    pub struct Films;
    impl ::cynic::schema::Field for Films {
        type Type = Option<Vec<Option<super::Film>>>;
        const NAME: &'static str = "films";
    }
    impl ::cynic::schema::HasField<Films> for super::SpeciesFilmsConnection {
        type Type = Option<Vec<Option<super::Film>>>;
    }
}
pub struct SpeciesFilmsEdge;
pub mod species_films_edge_fields {
    pub struct Node;
    impl ::cynic::schema::Field for Node {
        type Type = Option<super::Film>;
        const NAME: &'static str = "node";
    }
    impl ::cynic::schema::HasField<Node> for super::SpeciesFilmsEdge {
        type Type = Option<super::Film>;
    }
    pub struct Cursor;
    impl ::cynic::schema::Field for Cursor {
        type Type = super::String;
        const NAME: &'static str = "cursor";
    }
    impl ::cynic::schema::HasField<Cursor> for super::SpeciesFilmsEdge {
        type Type = super::String;
    }
}
pub struct SpeciesPeopleConnection;
pub mod species_people_connection_fields {
    pub struct PageInfo;
    impl ::cynic::schema::Field for PageInfo {
        type Type = super::PageInfo;
        const NAME: &'static str = "pageInfo";
    }
    impl ::cynic::schema::HasField<PageInfo> for super::SpeciesPeopleConnection {
        type Type = super::PageInfo;
    }
    pub struct Edges;
    impl ::cynic::schema::Field for Edges {
        type Type = Option<Vec<Option<super::SpeciesPeopleEdge>>>;
        const NAME: &'static str = "edges";
    }
    impl ::cynic::schema::HasField<Edges> for super::SpeciesPeopleConnection {
        type Type = Option<Vec<Option<super::SpeciesPeopleEdge>>>;
    }
    pub struct TotalCount;
    impl ::cynic::schema::Field for TotalCount {
        type Type = Option<super::Int>;
        const NAME: &'static str = "totalCount";
    }
    impl ::cynic::schema::HasField<TotalCount> for super::SpeciesPeopleConnection {
        type Type = Option<super::Int>;
    }
    pub struct People;
    impl ::cynic::schema::Field for People {
        type Type = Option<Vec<Option<super::Person>>>;
        const NAME: &'static str = "people";
    }
    impl ::cynic::schema::HasField<People> for super::SpeciesPeopleConnection {
        type Type = Option<Vec<Option<super::Person>>>;
    }
}
pub struct SpeciesPeopleEdge;
pub mod species_people_edge_fields {
    pub struct Node;
    impl ::cynic::schema::Field for Node {
        type Type = Option<super::Person>;
        const NAME: &'static str = "node";
    }
    impl ::cynic::schema::HasField<Node> for super::SpeciesPeopleEdge {
        type Type = Option<super::Person>;
    }
    pub struct Cursor;
    impl ::cynic::schema::Field for Cursor {
        type Type = super::String;
        const NAME: &'static str = "cursor";
    }
    impl ::cynic::schema::HasField<Cursor> for super::SpeciesPeopleEdge {
        type Type = super::String;
    }
}
pub struct Starship;
pub mod starship_fields {
    pub struct Name;
    impl ::cynic::schema::Field for Name {
        type Type = Option<super::String>;
        const NAME: &'static str = "name";
    }
    impl ::cynic::schema::HasField<Name> for super::Starship {
        type Type = Option<super::String>;
    }
    pub struct Model;
    impl ::cynic::schema::Field for Model {
        type Type = Option<super::String>;
        const NAME: &'static str = "model";
    }
    impl ::cynic::schema::HasField<Model> for super::Starship {
        type Type = Option<super::String>;
    }
    pub struct StarshipClass;
    impl ::cynic::schema::Field for StarshipClass {
        type Type = Option<super::String>;
        const NAME: &'static str = "starshipClass";
    }
    impl ::cynic::schema::HasField<StarshipClass> for super::Starship {
        type Type = Option<super::String>;
    }
    pub struct Manufacturers;
    impl ::cynic::schema::Field for Manufacturers {
        type Type = Option<Vec<Option<super::String>>>;
        const NAME: &'static str = "manufacturers";
    }
    impl ::cynic::schema::HasField<Manufacturers> for super::Starship {
        type Type = Option<Vec<Option<super::String>>>;
    }
    pub struct CostInCredits;
    impl ::cynic::schema::Field for CostInCredits {
        type Type = Option<super::Float>;
        const NAME: &'static str = "costInCredits";
    }
    impl ::cynic::schema::HasField<CostInCredits> for super::Starship {
        type Type = Option<super::Float>;
    }
    pub struct Length;
    impl ::cynic::schema::Field for Length {
        type Type = Option<super::Float>;
        const NAME: &'static str = "length";
    }
    impl ::cynic::schema::HasField<Length> for super::Starship {
        type Type = Option<super::Float>;
    }
    pub struct Crew;
    impl ::cynic::schema::Field for Crew {
        type Type = Option<super::String>;
        const NAME: &'static str = "crew";
    }
    impl ::cynic::schema::HasField<Crew> for super::Starship {
        type Type = Option<super::String>;
    }
    pub struct Passengers;
    impl ::cynic::schema::Field for Passengers {
        type Type = Option<super::String>;
        const NAME: &'static str = "passengers";
    }
    impl ::cynic::schema::HasField<Passengers> for super::Starship {
        type Type = Option<super::String>;
    }
    pub struct MaxAtmospheringSpeed;
    impl ::cynic::schema::Field for MaxAtmospheringSpeed {
        type Type = Option<super::Int>;
        const NAME: &'static str = "maxAtmospheringSpeed";
    }
    impl ::cynic::schema::HasField<MaxAtmospheringSpeed> for super::Starship {
        type Type = Option<super::Int>;
    }
    pub struct HyperdriveRating;
    impl ::cynic::schema::Field for HyperdriveRating {
        type Type = Option<super::Float>;
        const NAME: &'static str = "hyperdriveRating";
    }
    impl ::cynic::schema::HasField<HyperdriveRating> for super::Starship {
        type Type = Option<super::Float>;
    }
    pub struct Mglt;
    impl ::cynic::schema::Field for Mglt {
        type Type = Option<super::Int>;
        const NAME: &'static str = "MGLT";
    }
    impl ::cynic::schema::HasField<Mglt> for super::Starship {
        type Type = Option<super::Int>;
    }
    pub struct CargoCapacity;
    impl ::cynic::schema::Field for CargoCapacity {
        type Type = Option<super::Float>;
        const NAME: &'static str = "cargoCapacity";
    }
    impl ::cynic::schema::HasField<CargoCapacity> for super::Starship {
        type Type = Option<super::Float>;
    }
    pub struct Consumables;
    impl ::cynic::schema::Field for Consumables {
        type Type = Option<super::String>;
        const NAME: &'static str = "consumables";
    }
    impl ::cynic::schema::HasField<Consumables> for super::Starship {
        type Type = Option<super::String>;
    }
    pub struct PilotConnection;
    impl ::cynic::schema::Field for PilotConnection {
        type Type = Option<super::StarshipPilotsConnection>;
        const NAME: &'static str = "pilotConnection";
    }
    impl ::cynic::schema::HasField<PilotConnection> for super::Starship {
        type Type = Option<super::StarshipPilotsConnection>;
    }
    pub mod pilot_connection_arguments {
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::PilotConnection {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "after";
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::PilotConnection {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "first";
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::PilotConnection {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "before";
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::PilotConnection {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "last";
        }
    }
    pub struct FilmConnection;
    impl ::cynic::schema::Field for FilmConnection {
        type Type = Option<super::StarshipFilmsConnection>;
        const NAME: &'static str = "filmConnection";
    }
    impl ::cynic::schema::HasField<FilmConnection> for super::Starship {
        type Type = Option<super::StarshipFilmsConnection>;
    }
    pub mod film_connection_arguments {
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::FilmConnection {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "after";
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::FilmConnection {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "first";
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::FilmConnection {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "before";
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::FilmConnection {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "last";
        }
    }
    pub struct Created;
    impl ::cynic::schema::Field for Created {
        type Type = Option<super::String>;
        const NAME: &'static str = "created";
    }
    impl ::cynic::schema::HasField<Created> for super::Starship {
        type Type = Option<super::String>;
    }
    pub struct Edited;
    impl ::cynic::schema::Field for Edited {
        type Type = Option<super::String>;
        const NAME: &'static str = "edited";
    }
    impl ::cynic::schema::HasField<Edited> for super::Starship {
        type Type = Option<super::String>;
    }
    pub struct Id;
    impl ::cynic::schema::Field for Id {
        type Type = super::Id;
        const NAME: &'static str = "id";
    }
    impl ::cynic::schema::HasField<Id> for super::Starship {
        type Type = super::Id;
    }
}
pub struct StarshipFilmsConnection;
pub mod starship_films_connection_fields {
    pub struct PageInfo;
    impl ::cynic::schema::Field for PageInfo {
        type Type = super::PageInfo;
        const NAME: &'static str = "pageInfo";
    }
    impl ::cynic::schema::HasField<PageInfo> for super::StarshipFilmsConnection {
        type Type = super::PageInfo;
    }
    pub struct Edges;
    impl ::cynic::schema::Field for Edges {
        type Type = Option<Vec<Option<super::StarshipFilmsEdge>>>;
        const NAME: &'static str = "edges";
    }
    impl ::cynic::schema::HasField<Edges> for super::StarshipFilmsConnection {
        type Type = Option<Vec<Option<super::StarshipFilmsEdge>>>;
    }
    pub struct TotalCount;
    impl ::cynic::schema::Field for TotalCount {
        type Type = Option<super::Int>;
        const NAME: &'static str = "totalCount";
    }
    impl ::cynic::schema::HasField<TotalCount> for super::StarshipFilmsConnection {
        type Type = Option<super::Int>;
    }
    pub struct Films;
    impl ::cynic::schema::Field for Films {
        type Type = Option<Vec<Option<super::Film>>>;
        const NAME: &'static str = "films";
    }
    impl ::cynic::schema::HasField<Films> for super::StarshipFilmsConnection {
        type Type = Option<Vec<Option<super::Film>>>;
    }
}
pub struct StarshipFilmsEdge;
pub mod starship_films_edge_fields {
    pub struct Node;
    impl ::cynic::schema::Field for Node {
        type Type = Option<super::Film>;
        const NAME: &'static str = "node";
    }
    impl ::cynic::schema::HasField<Node> for super::StarshipFilmsEdge {
        type Type = Option<super::Film>;
    }
    pub struct Cursor;
    impl ::cynic::schema::Field for Cursor {
        type Type = super::String;
        const NAME: &'static str = "cursor";
    }
    impl ::cynic::schema::HasField<Cursor> for super::StarshipFilmsEdge {
        type Type = super::String;
    }
}
pub struct StarshipPilotsConnection;
pub mod starship_pilots_connection_fields {
    pub struct PageInfo;
    impl ::cynic::schema::Field for PageInfo {
        type Type = super::PageInfo;
        const NAME: &'static str = "pageInfo";
    }
    impl ::cynic::schema::HasField<PageInfo> for super::StarshipPilotsConnection {
        type Type = super::PageInfo;
    }
    pub struct Edges;
    impl ::cynic::schema::Field for Edges {
        type Type = Option<Vec<Option<super::StarshipPilotsEdge>>>;
        const NAME: &'static str = "edges";
    }
    impl ::cynic::schema::HasField<Edges> for super::StarshipPilotsConnection {
        type Type = Option<Vec<Option<super::StarshipPilotsEdge>>>;
    }
    pub struct TotalCount;
    impl ::cynic::schema::Field for TotalCount {
        type Type = Option<super::Int>;
        const NAME: &'static str = "totalCount";
    }
    impl ::cynic::schema::HasField<TotalCount> for super::StarshipPilotsConnection {
        type Type = Option<super::Int>;
    }
    pub struct Pilots;
    impl ::cynic::schema::Field for Pilots {
        type Type = Option<Vec<Option<super::Person>>>;
        const NAME: &'static str = "pilots";
    }
    impl ::cynic::schema::HasField<Pilots> for super::StarshipPilotsConnection {
        type Type = Option<Vec<Option<super::Person>>>;
    }
}
pub struct StarshipPilotsEdge;
pub mod starship_pilots_edge_fields {
    pub struct Node;
    impl ::cynic::schema::Field for Node {
        type Type = Option<super::Person>;
        const NAME: &'static str = "node";
    }
    impl ::cynic::schema::HasField<Node> for super::StarshipPilotsEdge {
        type Type = Option<super::Person>;
    }
    pub struct Cursor;
    impl ::cynic::schema::Field for Cursor {
        type Type = super::String;
        const NAME: &'static str = "cursor";
    }
    impl ::cynic::schema::HasField<Cursor> for super::StarshipPilotsEdge {
        type Type = super::String;
    }
}
pub struct StarshipsConnection;
pub mod starships_connection_fields {
    pub struct PageInfo;
    impl ::cynic::schema::Field for PageInfo {
        type Type = super::PageInfo;
        const NAME: &'static str = "pageInfo";
    }
    impl ::cynic::schema::HasField<PageInfo> for super::StarshipsConnection {
        type Type = super::PageInfo;
    }
    pub struct Edges;
    impl ::cynic::schema::Field for Edges {
        type Type = Option<Vec<Option<super::StarshipsEdge>>>;
        const NAME: &'static str = "edges";
    }
    impl ::cynic::schema::HasField<Edges> for super::StarshipsConnection {
        type Type = Option<Vec<Option<super::StarshipsEdge>>>;
    }
    pub struct TotalCount;
    impl ::cynic::schema::Field for TotalCount {
        type Type = Option<super::Int>;
        const NAME: &'static str = "totalCount";
    }
    impl ::cynic::schema::HasField<TotalCount> for super::StarshipsConnection {
        type Type = Option<super::Int>;
    }
    pub struct Starships;
    impl ::cynic::schema::Field for Starships {
        type Type = Option<Vec<Option<super::Starship>>>;
        const NAME: &'static str = "starships";
    }
    impl ::cynic::schema::HasField<Starships> for super::StarshipsConnection {
        type Type = Option<Vec<Option<super::Starship>>>;
    }
}
pub struct StarshipsEdge;
pub mod starships_edge_fields {
    pub struct Node;
    impl ::cynic::schema::Field for Node {
        type Type = Option<super::Starship>;
        const NAME: &'static str = "node";
    }
    impl ::cynic::schema::HasField<Node> for super::StarshipsEdge {
        type Type = Option<super::Starship>;
    }
    pub struct Cursor;
    impl ::cynic::schema::Field for Cursor {
        type Type = super::String;
        const NAME: &'static str = "cursor";
    }
    impl ::cynic::schema::HasField<Cursor> for super::StarshipsEdge {
        type Type = super::String;
    }
}
pub struct Vehicle;
pub mod vehicle_fields {
    pub struct Name;
    impl ::cynic::schema::Field for Name {
        type Type = Option<super::String>;
        const NAME: &'static str = "name";
    }
    impl ::cynic::schema::HasField<Name> for super::Vehicle {
        type Type = Option<super::String>;
    }
    pub struct Model;
    impl ::cynic::schema::Field for Model {
        type Type = Option<super::String>;
        const NAME: &'static str = "model";
    }
    impl ::cynic::schema::HasField<Model> for super::Vehicle {
        type Type = Option<super::String>;
    }
    pub struct VehicleClass;
    impl ::cynic::schema::Field for VehicleClass {
        type Type = Option<super::String>;
        const NAME: &'static str = "vehicleClass";
    }
    impl ::cynic::schema::HasField<VehicleClass> for super::Vehicle {
        type Type = Option<super::String>;
    }
    pub struct Manufacturers;
    impl ::cynic::schema::Field for Manufacturers {
        type Type = Option<Vec<Option<super::String>>>;
        const NAME: &'static str = "manufacturers";
    }
    impl ::cynic::schema::HasField<Manufacturers> for super::Vehicle {
        type Type = Option<Vec<Option<super::String>>>;
    }
    pub struct CostInCredits;
    impl ::cynic::schema::Field for CostInCredits {
        type Type = Option<super::Float>;
        const NAME: &'static str = "costInCredits";
    }
    impl ::cynic::schema::HasField<CostInCredits> for super::Vehicle {
        type Type = Option<super::Float>;
    }
    pub struct Length;
    impl ::cynic::schema::Field for Length {
        type Type = Option<super::Float>;
        const NAME: &'static str = "length";
    }
    impl ::cynic::schema::HasField<Length> for super::Vehicle {
        type Type = Option<super::Float>;
    }
    pub struct Crew;
    impl ::cynic::schema::Field for Crew {
        type Type = Option<super::String>;
        const NAME: &'static str = "crew";
    }
    impl ::cynic::schema::HasField<Crew> for super::Vehicle {
        type Type = Option<super::String>;
    }
    pub struct Passengers;
    impl ::cynic::schema::Field for Passengers {
        type Type = Option<super::String>;
        const NAME: &'static str = "passengers";
    }
    impl ::cynic::schema::HasField<Passengers> for super::Vehicle {
        type Type = Option<super::String>;
    }
    pub struct MaxAtmospheringSpeed;
    impl ::cynic::schema::Field for MaxAtmospheringSpeed {
        type Type = Option<super::Int>;
        const NAME: &'static str = "maxAtmospheringSpeed";
    }
    impl ::cynic::schema::HasField<MaxAtmospheringSpeed> for super::Vehicle {
        type Type = Option<super::Int>;
    }
    pub struct CargoCapacity;
    impl ::cynic::schema::Field for CargoCapacity {
        type Type = Option<super::Float>;
        const NAME: &'static str = "cargoCapacity";
    }
    impl ::cynic::schema::HasField<CargoCapacity> for super::Vehicle {
        type Type = Option<super::Float>;
    }
    pub struct Consumables;
    impl ::cynic::schema::Field for Consumables {
        type Type = Option<super::String>;
        const NAME: &'static str = "consumables";
    }
    impl ::cynic::schema::HasField<Consumables> for super::Vehicle {
        type Type = Option<super::String>;
    }
    pub struct PilotConnection;
    impl ::cynic::schema::Field for PilotConnection {
        type Type = Option<super::VehiclePilotsConnection>;
        const NAME: &'static str = "pilotConnection";
    }
    impl ::cynic::schema::HasField<PilotConnection> for super::Vehicle {
        type Type = Option<super::VehiclePilotsConnection>;
    }
    pub mod pilot_connection_arguments {
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::PilotConnection {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "after";
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::PilotConnection {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "first";
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::PilotConnection {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "before";
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::PilotConnection {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "last";
        }
    }
    pub struct FilmConnection;
    impl ::cynic::schema::Field for FilmConnection {
        type Type = Option<super::VehicleFilmsConnection>;
        const NAME: &'static str = "filmConnection";
    }
    impl ::cynic::schema::HasField<FilmConnection> for super::Vehicle {
        type Type = Option<super::VehicleFilmsConnection>;
    }
    pub mod film_connection_arguments {
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::FilmConnection {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "after";
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::FilmConnection {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "first";
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::FilmConnection {
            type ArgumentType = Option<super::super::String>;
            const NAME: &'static str = "before";
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::FilmConnection {
            type ArgumentType = Option<super::super::Int>;
            const NAME: &'static str = "last";
        }
    }
    pub struct Created;
    impl ::cynic::schema::Field for Created {
        type Type = Option<super::String>;
        const NAME: &'static str = "created";
    }
    impl ::cynic::schema::HasField<Created> for super::Vehicle {
        type Type = Option<super::String>;
    }
    pub struct Edited;
    impl ::cynic::schema::Field for Edited {
        type Type = Option<super::String>;
        const NAME: &'static str = "edited";
    }
    impl ::cynic::schema::HasField<Edited> for super::Vehicle {
        type Type = Option<super::String>;
    }
    pub struct Id;
    impl ::cynic::schema::Field for Id {
        type Type = super::Id;
        const NAME: &'static str = "id";
    }
    impl ::cynic::schema::HasField<Id> for super::Vehicle {
        type Type = super::Id;
    }
}
pub struct VehicleFilmsConnection;
pub mod vehicle_films_connection_fields {
    pub struct PageInfo;
    impl ::cynic::schema::Field for PageInfo {
        type Type = super::PageInfo;
        const NAME: &'static str = "pageInfo";
    }
    impl ::cynic::schema::HasField<PageInfo> for super::VehicleFilmsConnection {
        type Type = super::PageInfo;
    }
    pub struct Edges;
    impl ::cynic::schema::Field for Edges {
        type Type = Option<Vec<Option<super::VehicleFilmsEdge>>>;
        const NAME: &'static str = "edges";
    }
    impl ::cynic::schema::HasField<Edges> for super::VehicleFilmsConnection {
        type Type = Option<Vec<Option<super::VehicleFilmsEdge>>>;
    }
    pub struct TotalCount;
    impl ::cynic::schema::Field for TotalCount {
        type Type = Option<super::Int>;
        const NAME: &'static str = "totalCount";
    }
    impl ::cynic::schema::HasField<TotalCount> for super::VehicleFilmsConnection {
        type Type = Option<super::Int>;
    }
    pub struct Films;
    impl ::cynic::schema::Field for Films {
        type Type = Option<Vec<Option<super::Film>>>;
        const NAME: &'static str = "films";
    }
    impl ::cynic::schema::HasField<Films> for super::VehicleFilmsConnection {
        type Type = Option<Vec<Option<super::Film>>>;
    }
}
pub struct VehicleFilmsEdge;
pub mod vehicle_films_edge_fields {
    pub struct Node;
    impl ::cynic::schema::Field for Node {
        type Type = Option<super::Film>;
        const NAME: &'static str = "node";
    }
    impl ::cynic::schema::HasField<Node> for super::VehicleFilmsEdge {
        type Type = Option<super::Film>;
    }
    pub struct Cursor;
    impl ::cynic::schema::Field for Cursor {
        type Type = super::String;
        const NAME: &'static str = "cursor";
    }
    impl ::cynic::schema::HasField<Cursor> for super::VehicleFilmsEdge {
        type Type = super::String;
    }
}
pub struct VehiclePilotsConnection;
pub mod vehicle_pilots_connection_fields {
    pub struct PageInfo;
    impl ::cynic::schema::Field for PageInfo {
        type Type = super::PageInfo;
        const NAME: &'static str = "pageInfo";
    }
    impl ::cynic::schema::HasField<PageInfo> for super::VehiclePilotsConnection {
        type Type = super::PageInfo;
    }
    pub struct Edges;
    impl ::cynic::schema::Field for Edges {
        type Type = Option<Vec<Option<super::VehiclePilotsEdge>>>;
        const NAME: &'static str = "edges";
    }
    impl ::cynic::schema::HasField<Edges> for super::VehiclePilotsConnection {
        type Type = Option<Vec<Option<super::VehiclePilotsEdge>>>;
    }
    pub struct TotalCount;
    impl ::cynic::schema::Field for TotalCount {
        type Type = Option<super::Int>;
        const NAME: &'static str = "totalCount";
    }
    impl ::cynic::schema::HasField<TotalCount> for super::VehiclePilotsConnection {
        type Type = Option<super::Int>;
    }
    pub struct Pilots;
    impl ::cynic::schema::Field for Pilots {
        type Type = Option<Vec<Option<super::Person>>>;
        const NAME: &'static str = "pilots";
    }
    impl ::cynic::schema::HasField<Pilots> for super::VehiclePilotsConnection {
        type Type = Option<Vec<Option<super::Person>>>;
    }
}
pub struct VehiclePilotsEdge;
pub mod vehicle_pilots_edge_fields {
    pub struct Node;
    impl ::cynic::schema::Field for Node {
        type Type = Option<super::Person>;
        const NAME: &'static str = "node";
    }
    impl ::cynic::schema::HasField<Node> for super::VehiclePilotsEdge {
        type Type = Option<super::Person>;
    }
    pub struct Cursor;
    impl ::cynic::schema::Field for Cursor {
        type Type = super::String;
        const NAME: &'static str = "cursor";
    }
    impl ::cynic::schema::HasField<Cursor> for super::VehiclePilotsEdge {
        type Type = super::String;
    }
}
pub struct VehiclesConnection;
pub mod vehicles_connection_fields {
    pub struct PageInfo;
    impl ::cynic::schema::Field for PageInfo {
        type Type = super::PageInfo;
        const NAME: &'static str = "pageInfo";
    }
    impl ::cynic::schema::HasField<PageInfo> for super::VehiclesConnection {
        type Type = super::PageInfo;
    }
    pub struct Edges;
    impl ::cynic::schema::Field for Edges {
        type Type = Option<Vec<Option<super::VehiclesEdge>>>;
        const NAME: &'static str = "edges";
    }
    impl ::cynic::schema::HasField<Edges> for super::VehiclesConnection {
        type Type = Option<Vec<Option<super::VehiclesEdge>>>;
    }
    pub struct TotalCount;
    impl ::cynic::schema::Field for TotalCount {
        type Type = Option<super::Int>;
        const NAME: &'static str = "totalCount";
    }
    impl ::cynic::schema::HasField<TotalCount> for super::VehiclesConnection {
        type Type = Option<super::Int>;
    }
    pub struct Vehicles;
    impl ::cynic::schema::Field for Vehicles {
        type Type = Option<Vec<Option<super::Vehicle>>>;
        const NAME: &'static str = "vehicles";
    }
    impl ::cynic::schema::HasField<Vehicles> for super::VehiclesConnection {
        type Type = Option<Vec<Option<super::Vehicle>>>;
    }
}
pub struct VehiclesEdge;
pub mod vehicles_edge_fields {
    pub struct Node;
    impl ::cynic::schema::Field for Node {
        type Type = Option<super::Vehicle>;
        const NAME: &'static str = "node";
    }
    impl ::cynic::schema::HasField<Node> for super::VehiclesEdge {
        type Type = Option<super::Vehicle>;
    }
    pub struct Cursor;
    impl ::cynic::schema::Field for Cursor {
        type Type = super::String;
        const NAME: &'static str = "cursor";
    }
    impl ::cynic::schema::HasField<Cursor> for super::VehiclesEdge {
        type Type = super::String;
    }
}
impl ::cynic::schema::HasSubtype<Film> for Node {}
impl ::cynic::schema::HasSubtype<Node> for Node {}
impl ::cynic::schema::HasSubtype<Person> for Node {}
impl ::cynic::schema::HasSubtype<Planet> for Node {}
impl ::cynic::schema::HasSubtype<Species> for Node {}
impl ::cynic::schema::HasSubtype<Starship> for Node {}
impl ::cynic::schema::HasSubtype<Vehicle> for Node {}
impl ::cynic::schema::NamedType for Film {
    const NAME: &'static str = "Film";
}
impl ::cynic::schema::NamedType for FilmCharactersConnection {
    const NAME: &'static str = "FilmCharactersConnection";
}
impl ::cynic::schema::NamedType for FilmCharactersEdge {
    const NAME: &'static str = "FilmCharactersEdge";
}
impl ::cynic::schema::NamedType for FilmPlanetsConnection {
    const NAME: &'static str = "FilmPlanetsConnection";
}
impl ::cynic::schema::NamedType for FilmPlanetsEdge {
    const NAME: &'static str = "FilmPlanetsEdge";
}
impl ::cynic::schema::NamedType for FilmSpeciesConnection {
    const NAME: &'static str = "FilmSpeciesConnection";
}
impl ::cynic::schema::NamedType for FilmSpeciesEdge {
    const NAME: &'static str = "FilmSpeciesEdge";
}
impl ::cynic::schema::NamedType for FilmStarshipsConnection {
    const NAME: &'static str = "FilmStarshipsConnection";
}
impl ::cynic::schema::NamedType for FilmStarshipsEdge {
    const NAME: &'static str = "FilmStarshipsEdge";
}
impl ::cynic::schema::NamedType for FilmVehiclesConnection {
    const NAME: &'static str = "FilmVehiclesConnection";
}
impl ::cynic::schema::NamedType for FilmVehiclesEdge {
    const NAME: &'static str = "FilmVehiclesEdge";
}
impl ::cynic::schema::NamedType for FilmsConnection {
    const NAME: &'static str = "FilmsConnection";
}
impl ::cynic::schema::NamedType for FilmsEdge {
    const NAME: &'static str = "FilmsEdge";
}
impl ::cynic::schema::NamedType for Node {
    const NAME: &'static str = "Node";
}
impl ::cynic::schema::NamedType for PageInfo {
    const NAME: &'static str = "PageInfo";
}
impl ::cynic::schema::NamedType for PeopleConnection {
    const NAME: &'static str = "PeopleConnection";
}
impl ::cynic::schema::NamedType for PeopleEdge {
    const NAME: &'static str = "PeopleEdge";
}
impl ::cynic::schema::NamedType for Person {
    const NAME: &'static str = "Person";
}
impl ::cynic::schema::NamedType for PersonFilmsConnection {
    const NAME: &'static str = "PersonFilmsConnection";
}
impl ::cynic::schema::NamedType for PersonFilmsEdge {
    const NAME: &'static str = "PersonFilmsEdge";
}
impl ::cynic::schema::NamedType for PersonStarshipsConnection {
    const NAME: &'static str = "PersonStarshipsConnection";
}
impl ::cynic::schema::NamedType for PersonStarshipsEdge {
    const NAME: &'static str = "PersonStarshipsEdge";
}
impl ::cynic::schema::NamedType for PersonVehiclesConnection {
    const NAME: &'static str = "PersonVehiclesConnection";
}
impl ::cynic::schema::NamedType for PersonVehiclesEdge {
    const NAME: &'static str = "PersonVehiclesEdge";
}
impl ::cynic::schema::NamedType for Planet {
    const NAME: &'static str = "Planet";
}
impl ::cynic::schema::NamedType for PlanetFilmsConnection {
    const NAME: &'static str = "PlanetFilmsConnection";
}
impl ::cynic::schema::NamedType for PlanetFilmsEdge {
    const NAME: &'static str = "PlanetFilmsEdge";
}
impl ::cynic::schema::NamedType for PlanetResidentsConnection {
    const NAME: &'static str = "PlanetResidentsConnection";
}
impl ::cynic::schema::NamedType for PlanetResidentsEdge {
    const NAME: &'static str = "PlanetResidentsEdge";
}
impl ::cynic::schema::NamedType for PlanetsConnection {
    const NAME: &'static str = "PlanetsConnection";
}
impl ::cynic::schema::NamedType for PlanetsEdge {
    const NAME: &'static str = "PlanetsEdge";
}
impl ::cynic::schema::NamedType for Root {
    const NAME: &'static str = "Root";
}
impl ::cynic::schema::NamedType for Species {
    const NAME: &'static str = "Species";
}
impl ::cynic::schema::NamedType for SpeciesConnection {
    const NAME: &'static str = "SpeciesConnection";
}
impl ::cynic::schema::NamedType for SpeciesEdge {
    const NAME: &'static str = "SpeciesEdge";
}
impl ::cynic::schema::NamedType for SpeciesFilmsConnection {
    const NAME: &'static str = "SpeciesFilmsConnection";
}
impl ::cynic::schema::NamedType for SpeciesFilmsEdge {
    const NAME: &'static str = "SpeciesFilmsEdge";
}
impl ::cynic::schema::NamedType for SpeciesPeopleConnection {
    const NAME: &'static str = "SpeciesPeopleConnection";
}
impl ::cynic::schema::NamedType for SpeciesPeopleEdge {
    const NAME: &'static str = "SpeciesPeopleEdge";
}
impl ::cynic::schema::NamedType for Starship {
    const NAME: &'static str = "Starship";
}
impl ::cynic::schema::NamedType for StarshipFilmsConnection {
    const NAME: &'static str = "StarshipFilmsConnection";
}
impl ::cynic::schema::NamedType for StarshipFilmsEdge {
    const NAME: &'static str = "StarshipFilmsEdge";
}
impl ::cynic::schema::NamedType for StarshipPilotsConnection {
    const NAME: &'static str = "StarshipPilotsConnection";
}
impl ::cynic::schema::NamedType for StarshipPilotsEdge {
    const NAME: &'static str = "StarshipPilotsEdge";
}
impl ::cynic::schema::NamedType for StarshipsConnection {
    const NAME: &'static str = "StarshipsConnection";
}
impl ::cynic::schema::NamedType for StarshipsEdge {
    const NAME: &'static str = "StarshipsEdge";
}
impl ::cynic::schema::NamedType for Vehicle {
    const NAME: &'static str = "Vehicle";
}
impl ::cynic::schema::NamedType for VehicleFilmsConnection {
    const NAME: &'static str = "VehicleFilmsConnection";
}
impl ::cynic::schema::NamedType for VehicleFilmsEdge {
    const NAME: &'static str = "VehicleFilmsEdge";
}
impl ::cynic::schema::NamedType for VehiclePilotsConnection {
    const NAME: &'static str = "VehiclePilotsConnection";
}
impl ::cynic::schema::NamedType for VehiclePilotsEdge {
    const NAME: &'static str = "VehiclePilotsEdge";
}
impl ::cynic::schema::NamedType for VehiclesConnection {
    const NAME: &'static str = "VehiclesConnection";
}
impl ::cynic::schema::NamedType for VehiclesEdge {
    const NAME: &'static str = "VehiclesEdge";
}
pub type Boolean = bool;
pub type String = std::string::String;
pub type Float = f64;
pub type Int = i32;
pub type Id = ::cynic::Id;
pub mod variable {
    use cynic::variables::VariableType;
    #[doc = r" Used to determine the type of a given variable that"]
    #[doc = r" appears in an argument struct."]
    pub trait Variable {
        const TYPE: VariableType;
    }
    impl<T> Variable for &T
    where
        T: Variable,
    {
        const TYPE: VariableType = T::TYPE;
    }
    impl<T> Variable for Option<T>
    where
        T: Variable,
    {
        const TYPE: VariableType = VariableType::Nullable(&T::TYPE);
    }
    impl<T> Variable for Vec<T>
    where
        T: Variable,
    {
        const TYPE: VariableType = VariableType::List(&T::TYPE);
    }
    impl<T> Variable for Box<T>
    where
        T: Variable,
    {
        const TYPE: VariableType = T::TYPE;
    }
    impl<T> Variable for std::rc::Rc<T>
    where
        T: Variable,
    {
        const TYPE: VariableType = T::TYPE;
    }
    impl<T> Variable for std::sync::Arc<T>
    where
        T: Variable,
    {
        const TYPE: VariableType = T::TYPE;
    }
    impl Variable for bool {
        const TYPE: VariableType = VariableType::Named("Boolean");
    }
    impl Variable for String {
        const TYPE: VariableType = VariableType::Named("String");
    }
    impl Variable for f64 {
        const TYPE: VariableType = VariableType::Named("Float");
    }
    impl Variable for i32 {
        const TYPE: VariableType = VariableType::Named("Int");
    }
    impl Variable for ::cynic::Id {
        const TYPE: VariableType = VariableType::Named("ID");
    }
}

