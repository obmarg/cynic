---
source: cynic-codegen/tests/use-schema.rs
assertion_line: 25
expression: "format_code(format!(\"{}\", tokens))"

---
impl ::cynic::schema::QueryRoot for Root {}
pub struct Film;
pub mod film_fields {
    pub struct Title;
    impl ::cynic::schema::Field for Title {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "title"
        }
    }
    impl ::cynic::schema::HasField<Title, Option<super::String>> for super::Film {}
    pub struct EpisodeId;
    impl ::cynic::schema::Field for EpisodeId {
        type SchemaType = Option<super::Int>;
        fn name() -> &'static str {
            "episodeID"
        }
    }
    impl ::cynic::schema::HasField<EpisodeId, Option<super::Int>> for super::Film {}
    pub struct OpeningCrawl;
    impl ::cynic::schema::Field for OpeningCrawl {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "openingCrawl"
        }
    }
    impl ::cynic::schema::HasField<OpeningCrawl, Option<super::String>> for super::Film {}
    pub struct Director;
    impl ::cynic::schema::Field for Director {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "director"
        }
    }
    impl ::cynic::schema::HasField<Director, Option<super::String>> for super::Film {}
    pub struct Producers;
    impl ::cynic::schema::Field for Producers {
        type SchemaType = Option<Vec<Option<super::String>>>;
        fn name() -> &'static str {
            "producers"
        }
    }
    impl ::cynic::schema::HasField<Producers, Option<Vec<Option<super::String>>>> for super::Film {}
    pub struct ReleaseDate;
    impl ::cynic::schema::Field for ReleaseDate {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "releaseDate"
        }
    }
    impl ::cynic::schema::HasField<ReleaseDate, Option<super::String>> for super::Film {}
    pub struct SpeciesConnection;
    impl ::cynic::schema::Field for SpeciesConnection {
        type SchemaType = Option<super::FilmSpeciesConnection>;
        fn name() -> &'static str {
            "speciesConnection"
        }
    }
    impl ::cynic::schema::HasField<SpeciesConnection, Option<super::FilmSpeciesConnection>>
        for super::Film
    {
    }
    pub mod species_connection_arguments {
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::SpeciesConnection {
            type ArgumentSchemaType = Option<super::super::String>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "after"
            }
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::SpeciesConnection {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "first"
            }
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::SpeciesConnection {
            type ArgumentSchemaType = Option<super::super::String>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "before"
            }
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::SpeciesConnection {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "last"
            }
        }
    }
    pub struct StarshipConnection;
    impl ::cynic::schema::Field for StarshipConnection {
        type SchemaType = Option<super::FilmStarshipsConnection>;
        fn name() -> &'static str {
            "starshipConnection"
        }
    }
    impl ::cynic::schema::HasField<StarshipConnection, Option<super::FilmStarshipsConnection>>
        for super::Film
    {
    }
    pub mod starship_connection_arguments {
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::StarshipConnection {
            type ArgumentSchemaType = Option<super::super::String>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "after"
            }
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::StarshipConnection {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "first"
            }
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::StarshipConnection {
            type ArgumentSchemaType = Option<super::super::String>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "before"
            }
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::StarshipConnection {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "last"
            }
        }
    }
    pub struct VehicleConnection;
    impl ::cynic::schema::Field for VehicleConnection {
        type SchemaType = Option<super::FilmVehiclesConnection>;
        fn name() -> &'static str {
            "vehicleConnection"
        }
    }
    impl ::cynic::schema::HasField<VehicleConnection, Option<super::FilmVehiclesConnection>>
        for super::Film
    {
    }
    pub mod vehicle_connection_arguments {
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::VehicleConnection {
            type ArgumentSchemaType = Option<super::super::String>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "after"
            }
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::VehicleConnection {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "first"
            }
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::VehicleConnection {
            type ArgumentSchemaType = Option<super::super::String>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "before"
            }
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::VehicleConnection {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "last"
            }
        }
    }
    pub struct CharacterConnection;
    impl ::cynic::schema::Field for CharacterConnection {
        type SchemaType = Option<super::FilmCharactersConnection>;
        fn name() -> &'static str {
            "characterConnection"
        }
    }
    impl ::cynic::schema::HasField<CharacterConnection, Option<super::FilmCharactersConnection>>
        for super::Film
    {
    }
    pub mod character_connection_arguments {
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::CharacterConnection {
            type ArgumentSchemaType = Option<super::super::String>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "after"
            }
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::CharacterConnection {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "first"
            }
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::CharacterConnection {
            type ArgumentSchemaType = Option<super::super::String>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "before"
            }
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::CharacterConnection {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "last"
            }
        }
    }
    pub struct PlanetConnection;
    impl ::cynic::schema::Field for PlanetConnection {
        type SchemaType = Option<super::FilmPlanetsConnection>;
        fn name() -> &'static str {
            "planetConnection"
        }
    }
    impl ::cynic::schema::HasField<PlanetConnection, Option<super::FilmPlanetsConnection>>
        for super::Film
    {
    }
    pub mod planet_connection_arguments {
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::PlanetConnection {
            type ArgumentSchemaType = Option<super::super::String>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "after"
            }
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::PlanetConnection {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "first"
            }
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::PlanetConnection {
            type ArgumentSchemaType = Option<super::super::String>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "before"
            }
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::PlanetConnection {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "last"
            }
        }
    }
    pub struct Created;
    impl ::cynic::schema::Field for Created {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "created"
        }
    }
    impl ::cynic::schema::HasField<Created, Option<super::String>> for super::Film {}
    pub struct Edited;
    impl ::cynic::schema::Field for Edited {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "edited"
        }
    }
    impl ::cynic::schema::HasField<Edited, Option<super::String>> for super::Film {}
    pub struct Id;
    impl ::cynic::schema::Field for Id {
        type SchemaType = super::Id;
        fn name() -> &'static str {
            "id"
        }
    }
    impl ::cynic::schema::HasField<Id, super::Id> for super::Film {}
}
pub struct FilmCharactersConnection;
pub mod film_characters_connection_fields {
    pub struct PageInfo;
    impl ::cynic::schema::Field for PageInfo {
        type SchemaType = super::PageInfo;
        fn name() -> &'static str {
            "pageInfo"
        }
    }
    impl ::cynic::schema::HasField<PageInfo, super::PageInfo> for super::FilmCharactersConnection {}
    pub struct Edges;
    impl ::cynic::schema::Field for Edges {
        type SchemaType = Option<Vec<Option<super::FilmCharactersEdge>>>;
        fn name() -> &'static str {
            "edges"
        }
    }
    impl ::cynic::schema::HasField<Edges, Option<Vec<Option<super::FilmCharactersEdge>>>>
        for super::FilmCharactersConnection
    {
    }
    pub struct TotalCount;
    impl ::cynic::schema::Field for TotalCount {
        type SchemaType = Option<super::Int>;
        fn name() -> &'static str {
            "totalCount"
        }
    }
    impl ::cynic::schema::HasField<TotalCount, Option<super::Int>> for super::FilmCharactersConnection {}
    pub struct Characters;
    impl ::cynic::schema::Field for Characters {
        type SchemaType = Option<Vec<Option<super::Person>>>;
        fn name() -> &'static str {
            "characters"
        }
    }
    impl ::cynic::schema::HasField<Characters, Option<Vec<Option<super::Person>>>>
        for super::FilmCharactersConnection
    {
    }
}
pub struct FilmCharactersEdge;
pub mod film_characters_edge_fields {
    pub struct Node;
    impl ::cynic::schema::Field for Node {
        type SchemaType = Option<super::Person>;
        fn name() -> &'static str {
            "node"
        }
    }
    impl ::cynic::schema::HasField<Node, Option<super::Person>> for super::FilmCharactersEdge {}
    pub struct Cursor;
    impl ::cynic::schema::Field for Cursor {
        type SchemaType = super::String;
        fn name() -> &'static str {
            "cursor"
        }
    }
    impl ::cynic::schema::HasField<Cursor, super::String> for super::FilmCharactersEdge {}
}
pub struct FilmPlanetsConnection;
pub mod film_planets_connection_fields {
    pub struct PageInfo;
    impl ::cynic::schema::Field for PageInfo {
        type SchemaType = super::PageInfo;
        fn name() -> &'static str {
            "pageInfo"
        }
    }
    impl ::cynic::schema::HasField<PageInfo, super::PageInfo> for super::FilmPlanetsConnection {}
    pub struct Edges;
    impl ::cynic::schema::Field for Edges {
        type SchemaType = Option<Vec<Option<super::FilmPlanetsEdge>>>;
        fn name() -> &'static str {
            "edges"
        }
    }
    impl ::cynic::schema::HasField<Edges, Option<Vec<Option<super::FilmPlanetsEdge>>>>
        for super::FilmPlanetsConnection
    {
    }
    pub struct TotalCount;
    impl ::cynic::schema::Field for TotalCount {
        type SchemaType = Option<super::Int>;
        fn name() -> &'static str {
            "totalCount"
        }
    }
    impl ::cynic::schema::HasField<TotalCount, Option<super::Int>> for super::FilmPlanetsConnection {}
    pub struct Planets;
    impl ::cynic::schema::Field for Planets {
        type SchemaType = Option<Vec<Option<super::Planet>>>;
        fn name() -> &'static str {
            "planets"
        }
    }
    impl ::cynic::schema::HasField<Planets, Option<Vec<Option<super::Planet>>>>
        for super::FilmPlanetsConnection
    {
    }
}
pub struct FilmPlanetsEdge;
pub mod film_planets_edge_fields {
    pub struct Node;
    impl ::cynic::schema::Field for Node {
        type SchemaType = Option<super::Planet>;
        fn name() -> &'static str {
            "node"
        }
    }
    impl ::cynic::schema::HasField<Node, Option<super::Planet>> for super::FilmPlanetsEdge {}
    pub struct Cursor;
    impl ::cynic::schema::Field for Cursor {
        type SchemaType = super::String;
        fn name() -> &'static str {
            "cursor"
        }
    }
    impl ::cynic::schema::HasField<Cursor, super::String> for super::FilmPlanetsEdge {}
}
pub struct FilmSpeciesConnection;
pub mod film_species_connection_fields {
    pub struct PageInfo;
    impl ::cynic::schema::Field for PageInfo {
        type SchemaType = super::PageInfo;
        fn name() -> &'static str {
            "pageInfo"
        }
    }
    impl ::cynic::schema::HasField<PageInfo, super::PageInfo> for super::FilmSpeciesConnection {}
    pub struct Edges;
    impl ::cynic::schema::Field for Edges {
        type SchemaType = Option<Vec<Option<super::FilmSpeciesEdge>>>;
        fn name() -> &'static str {
            "edges"
        }
    }
    impl ::cynic::schema::HasField<Edges, Option<Vec<Option<super::FilmSpeciesEdge>>>>
        for super::FilmSpeciesConnection
    {
    }
    pub struct TotalCount;
    impl ::cynic::schema::Field for TotalCount {
        type SchemaType = Option<super::Int>;
        fn name() -> &'static str {
            "totalCount"
        }
    }
    impl ::cynic::schema::HasField<TotalCount, Option<super::Int>> for super::FilmSpeciesConnection {}
    pub struct Species;
    impl ::cynic::schema::Field for Species {
        type SchemaType = Option<Vec<Option<super::Species>>>;
        fn name() -> &'static str {
            "species"
        }
    }
    impl ::cynic::schema::HasField<Species, Option<Vec<Option<super::Species>>>>
        for super::FilmSpeciesConnection
    {
    }
}
pub struct FilmSpeciesEdge;
pub mod film_species_edge_fields {
    pub struct Node;
    impl ::cynic::schema::Field for Node {
        type SchemaType = Option<super::Species>;
        fn name() -> &'static str {
            "node"
        }
    }
    impl ::cynic::schema::HasField<Node, Option<super::Species>> for super::FilmSpeciesEdge {}
    pub struct Cursor;
    impl ::cynic::schema::Field for Cursor {
        type SchemaType = super::String;
        fn name() -> &'static str {
            "cursor"
        }
    }
    impl ::cynic::schema::HasField<Cursor, super::String> for super::FilmSpeciesEdge {}
}
pub struct FilmStarshipsConnection;
pub mod film_starships_connection_fields {
    pub struct PageInfo;
    impl ::cynic::schema::Field for PageInfo {
        type SchemaType = super::PageInfo;
        fn name() -> &'static str {
            "pageInfo"
        }
    }
    impl ::cynic::schema::HasField<PageInfo, super::PageInfo> for super::FilmStarshipsConnection {}
    pub struct Edges;
    impl ::cynic::schema::Field for Edges {
        type SchemaType = Option<Vec<Option<super::FilmStarshipsEdge>>>;
        fn name() -> &'static str {
            "edges"
        }
    }
    impl ::cynic::schema::HasField<Edges, Option<Vec<Option<super::FilmStarshipsEdge>>>>
        for super::FilmStarshipsConnection
    {
    }
    pub struct TotalCount;
    impl ::cynic::schema::Field for TotalCount {
        type SchemaType = Option<super::Int>;
        fn name() -> &'static str {
            "totalCount"
        }
    }
    impl ::cynic::schema::HasField<TotalCount, Option<super::Int>> for super::FilmStarshipsConnection {}
    pub struct Starships;
    impl ::cynic::schema::Field for Starships {
        type SchemaType = Option<Vec<Option<super::Starship>>>;
        fn name() -> &'static str {
            "starships"
        }
    }
    impl ::cynic::schema::HasField<Starships, Option<Vec<Option<super::Starship>>>>
        for super::FilmStarshipsConnection
    {
    }
}
pub struct FilmStarshipsEdge;
pub mod film_starships_edge_fields {
    pub struct Node;
    impl ::cynic::schema::Field for Node {
        type SchemaType = Option<super::Starship>;
        fn name() -> &'static str {
            "node"
        }
    }
    impl ::cynic::schema::HasField<Node, Option<super::Starship>> for super::FilmStarshipsEdge {}
    pub struct Cursor;
    impl ::cynic::schema::Field for Cursor {
        type SchemaType = super::String;
        fn name() -> &'static str {
            "cursor"
        }
    }
    impl ::cynic::schema::HasField<Cursor, super::String> for super::FilmStarshipsEdge {}
}
pub struct FilmVehiclesConnection;
pub mod film_vehicles_connection_fields {
    pub struct PageInfo;
    impl ::cynic::schema::Field for PageInfo {
        type SchemaType = super::PageInfo;
        fn name() -> &'static str {
            "pageInfo"
        }
    }
    impl ::cynic::schema::HasField<PageInfo, super::PageInfo> for super::FilmVehiclesConnection {}
    pub struct Edges;
    impl ::cynic::schema::Field for Edges {
        type SchemaType = Option<Vec<Option<super::FilmVehiclesEdge>>>;
        fn name() -> &'static str {
            "edges"
        }
    }
    impl ::cynic::schema::HasField<Edges, Option<Vec<Option<super::FilmVehiclesEdge>>>>
        for super::FilmVehiclesConnection
    {
    }
    pub struct TotalCount;
    impl ::cynic::schema::Field for TotalCount {
        type SchemaType = Option<super::Int>;
        fn name() -> &'static str {
            "totalCount"
        }
    }
    impl ::cynic::schema::HasField<TotalCount, Option<super::Int>> for super::FilmVehiclesConnection {}
    pub struct Vehicles;
    impl ::cynic::schema::Field for Vehicles {
        type SchemaType = Option<Vec<Option<super::Vehicle>>>;
        fn name() -> &'static str {
            "vehicles"
        }
    }
    impl ::cynic::schema::HasField<Vehicles, Option<Vec<Option<super::Vehicle>>>>
        for super::FilmVehiclesConnection
    {
    }
}
pub struct FilmVehiclesEdge;
pub mod film_vehicles_edge_fields {
    pub struct Node;
    impl ::cynic::schema::Field for Node {
        type SchemaType = Option<super::Vehicle>;
        fn name() -> &'static str {
            "node"
        }
    }
    impl ::cynic::schema::HasField<Node, Option<super::Vehicle>> for super::FilmVehiclesEdge {}
    pub struct Cursor;
    impl ::cynic::schema::Field for Cursor {
        type SchemaType = super::String;
        fn name() -> &'static str {
            "cursor"
        }
    }
    impl ::cynic::schema::HasField<Cursor, super::String> for super::FilmVehiclesEdge {}
}
pub struct FilmsConnection;
pub mod films_connection_fields {
    pub struct PageInfo;
    impl ::cynic::schema::Field for PageInfo {
        type SchemaType = super::PageInfo;
        fn name() -> &'static str {
            "pageInfo"
        }
    }
    impl ::cynic::schema::HasField<PageInfo, super::PageInfo> for super::FilmsConnection {}
    pub struct Edges;
    impl ::cynic::schema::Field for Edges {
        type SchemaType = Option<Vec<Option<super::FilmsEdge>>>;
        fn name() -> &'static str {
            "edges"
        }
    }
    impl ::cynic::schema::HasField<Edges, Option<Vec<Option<super::FilmsEdge>>>>
        for super::FilmsConnection
    {
    }
    pub struct TotalCount;
    impl ::cynic::schema::Field for TotalCount {
        type SchemaType = Option<super::Int>;
        fn name() -> &'static str {
            "totalCount"
        }
    }
    impl ::cynic::schema::HasField<TotalCount, Option<super::Int>> for super::FilmsConnection {}
    pub struct Films;
    impl ::cynic::schema::Field for Films {
        type SchemaType = Option<Vec<Option<super::Film>>>;
        fn name() -> &'static str {
            "films"
        }
    }
    impl ::cynic::schema::HasField<Films, Option<Vec<Option<super::Film>>>> for super::FilmsConnection {}
}
pub struct FilmsEdge;
pub mod films_edge_fields {
    pub struct Node;
    impl ::cynic::schema::Field for Node {
        type SchemaType = Option<super::Film>;
        fn name() -> &'static str {
            "node"
        }
    }
    impl ::cynic::schema::HasField<Node, Option<super::Film>> for super::FilmsEdge {}
    pub struct Cursor;
    impl ::cynic::schema::Field for Cursor {
        type SchemaType = super::String;
        fn name() -> &'static str {
            "cursor"
        }
    }
    impl ::cynic::schema::HasField<Cursor, super::String> for super::FilmsEdge {}
}
pub struct Node {}
pub struct PageInfo;
pub mod page_info_fields {
    pub struct HasNextPage;
    impl ::cynic::schema::Field for HasNextPage {
        type SchemaType = super::Boolean;
        fn name() -> &'static str {
            "hasNextPage"
        }
    }
    impl ::cynic::schema::HasField<HasNextPage, super::Boolean> for super::PageInfo {}
    pub struct HasPreviousPage;
    impl ::cynic::schema::Field for HasPreviousPage {
        type SchemaType = super::Boolean;
        fn name() -> &'static str {
            "hasPreviousPage"
        }
    }
    impl ::cynic::schema::HasField<HasPreviousPage, super::Boolean> for super::PageInfo {}
    pub struct StartCursor;
    impl ::cynic::schema::Field for StartCursor {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "startCursor"
        }
    }
    impl ::cynic::schema::HasField<StartCursor, Option<super::String>> for super::PageInfo {}
    pub struct EndCursor;
    impl ::cynic::schema::Field for EndCursor {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "endCursor"
        }
    }
    impl ::cynic::schema::HasField<EndCursor, Option<super::String>> for super::PageInfo {}
}
pub struct PeopleConnection;
pub mod people_connection_fields {
    pub struct PageInfo;
    impl ::cynic::schema::Field for PageInfo {
        type SchemaType = super::PageInfo;
        fn name() -> &'static str {
            "pageInfo"
        }
    }
    impl ::cynic::schema::HasField<PageInfo, super::PageInfo> for super::PeopleConnection {}
    pub struct Edges;
    impl ::cynic::schema::Field for Edges {
        type SchemaType = Option<Vec<Option<super::PeopleEdge>>>;
        fn name() -> &'static str {
            "edges"
        }
    }
    impl ::cynic::schema::HasField<Edges, Option<Vec<Option<super::PeopleEdge>>>>
        for super::PeopleConnection
    {
    }
    pub struct TotalCount;
    impl ::cynic::schema::Field for TotalCount {
        type SchemaType = Option<super::Int>;
        fn name() -> &'static str {
            "totalCount"
        }
    }
    impl ::cynic::schema::HasField<TotalCount, Option<super::Int>> for super::PeopleConnection {}
    pub struct People;
    impl ::cynic::schema::Field for People {
        type SchemaType = Option<Vec<Option<super::Person>>>;
        fn name() -> &'static str {
            "people"
        }
    }
    impl ::cynic::schema::HasField<People, Option<Vec<Option<super::Person>>>>
        for super::PeopleConnection
    {
    }
}
pub struct PeopleEdge;
pub mod people_edge_fields {
    pub struct Node;
    impl ::cynic::schema::Field for Node {
        type SchemaType = Option<super::Person>;
        fn name() -> &'static str {
            "node"
        }
    }
    impl ::cynic::schema::HasField<Node, Option<super::Person>> for super::PeopleEdge {}
    pub struct Cursor;
    impl ::cynic::schema::Field for Cursor {
        type SchemaType = super::String;
        fn name() -> &'static str {
            "cursor"
        }
    }
    impl ::cynic::schema::HasField<Cursor, super::String> for super::PeopleEdge {}
}
pub struct Person;
pub mod person_fields {
    pub struct Name;
    impl ::cynic::schema::Field for Name {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "name"
        }
    }
    impl ::cynic::schema::HasField<Name, Option<super::String>> for super::Person {}
    pub struct BirthYear;
    impl ::cynic::schema::Field for BirthYear {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "birthYear"
        }
    }
    impl ::cynic::schema::HasField<BirthYear, Option<super::String>> for super::Person {}
    pub struct EyeColor;
    impl ::cynic::schema::Field for EyeColor {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "eyeColor"
        }
    }
    impl ::cynic::schema::HasField<EyeColor, Option<super::String>> for super::Person {}
    pub struct Gender;
    impl ::cynic::schema::Field for Gender {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "gender"
        }
    }
    impl ::cynic::schema::HasField<Gender, Option<super::String>> for super::Person {}
    pub struct HairColor;
    impl ::cynic::schema::Field for HairColor {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "hairColor"
        }
    }
    impl ::cynic::schema::HasField<HairColor, Option<super::String>> for super::Person {}
    pub struct Height;
    impl ::cynic::schema::Field for Height {
        type SchemaType = Option<super::Int>;
        fn name() -> &'static str {
            "height"
        }
    }
    impl ::cynic::schema::HasField<Height, Option<super::Int>> for super::Person {}
    pub struct Mass;
    impl ::cynic::schema::Field for Mass {
        type SchemaType = Option<super::Float>;
        fn name() -> &'static str {
            "mass"
        }
    }
    impl ::cynic::schema::HasField<Mass, Option<super::Float>> for super::Person {}
    pub struct SkinColor;
    impl ::cynic::schema::Field for SkinColor {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "skinColor"
        }
    }
    impl ::cynic::schema::HasField<SkinColor, Option<super::String>> for super::Person {}
    pub struct Homeworld;
    impl ::cynic::schema::Field for Homeworld {
        type SchemaType = Option<super::Planet>;
        fn name() -> &'static str {
            "homeworld"
        }
    }
    impl ::cynic::schema::HasField<Homeworld, Option<super::Planet>> for super::Person {}
    pub struct FilmConnection;
    impl ::cynic::schema::Field for FilmConnection {
        type SchemaType = Option<super::PersonFilmsConnection>;
        fn name() -> &'static str {
            "filmConnection"
        }
    }
    impl ::cynic::schema::HasField<FilmConnection, Option<super::PersonFilmsConnection>>
        for super::Person
    {
    }
    pub mod film_connection_arguments {
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::FilmConnection {
            type ArgumentSchemaType = Option<super::super::String>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "after"
            }
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::FilmConnection {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "first"
            }
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::FilmConnection {
            type ArgumentSchemaType = Option<super::super::String>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "before"
            }
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::FilmConnection {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "last"
            }
        }
    }
    pub struct Species;
    impl ::cynic::schema::Field for Species {
        type SchemaType = Option<super::Species>;
        fn name() -> &'static str {
            "species"
        }
    }
    impl ::cynic::schema::HasField<Species, Option<super::Species>> for super::Person {}
    pub struct StarshipConnection;
    impl ::cynic::schema::Field for StarshipConnection {
        type SchemaType = Option<super::PersonStarshipsConnection>;
        fn name() -> &'static str {
            "starshipConnection"
        }
    }
    impl ::cynic::schema::HasField<StarshipConnection, Option<super::PersonStarshipsConnection>>
        for super::Person
    {
    }
    pub mod starship_connection_arguments {
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::StarshipConnection {
            type ArgumentSchemaType = Option<super::super::String>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "after"
            }
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::StarshipConnection {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "first"
            }
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::StarshipConnection {
            type ArgumentSchemaType = Option<super::super::String>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "before"
            }
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::StarshipConnection {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "last"
            }
        }
    }
    pub struct VehicleConnection;
    impl ::cynic::schema::Field for VehicleConnection {
        type SchemaType = Option<super::PersonVehiclesConnection>;
        fn name() -> &'static str {
            "vehicleConnection"
        }
    }
    impl ::cynic::schema::HasField<VehicleConnection, Option<super::PersonVehiclesConnection>>
        for super::Person
    {
    }
    pub mod vehicle_connection_arguments {
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::VehicleConnection {
            type ArgumentSchemaType = Option<super::super::String>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "after"
            }
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::VehicleConnection {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "first"
            }
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::VehicleConnection {
            type ArgumentSchemaType = Option<super::super::String>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "before"
            }
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::VehicleConnection {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "last"
            }
        }
    }
    pub struct Created;
    impl ::cynic::schema::Field for Created {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "created"
        }
    }
    impl ::cynic::schema::HasField<Created, Option<super::String>> for super::Person {}
    pub struct Edited;
    impl ::cynic::schema::Field for Edited {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "edited"
        }
    }
    impl ::cynic::schema::HasField<Edited, Option<super::String>> for super::Person {}
    pub struct Id;
    impl ::cynic::schema::Field for Id {
        type SchemaType = super::Id;
        fn name() -> &'static str {
            "id"
        }
    }
    impl ::cynic::schema::HasField<Id, super::Id> for super::Person {}
}
pub struct PersonFilmsConnection;
pub mod person_films_connection_fields {
    pub struct PageInfo;
    impl ::cynic::schema::Field for PageInfo {
        type SchemaType = super::PageInfo;
        fn name() -> &'static str {
            "pageInfo"
        }
    }
    impl ::cynic::schema::HasField<PageInfo, super::PageInfo> for super::PersonFilmsConnection {}
    pub struct Edges;
    impl ::cynic::schema::Field for Edges {
        type SchemaType = Option<Vec<Option<super::PersonFilmsEdge>>>;
        fn name() -> &'static str {
            "edges"
        }
    }
    impl ::cynic::schema::HasField<Edges, Option<Vec<Option<super::PersonFilmsEdge>>>>
        for super::PersonFilmsConnection
    {
    }
    pub struct TotalCount;
    impl ::cynic::schema::Field for TotalCount {
        type SchemaType = Option<super::Int>;
        fn name() -> &'static str {
            "totalCount"
        }
    }
    impl ::cynic::schema::HasField<TotalCount, Option<super::Int>> for super::PersonFilmsConnection {}
    pub struct Films;
    impl ::cynic::schema::Field for Films {
        type SchemaType = Option<Vec<Option<super::Film>>>;
        fn name() -> &'static str {
            "films"
        }
    }
    impl ::cynic::schema::HasField<Films, Option<Vec<Option<super::Film>>>>
        for super::PersonFilmsConnection
    {
    }
}
pub struct PersonFilmsEdge;
pub mod person_films_edge_fields {
    pub struct Node;
    impl ::cynic::schema::Field for Node {
        type SchemaType = Option<super::Film>;
        fn name() -> &'static str {
            "node"
        }
    }
    impl ::cynic::schema::HasField<Node, Option<super::Film>> for super::PersonFilmsEdge {}
    pub struct Cursor;
    impl ::cynic::schema::Field for Cursor {
        type SchemaType = super::String;
        fn name() -> &'static str {
            "cursor"
        }
    }
    impl ::cynic::schema::HasField<Cursor, super::String> for super::PersonFilmsEdge {}
}
pub struct PersonStarshipsConnection;
pub mod person_starships_connection_fields {
    pub struct PageInfo;
    impl ::cynic::schema::Field for PageInfo {
        type SchemaType = super::PageInfo;
        fn name() -> &'static str {
            "pageInfo"
        }
    }
    impl ::cynic::schema::HasField<PageInfo, super::PageInfo> for super::PersonStarshipsConnection {}
    pub struct Edges;
    impl ::cynic::schema::Field for Edges {
        type SchemaType = Option<Vec<Option<super::PersonStarshipsEdge>>>;
        fn name() -> &'static str {
            "edges"
        }
    }
    impl ::cynic::schema::HasField<Edges, Option<Vec<Option<super::PersonStarshipsEdge>>>>
        for super::PersonStarshipsConnection
    {
    }
    pub struct TotalCount;
    impl ::cynic::schema::Field for TotalCount {
        type SchemaType = Option<super::Int>;
        fn name() -> &'static str {
            "totalCount"
        }
    }
    impl ::cynic::schema::HasField<TotalCount, Option<super::Int>>
        for super::PersonStarshipsConnection
    {
    }
    pub struct Starships;
    impl ::cynic::schema::Field for Starships {
        type SchemaType = Option<Vec<Option<super::Starship>>>;
        fn name() -> &'static str {
            "starships"
        }
    }
    impl ::cynic::schema::HasField<Starships, Option<Vec<Option<super::Starship>>>>
        for super::PersonStarshipsConnection
    {
    }
}
pub struct PersonStarshipsEdge;
pub mod person_starships_edge_fields {
    pub struct Node;
    impl ::cynic::schema::Field for Node {
        type SchemaType = Option<super::Starship>;
        fn name() -> &'static str {
            "node"
        }
    }
    impl ::cynic::schema::HasField<Node, Option<super::Starship>> for super::PersonStarshipsEdge {}
    pub struct Cursor;
    impl ::cynic::schema::Field for Cursor {
        type SchemaType = super::String;
        fn name() -> &'static str {
            "cursor"
        }
    }
    impl ::cynic::schema::HasField<Cursor, super::String> for super::PersonStarshipsEdge {}
}
pub struct PersonVehiclesConnection;
pub mod person_vehicles_connection_fields {
    pub struct PageInfo;
    impl ::cynic::schema::Field for PageInfo {
        type SchemaType = super::PageInfo;
        fn name() -> &'static str {
            "pageInfo"
        }
    }
    impl ::cynic::schema::HasField<PageInfo, super::PageInfo> for super::PersonVehiclesConnection {}
    pub struct Edges;
    impl ::cynic::schema::Field for Edges {
        type SchemaType = Option<Vec<Option<super::PersonVehiclesEdge>>>;
        fn name() -> &'static str {
            "edges"
        }
    }
    impl ::cynic::schema::HasField<Edges, Option<Vec<Option<super::PersonVehiclesEdge>>>>
        for super::PersonVehiclesConnection
    {
    }
    pub struct TotalCount;
    impl ::cynic::schema::Field for TotalCount {
        type SchemaType = Option<super::Int>;
        fn name() -> &'static str {
            "totalCount"
        }
    }
    impl ::cynic::schema::HasField<TotalCount, Option<super::Int>> for super::PersonVehiclesConnection {}
    pub struct Vehicles;
    impl ::cynic::schema::Field for Vehicles {
        type SchemaType = Option<Vec<Option<super::Vehicle>>>;
        fn name() -> &'static str {
            "vehicles"
        }
    }
    impl ::cynic::schema::HasField<Vehicles, Option<Vec<Option<super::Vehicle>>>>
        for super::PersonVehiclesConnection
    {
    }
}
pub struct PersonVehiclesEdge;
pub mod person_vehicles_edge_fields {
    pub struct Node;
    impl ::cynic::schema::Field for Node {
        type SchemaType = Option<super::Vehicle>;
        fn name() -> &'static str {
            "node"
        }
    }
    impl ::cynic::schema::HasField<Node, Option<super::Vehicle>> for super::PersonVehiclesEdge {}
    pub struct Cursor;
    impl ::cynic::schema::Field for Cursor {
        type SchemaType = super::String;
        fn name() -> &'static str {
            "cursor"
        }
    }
    impl ::cynic::schema::HasField<Cursor, super::String> for super::PersonVehiclesEdge {}
}
pub struct Planet;
pub mod planet_fields {
    pub struct Name;
    impl ::cynic::schema::Field for Name {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "name"
        }
    }
    impl ::cynic::schema::HasField<Name, Option<super::String>> for super::Planet {}
    pub struct Diameter;
    impl ::cynic::schema::Field for Diameter {
        type SchemaType = Option<super::Int>;
        fn name() -> &'static str {
            "diameter"
        }
    }
    impl ::cynic::schema::HasField<Diameter, Option<super::Int>> for super::Planet {}
    pub struct RotationPeriod;
    impl ::cynic::schema::Field for RotationPeriod {
        type SchemaType = Option<super::Int>;
        fn name() -> &'static str {
            "rotationPeriod"
        }
    }
    impl ::cynic::schema::HasField<RotationPeriod, Option<super::Int>> for super::Planet {}
    pub struct OrbitalPeriod;
    impl ::cynic::schema::Field for OrbitalPeriod {
        type SchemaType = Option<super::Int>;
        fn name() -> &'static str {
            "orbitalPeriod"
        }
    }
    impl ::cynic::schema::HasField<OrbitalPeriod, Option<super::Int>> for super::Planet {}
    pub struct Gravity;
    impl ::cynic::schema::Field for Gravity {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "gravity"
        }
    }
    impl ::cynic::schema::HasField<Gravity, Option<super::String>> for super::Planet {}
    pub struct Population;
    impl ::cynic::schema::Field for Population {
        type SchemaType = Option<super::Float>;
        fn name() -> &'static str {
            "population"
        }
    }
    impl ::cynic::schema::HasField<Population, Option<super::Float>> for super::Planet {}
    pub struct Climates;
    impl ::cynic::schema::Field for Climates {
        type SchemaType = Option<Vec<Option<super::String>>>;
        fn name() -> &'static str {
            "climates"
        }
    }
    impl ::cynic::schema::HasField<Climates, Option<Vec<Option<super::String>>>> for super::Planet {}
    pub struct Terrains;
    impl ::cynic::schema::Field for Terrains {
        type SchemaType = Option<Vec<Option<super::String>>>;
        fn name() -> &'static str {
            "terrains"
        }
    }
    impl ::cynic::schema::HasField<Terrains, Option<Vec<Option<super::String>>>> for super::Planet {}
    pub struct SurfaceWater;
    impl ::cynic::schema::Field for SurfaceWater {
        type SchemaType = Option<super::Float>;
        fn name() -> &'static str {
            "surfaceWater"
        }
    }
    impl ::cynic::schema::HasField<SurfaceWater, Option<super::Float>> for super::Planet {}
    pub struct ResidentConnection;
    impl ::cynic::schema::Field for ResidentConnection {
        type SchemaType = Option<super::PlanetResidentsConnection>;
        fn name() -> &'static str {
            "residentConnection"
        }
    }
    impl ::cynic::schema::HasField<ResidentConnection, Option<super::PlanetResidentsConnection>>
        for super::Planet
    {
    }
    pub mod resident_connection_arguments {
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::ResidentConnection {
            type ArgumentSchemaType = Option<super::super::String>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "after"
            }
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::ResidentConnection {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "first"
            }
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::ResidentConnection {
            type ArgumentSchemaType = Option<super::super::String>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "before"
            }
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::ResidentConnection {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "last"
            }
        }
    }
    pub struct FilmConnection;
    impl ::cynic::schema::Field for FilmConnection {
        type SchemaType = Option<super::PlanetFilmsConnection>;
        fn name() -> &'static str {
            "filmConnection"
        }
    }
    impl ::cynic::schema::HasField<FilmConnection, Option<super::PlanetFilmsConnection>>
        for super::Planet
    {
    }
    pub mod film_connection_arguments {
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::FilmConnection {
            type ArgumentSchemaType = Option<super::super::String>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "after"
            }
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::FilmConnection {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "first"
            }
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::FilmConnection {
            type ArgumentSchemaType = Option<super::super::String>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "before"
            }
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::FilmConnection {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "last"
            }
        }
    }
    pub struct Created;
    impl ::cynic::schema::Field for Created {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "created"
        }
    }
    impl ::cynic::schema::HasField<Created, Option<super::String>> for super::Planet {}
    pub struct Edited;
    impl ::cynic::schema::Field for Edited {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "edited"
        }
    }
    impl ::cynic::schema::HasField<Edited, Option<super::String>> for super::Planet {}
    pub struct Id;
    impl ::cynic::schema::Field for Id {
        type SchemaType = super::Id;
        fn name() -> &'static str {
            "id"
        }
    }
    impl ::cynic::schema::HasField<Id, super::Id> for super::Planet {}
}
pub struct PlanetFilmsConnection;
pub mod planet_films_connection_fields {
    pub struct PageInfo;
    impl ::cynic::schema::Field for PageInfo {
        type SchemaType = super::PageInfo;
        fn name() -> &'static str {
            "pageInfo"
        }
    }
    impl ::cynic::schema::HasField<PageInfo, super::PageInfo> for super::PlanetFilmsConnection {}
    pub struct Edges;
    impl ::cynic::schema::Field for Edges {
        type SchemaType = Option<Vec<Option<super::PlanetFilmsEdge>>>;
        fn name() -> &'static str {
            "edges"
        }
    }
    impl ::cynic::schema::HasField<Edges, Option<Vec<Option<super::PlanetFilmsEdge>>>>
        for super::PlanetFilmsConnection
    {
    }
    pub struct TotalCount;
    impl ::cynic::schema::Field for TotalCount {
        type SchemaType = Option<super::Int>;
        fn name() -> &'static str {
            "totalCount"
        }
    }
    impl ::cynic::schema::HasField<TotalCount, Option<super::Int>> for super::PlanetFilmsConnection {}
    pub struct Films;
    impl ::cynic::schema::Field for Films {
        type SchemaType = Option<Vec<Option<super::Film>>>;
        fn name() -> &'static str {
            "films"
        }
    }
    impl ::cynic::schema::HasField<Films, Option<Vec<Option<super::Film>>>>
        for super::PlanetFilmsConnection
    {
    }
}
pub struct PlanetFilmsEdge;
pub mod planet_films_edge_fields {
    pub struct Node;
    impl ::cynic::schema::Field for Node {
        type SchemaType = Option<super::Film>;
        fn name() -> &'static str {
            "node"
        }
    }
    impl ::cynic::schema::HasField<Node, Option<super::Film>> for super::PlanetFilmsEdge {}
    pub struct Cursor;
    impl ::cynic::schema::Field for Cursor {
        type SchemaType = super::String;
        fn name() -> &'static str {
            "cursor"
        }
    }
    impl ::cynic::schema::HasField<Cursor, super::String> for super::PlanetFilmsEdge {}
}
pub struct PlanetResidentsConnection;
pub mod planet_residents_connection_fields {
    pub struct PageInfo;
    impl ::cynic::schema::Field for PageInfo {
        type SchemaType = super::PageInfo;
        fn name() -> &'static str {
            "pageInfo"
        }
    }
    impl ::cynic::schema::HasField<PageInfo, super::PageInfo> for super::PlanetResidentsConnection {}
    pub struct Edges;
    impl ::cynic::schema::Field for Edges {
        type SchemaType = Option<Vec<Option<super::PlanetResidentsEdge>>>;
        fn name() -> &'static str {
            "edges"
        }
    }
    impl ::cynic::schema::HasField<Edges, Option<Vec<Option<super::PlanetResidentsEdge>>>>
        for super::PlanetResidentsConnection
    {
    }
    pub struct TotalCount;
    impl ::cynic::schema::Field for TotalCount {
        type SchemaType = Option<super::Int>;
        fn name() -> &'static str {
            "totalCount"
        }
    }
    impl ::cynic::schema::HasField<TotalCount, Option<super::Int>>
        for super::PlanetResidentsConnection
    {
    }
    pub struct Residents;
    impl ::cynic::schema::Field for Residents {
        type SchemaType = Option<Vec<Option<super::Person>>>;
        fn name() -> &'static str {
            "residents"
        }
    }
    impl ::cynic::schema::HasField<Residents, Option<Vec<Option<super::Person>>>>
        for super::PlanetResidentsConnection
    {
    }
}
pub struct PlanetResidentsEdge;
pub mod planet_residents_edge_fields {
    pub struct Node;
    impl ::cynic::schema::Field for Node {
        type SchemaType = Option<super::Person>;
        fn name() -> &'static str {
            "node"
        }
    }
    impl ::cynic::schema::HasField<Node, Option<super::Person>> for super::PlanetResidentsEdge {}
    pub struct Cursor;
    impl ::cynic::schema::Field for Cursor {
        type SchemaType = super::String;
        fn name() -> &'static str {
            "cursor"
        }
    }
    impl ::cynic::schema::HasField<Cursor, super::String> for super::PlanetResidentsEdge {}
}
pub struct PlanetsConnection;
pub mod planets_connection_fields {
    pub struct PageInfo;
    impl ::cynic::schema::Field for PageInfo {
        type SchemaType = super::PageInfo;
        fn name() -> &'static str {
            "pageInfo"
        }
    }
    impl ::cynic::schema::HasField<PageInfo, super::PageInfo> for super::PlanetsConnection {}
    pub struct Edges;
    impl ::cynic::schema::Field for Edges {
        type SchemaType = Option<Vec<Option<super::PlanetsEdge>>>;
        fn name() -> &'static str {
            "edges"
        }
    }
    impl ::cynic::schema::HasField<Edges, Option<Vec<Option<super::PlanetsEdge>>>>
        for super::PlanetsConnection
    {
    }
    pub struct TotalCount;
    impl ::cynic::schema::Field for TotalCount {
        type SchemaType = Option<super::Int>;
        fn name() -> &'static str {
            "totalCount"
        }
    }
    impl ::cynic::schema::HasField<TotalCount, Option<super::Int>> for super::PlanetsConnection {}
    pub struct Planets;
    impl ::cynic::schema::Field for Planets {
        type SchemaType = Option<Vec<Option<super::Planet>>>;
        fn name() -> &'static str {
            "planets"
        }
    }
    impl ::cynic::schema::HasField<Planets, Option<Vec<Option<super::Planet>>>>
        for super::PlanetsConnection
    {
    }
}
pub struct PlanetsEdge;
pub mod planets_edge_fields {
    pub struct Node;
    impl ::cynic::schema::Field for Node {
        type SchemaType = Option<super::Planet>;
        fn name() -> &'static str {
            "node"
        }
    }
    impl ::cynic::schema::HasField<Node, Option<super::Planet>> for super::PlanetsEdge {}
    pub struct Cursor;
    impl ::cynic::schema::Field for Cursor {
        type SchemaType = super::String;
        fn name() -> &'static str {
            "cursor"
        }
    }
    impl ::cynic::schema::HasField<Cursor, super::String> for super::PlanetsEdge {}
}
pub struct Root;
pub mod root_fields {
    pub struct AllFilms;
    impl ::cynic::schema::Field for AllFilms {
        type SchemaType = Option<super::FilmsConnection>;
        fn name() -> &'static str {
            "allFilms"
        }
    }
    impl ::cynic::schema::HasField<AllFilms, Option<super::FilmsConnection>> for super::Root {}
    pub mod all_films_arguments {
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::AllFilms {
            type ArgumentSchemaType = Option<super::super::String>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "after"
            }
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::AllFilms {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "first"
            }
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::AllFilms {
            type ArgumentSchemaType = Option<super::super::String>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "before"
            }
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::AllFilms {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "last"
            }
        }
    }
    pub struct Film;
    impl ::cynic::schema::Field for Film {
        type SchemaType = Option<super::Film>;
        fn name() -> &'static str {
            "film"
        }
    }
    impl ::cynic::schema::HasField<Film, Option<super::Film>> for super::Root {}
    pub mod film_arguments {
        pub struct Id;
        impl ::cynic::schema::HasArgument<Id> for super::Film {
            type ArgumentSchemaType = Option<super::super::Id>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "id"
            }
        }
        pub struct FilmId;
        impl ::cynic::schema::HasArgument<FilmId> for super::Film {
            type ArgumentSchemaType = Option<super::super::Id>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "filmID"
            }
        }
    }
    pub struct AllPeople;
    impl ::cynic::schema::Field for AllPeople {
        type SchemaType = Option<super::PeopleConnection>;
        fn name() -> &'static str {
            "allPeople"
        }
    }
    impl ::cynic::schema::HasField<AllPeople, Option<super::PeopleConnection>> for super::Root {}
    pub mod all_people_arguments {
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::AllPeople {
            type ArgumentSchemaType = Option<super::super::String>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "after"
            }
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::AllPeople {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "first"
            }
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::AllPeople {
            type ArgumentSchemaType = Option<super::super::String>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "before"
            }
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::AllPeople {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "last"
            }
        }
    }
    pub struct Person;
    impl ::cynic::schema::Field for Person {
        type SchemaType = Option<super::Person>;
        fn name() -> &'static str {
            "person"
        }
    }
    impl ::cynic::schema::HasField<Person, Option<super::Person>> for super::Root {}
    pub mod person_arguments {
        pub struct Id;
        impl ::cynic::schema::HasArgument<Id> for super::Person {
            type ArgumentSchemaType = Option<super::super::Id>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "id"
            }
        }
        pub struct PersonId;
        impl ::cynic::schema::HasArgument<PersonId> for super::Person {
            type ArgumentSchemaType = Option<super::super::Id>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "personID"
            }
        }
    }
    pub struct AllPlanets;
    impl ::cynic::schema::Field for AllPlanets {
        type SchemaType = Option<super::PlanetsConnection>;
        fn name() -> &'static str {
            "allPlanets"
        }
    }
    impl ::cynic::schema::HasField<AllPlanets, Option<super::PlanetsConnection>> for super::Root {}
    pub mod all_planets_arguments {
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::AllPlanets {
            type ArgumentSchemaType = Option<super::super::String>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "after"
            }
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::AllPlanets {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "first"
            }
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::AllPlanets {
            type ArgumentSchemaType = Option<super::super::String>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "before"
            }
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::AllPlanets {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "last"
            }
        }
    }
    pub struct Planet;
    impl ::cynic::schema::Field for Planet {
        type SchemaType = Option<super::Planet>;
        fn name() -> &'static str {
            "planet"
        }
    }
    impl ::cynic::schema::HasField<Planet, Option<super::Planet>> for super::Root {}
    pub mod planet_arguments {
        pub struct Id;
        impl ::cynic::schema::HasArgument<Id> for super::Planet {
            type ArgumentSchemaType = Option<super::super::Id>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "id"
            }
        }
        pub struct PlanetId;
        impl ::cynic::schema::HasArgument<PlanetId> for super::Planet {
            type ArgumentSchemaType = Option<super::super::Id>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "planetID"
            }
        }
    }
    pub struct AllSpecies;
    impl ::cynic::schema::Field for AllSpecies {
        type SchemaType = Option<super::SpeciesConnection>;
        fn name() -> &'static str {
            "allSpecies"
        }
    }
    impl ::cynic::schema::HasField<AllSpecies, Option<super::SpeciesConnection>> for super::Root {}
    pub mod all_species_arguments {
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::AllSpecies {
            type ArgumentSchemaType = Option<super::super::String>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "after"
            }
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::AllSpecies {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "first"
            }
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::AllSpecies {
            type ArgumentSchemaType = Option<super::super::String>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "before"
            }
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::AllSpecies {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "last"
            }
        }
    }
    pub struct Species;
    impl ::cynic::schema::Field for Species {
        type SchemaType = Option<super::Species>;
        fn name() -> &'static str {
            "species"
        }
    }
    impl ::cynic::schema::HasField<Species, Option<super::Species>> for super::Root {}
    pub mod species_arguments {
        pub struct Id;
        impl ::cynic::schema::HasArgument<Id> for super::Species {
            type ArgumentSchemaType = Option<super::super::Id>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "id"
            }
        }
        pub struct SpeciesId;
        impl ::cynic::schema::HasArgument<SpeciesId> for super::Species {
            type ArgumentSchemaType = Option<super::super::Id>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "speciesID"
            }
        }
    }
    pub struct AllStarships;
    impl ::cynic::schema::Field for AllStarships {
        type SchemaType = Option<super::StarshipsConnection>;
        fn name() -> &'static str {
            "allStarships"
        }
    }
    impl ::cynic::schema::HasField<AllStarships, Option<super::StarshipsConnection>> for super::Root {}
    pub mod all_starships_arguments {
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::AllStarships {
            type ArgumentSchemaType = Option<super::super::String>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "after"
            }
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::AllStarships {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "first"
            }
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::AllStarships {
            type ArgumentSchemaType = Option<super::super::String>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "before"
            }
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::AllStarships {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "last"
            }
        }
    }
    pub struct Starship;
    impl ::cynic::schema::Field for Starship {
        type SchemaType = Option<super::Starship>;
        fn name() -> &'static str {
            "starship"
        }
    }
    impl ::cynic::schema::HasField<Starship, Option<super::Starship>> for super::Root {}
    pub mod starship_arguments {
        pub struct Id;
        impl ::cynic::schema::HasArgument<Id> for super::Starship {
            type ArgumentSchemaType = Option<super::super::Id>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "id"
            }
        }
        pub struct StarshipId;
        impl ::cynic::schema::HasArgument<StarshipId> for super::Starship {
            type ArgumentSchemaType = Option<super::super::Id>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "starshipID"
            }
        }
    }
    pub struct AllVehicles;
    impl ::cynic::schema::Field for AllVehicles {
        type SchemaType = Option<super::VehiclesConnection>;
        fn name() -> &'static str {
            "allVehicles"
        }
    }
    impl ::cynic::schema::HasField<AllVehicles, Option<super::VehiclesConnection>> for super::Root {}
    pub mod all_vehicles_arguments {
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::AllVehicles {
            type ArgumentSchemaType = Option<super::super::String>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "after"
            }
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::AllVehicles {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "first"
            }
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::AllVehicles {
            type ArgumentSchemaType = Option<super::super::String>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "before"
            }
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::AllVehicles {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "last"
            }
        }
    }
    pub struct Vehicle;
    impl ::cynic::schema::Field for Vehicle {
        type SchemaType = Option<super::Vehicle>;
        fn name() -> &'static str {
            "vehicle"
        }
    }
    impl ::cynic::schema::HasField<Vehicle, Option<super::Vehicle>> for super::Root {}
    pub mod vehicle_arguments {
        pub struct Id;
        impl ::cynic::schema::HasArgument<Id> for super::Vehicle {
            type ArgumentSchemaType = Option<super::super::Id>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "id"
            }
        }
        pub struct VehicleId;
        impl ::cynic::schema::HasArgument<VehicleId> for super::Vehicle {
            type ArgumentSchemaType = Option<super::super::Id>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "vehicleID"
            }
        }
    }
    pub struct Node;
    impl ::cynic::schema::Field for Node {
        type SchemaType = Option<super::Node>;
        fn name() -> &'static str {
            "node"
        }
    }
    impl ::cynic::schema::HasField<Node, Option<super::Node>> for super::Root {}
    pub mod node_arguments {
        pub struct Id;
        impl ::cynic::schema::HasArgument<Id> for super::Node {
            type ArgumentSchemaType = super::super::Id;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "id"
            }
        }
    }
}
pub struct Species;
pub mod species_fields {
    pub struct Name;
    impl ::cynic::schema::Field for Name {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "name"
        }
    }
    impl ::cynic::schema::HasField<Name, Option<super::String>> for super::Species {}
    pub struct Classification;
    impl ::cynic::schema::Field for Classification {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "classification"
        }
    }
    impl ::cynic::schema::HasField<Classification, Option<super::String>> for super::Species {}
    pub struct Designation;
    impl ::cynic::schema::Field for Designation {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "designation"
        }
    }
    impl ::cynic::schema::HasField<Designation, Option<super::String>> for super::Species {}
    pub struct AverageHeight;
    impl ::cynic::schema::Field for AverageHeight {
        type SchemaType = Option<super::Float>;
        fn name() -> &'static str {
            "averageHeight"
        }
    }
    impl ::cynic::schema::HasField<AverageHeight, Option<super::Float>> for super::Species {}
    pub struct AverageLifespan;
    impl ::cynic::schema::Field for AverageLifespan {
        type SchemaType = Option<super::Int>;
        fn name() -> &'static str {
            "averageLifespan"
        }
    }
    impl ::cynic::schema::HasField<AverageLifespan, Option<super::Int>> for super::Species {}
    pub struct EyeColors;
    impl ::cynic::schema::Field for EyeColors {
        type SchemaType = Option<Vec<Option<super::String>>>;
        fn name() -> &'static str {
            "eyeColors"
        }
    }
    impl ::cynic::schema::HasField<EyeColors, Option<Vec<Option<super::String>>>> for super::Species {}
    pub struct HairColors;
    impl ::cynic::schema::Field for HairColors {
        type SchemaType = Option<Vec<Option<super::String>>>;
        fn name() -> &'static str {
            "hairColors"
        }
    }
    impl ::cynic::schema::HasField<HairColors, Option<Vec<Option<super::String>>>> for super::Species {}
    pub struct SkinColors;
    impl ::cynic::schema::Field for SkinColors {
        type SchemaType = Option<Vec<Option<super::String>>>;
        fn name() -> &'static str {
            "skinColors"
        }
    }
    impl ::cynic::schema::HasField<SkinColors, Option<Vec<Option<super::String>>>> for super::Species {}
    pub struct Language;
    impl ::cynic::schema::Field for Language {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "language"
        }
    }
    impl ::cynic::schema::HasField<Language, Option<super::String>> for super::Species {}
    pub struct Homeworld;
    impl ::cynic::schema::Field for Homeworld {
        type SchemaType = Option<super::Planet>;
        fn name() -> &'static str {
            "homeworld"
        }
    }
    impl ::cynic::schema::HasField<Homeworld, Option<super::Planet>> for super::Species {}
    pub struct PersonConnection;
    impl ::cynic::schema::Field for PersonConnection {
        type SchemaType = Option<super::SpeciesPeopleConnection>;
        fn name() -> &'static str {
            "personConnection"
        }
    }
    impl ::cynic::schema::HasField<PersonConnection, Option<super::SpeciesPeopleConnection>>
        for super::Species
    {
    }
    pub mod person_connection_arguments {
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::PersonConnection {
            type ArgumentSchemaType = Option<super::super::String>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "after"
            }
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::PersonConnection {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "first"
            }
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::PersonConnection {
            type ArgumentSchemaType = Option<super::super::String>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "before"
            }
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::PersonConnection {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "last"
            }
        }
    }
    pub struct FilmConnection;
    impl ::cynic::schema::Field for FilmConnection {
        type SchemaType = Option<super::SpeciesFilmsConnection>;
        fn name() -> &'static str {
            "filmConnection"
        }
    }
    impl ::cynic::schema::HasField<FilmConnection, Option<super::SpeciesFilmsConnection>>
        for super::Species
    {
    }
    pub mod film_connection_arguments {
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::FilmConnection {
            type ArgumentSchemaType = Option<super::super::String>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "after"
            }
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::FilmConnection {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "first"
            }
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::FilmConnection {
            type ArgumentSchemaType = Option<super::super::String>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "before"
            }
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::FilmConnection {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "last"
            }
        }
    }
    pub struct Created;
    impl ::cynic::schema::Field for Created {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "created"
        }
    }
    impl ::cynic::schema::HasField<Created, Option<super::String>> for super::Species {}
    pub struct Edited;
    impl ::cynic::schema::Field for Edited {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "edited"
        }
    }
    impl ::cynic::schema::HasField<Edited, Option<super::String>> for super::Species {}
    pub struct Id;
    impl ::cynic::schema::Field for Id {
        type SchemaType = super::Id;
        fn name() -> &'static str {
            "id"
        }
    }
    impl ::cynic::schema::HasField<Id, super::Id> for super::Species {}
}
pub struct SpeciesConnection;
pub mod species_connection_fields {
    pub struct PageInfo;
    impl ::cynic::schema::Field for PageInfo {
        type SchemaType = super::PageInfo;
        fn name() -> &'static str {
            "pageInfo"
        }
    }
    impl ::cynic::schema::HasField<PageInfo, super::PageInfo> for super::SpeciesConnection {}
    pub struct Edges;
    impl ::cynic::schema::Field for Edges {
        type SchemaType = Option<Vec<Option<super::SpeciesEdge>>>;
        fn name() -> &'static str {
            "edges"
        }
    }
    impl ::cynic::schema::HasField<Edges, Option<Vec<Option<super::SpeciesEdge>>>>
        for super::SpeciesConnection
    {
    }
    pub struct TotalCount;
    impl ::cynic::schema::Field for TotalCount {
        type SchemaType = Option<super::Int>;
        fn name() -> &'static str {
            "totalCount"
        }
    }
    impl ::cynic::schema::HasField<TotalCount, Option<super::Int>> for super::SpeciesConnection {}
    pub struct Species;
    impl ::cynic::schema::Field for Species {
        type SchemaType = Option<Vec<Option<super::Species>>>;
        fn name() -> &'static str {
            "species"
        }
    }
    impl ::cynic::schema::HasField<Species, Option<Vec<Option<super::Species>>>>
        for super::SpeciesConnection
    {
    }
}
pub struct SpeciesEdge;
pub mod species_edge_fields {
    pub struct Node;
    impl ::cynic::schema::Field for Node {
        type SchemaType = Option<super::Species>;
        fn name() -> &'static str {
            "node"
        }
    }
    impl ::cynic::schema::HasField<Node, Option<super::Species>> for super::SpeciesEdge {}
    pub struct Cursor;
    impl ::cynic::schema::Field for Cursor {
        type SchemaType = super::String;
        fn name() -> &'static str {
            "cursor"
        }
    }
    impl ::cynic::schema::HasField<Cursor, super::String> for super::SpeciesEdge {}
}
pub struct SpeciesFilmsConnection;
pub mod species_films_connection_fields {
    pub struct PageInfo;
    impl ::cynic::schema::Field for PageInfo {
        type SchemaType = super::PageInfo;
        fn name() -> &'static str {
            "pageInfo"
        }
    }
    impl ::cynic::schema::HasField<PageInfo, super::PageInfo> for super::SpeciesFilmsConnection {}
    pub struct Edges;
    impl ::cynic::schema::Field for Edges {
        type SchemaType = Option<Vec<Option<super::SpeciesFilmsEdge>>>;
        fn name() -> &'static str {
            "edges"
        }
    }
    impl ::cynic::schema::HasField<Edges, Option<Vec<Option<super::SpeciesFilmsEdge>>>>
        for super::SpeciesFilmsConnection
    {
    }
    pub struct TotalCount;
    impl ::cynic::schema::Field for TotalCount {
        type SchemaType = Option<super::Int>;
        fn name() -> &'static str {
            "totalCount"
        }
    }
    impl ::cynic::schema::HasField<TotalCount, Option<super::Int>> for super::SpeciesFilmsConnection {}
    pub struct Films;
    impl ::cynic::schema::Field for Films {
        type SchemaType = Option<Vec<Option<super::Film>>>;
        fn name() -> &'static str {
            "films"
        }
    }
    impl ::cynic::schema::HasField<Films, Option<Vec<Option<super::Film>>>>
        for super::SpeciesFilmsConnection
    {
    }
}
pub struct SpeciesFilmsEdge;
pub mod species_films_edge_fields {
    pub struct Node;
    impl ::cynic::schema::Field for Node {
        type SchemaType = Option<super::Film>;
        fn name() -> &'static str {
            "node"
        }
    }
    impl ::cynic::schema::HasField<Node, Option<super::Film>> for super::SpeciesFilmsEdge {}
    pub struct Cursor;
    impl ::cynic::schema::Field for Cursor {
        type SchemaType = super::String;
        fn name() -> &'static str {
            "cursor"
        }
    }
    impl ::cynic::schema::HasField<Cursor, super::String> for super::SpeciesFilmsEdge {}
}
pub struct SpeciesPeopleConnection;
pub mod species_people_connection_fields {
    pub struct PageInfo;
    impl ::cynic::schema::Field for PageInfo {
        type SchemaType = super::PageInfo;
        fn name() -> &'static str {
            "pageInfo"
        }
    }
    impl ::cynic::schema::HasField<PageInfo, super::PageInfo> for super::SpeciesPeopleConnection {}
    pub struct Edges;
    impl ::cynic::schema::Field for Edges {
        type SchemaType = Option<Vec<Option<super::SpeciesPeopleEdge>>>;
        fn name() -> &'static str {
            "edges"
        }
    }
    impl ::cynic::schema::HasField<Edges, Option<Vec<Option<super::SpeciesPeopleEdge>>>>
        for super::SpeciesPeopleConnection
    {
    }
    pub struct TotalCount;
    impl ::cynic::schema::Field for TotalCount {
        type SchemaType = Option<super::Int>;
        fn name() -> &'static str {
            "totalCount"
        }
    }
    impl ::cynic::schema::HasField<TotalCount, Option<super::Int>> for super::SpeciesPeopleConnection {}
    pub struct People;
    impl ::cynic::schema::Field for People {
        type SchemaType = Option<Vec<Option<super::Person>>>;
        fn name() -> &'static str {
            "people"
        }
    }
    impl ::cynic::schema::HasField<People, Option<Vec<Option<super::Person>>>>
        for super::SpeciesPeopleConnection
    {
    }
}
pub struct SpeciesPeopleEdge;
pub mod species_people_edge_fields {
    pub struct Node;
    impl ::cynic::schema::Field for Node {
        type SchemaType = Option<super::Person>;
        fn name() -> &'static str {
            "node"
        }
    }
    impl ::cynic::schema::HasField<Node, Option<super::Person>> for super::SpeciesPeopleEdge {}
    pub struct Cursor;
    impl ::cynic::schema::Field for Cursor {
        type SchemaType = super::String;
        fn name() -> &'static str {
            "cursor"
        }
    }
    impl ::cynic::schema::HasField<Cursor, super::String> for super::SpeciesPeopleEdge {}
}
pub struct Starship;
pub mod starship_fields {
    pub struct Name;
    impl ::cynic::schema::Field for Name {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "name"
        }
    }
    impl ::cynic::schema::HasField<Name, Option<super::String>> for super::Starship {}
    pub struct Model;
    impl ::cynic::schema::Field for Model {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "model"
        }
    }
    impl ::cynic::schema::HasField<Model, Option<super::String>> for super::Starship {}
    pub struct StarshipClass;
    impl ::cynic::schema::Field for StarshipClass {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "starshipClass"
        }
    }
    impl ::cynic::schema::HasField<StarshipClass, Option<super::String>> for super::Starship {}
    pub struct Manufacturers;
    impl ::cynic::schema::Field for Manufacturers {
        type SchemaType = Option<Vec<Option<super::String>>>;
        fn name() -> &'static str {
            "manufacturers"
        }
    }
    impl ::cynic::schema::HasField<Manufacturers, Option<Vec<Option<super::String>>>>
        for super::Starship
    {
    }
    pub struct CostInCredits;
    impl ::cynic::schema::Field for CostInCredits {
        type SchemaType = Option<super::Float>;
        fn name() -> &'static str {
            "costInCredits"
        }
    }
    impl ::cynic::schema::HasField<CostInCredits, Option<super::Float>> for super::Starship {}
    pub struct Length;
    impl ::cynic::schema::Field for Length {
        type SchemaType = Option<super::Float>;
        fn name() -> &'static str {
            "length"
        }
    }
    impl ::cynic::schema::HasField<Length, Option<super::Float>> for super::Starship {}
    pub struct Crew;
    impl ::cynic::schema::Field for Crew {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "crew"
        }
    }
    impl ::cynic::schema::HasField<Crew, Option<super::String>> for super::Starship {}
    pub struct Passengers;
    impl ::cynic::schema::Field for Passengers {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "passengers"
        }
    }
    impl ::cynic::schema::HasField<Passengers, Option<super::String>> for super::Starship {}
    pub struct MaxAtmospheringSpeed;
    impl ::cynic::schema::Field for MaxAtmospheringSpeed {
        type SchemaType = Option<super::Int>;
        fn name() -> &'static str {
            "maxAtmospheringSpeed"
        }
    }
    impl ::cynic::schema::HasField<MaxAtmospheringSpeed, Option<super::Int>> for super::Starship {}
    pub struct HyperdriveRating;
    impl ::cynic::schema::Field for HyperdriveRating {
        type SchemaType = Option<super::Float>;
        fn name() -> &'static str {
            "hyperdriveRating"
        }
    }
    impl ::cynic::schema::HasField<HyperdriveRating, Option<super::Float>> for super::Starship {}
    pub struct Mglt;
    impl ::cynic::schema::Field for Mglt {
        type SchemaType = Option<super::Int>;
        fn name() -> &'static str {
            "MGLT"
        }
    }
    impl ::cynic::schema::HasField<Mglt, Option<super::Int>> for super::Starship {}
    pub struct CargoCapacity;
    impl ::cynic::schema::Field for CargoCapacity {
        type SchemaType = Option<super::Float>;
        fn name() -> &'static str {
            "cargoCapacity"
        }
    }
    impl ::cynic::schema::HasField<CargoCapacity, Option<super::Float>> for super::Starship {}
    pub struct Consumables;
    impl ::cynic::schema::Field for Consumables {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "consumables"
        }
    }
    impl ::cynic::schema::HasField<Consumables, Option<super::String>> for super::Starship {}
    pub struct PilotConnection;
    impl ::cynic::schema::Field for PilotConnection {
        type SchemaType = Option<super::StarshipPilotsConnection>;
        fn name() -> &'static str {
            "pilotConnection"
        }
    }
    impl ::cynic::schema::HasField<PilotConnection, Option<super::StarshipPilotsConnection>>
        for super::Starship
    {
    }
    pub mod pilot_connection_arguments {
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::PilotConnection {
            type ArgumentSchemaType = Option<super::super::String>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "after"
            }
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::PilotConnection {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "first"
            }
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::PilotConnection {
            type ArgumentSchemaType = Option<super::super::String>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "before"
            }
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::PilotConnection {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "last"
            }
        }
    }
    pub struct FilmConnection;
    impl ::cynic::schema::Field for FilmConnection {
        type SchemaType = Option<super::StarshipFilmsConnection>;
        fn name() -> &'static str {
            "filmConnection"
        }
    }
    impl ::cynic::schema::HasField<FilmConnection, Option<super::StarshipFilmsConnection>>
        for super::Starship
    {
    }
    pub mod film_connection_arguments {
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::FilmConnection {
            type ArgumentSchemaType = Option<super::super::String>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "after"
            }
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::FilmConnection {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "first"
            }
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::FilmConnection {
            type ArgumentSchemaType = Option<super::super::String>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "before"
            }
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::FilmConnection {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "last"
            }
        }
    }
    pub struct Created;
    impl ::cynic::schema::Field for Created {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "created"
        }
    }
    impl ::cynic::schema::HasField<Created, Option<super::String>> for super::Starship {}
    pub struct Edited;
    impl ::cynic::schema::Field for Edited {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "edited"
        }
    }
    impl ::cynic::schema::HasField<Edited, Option<super::String>> for super::Starship {}
    pub struct Id;
    impl ::cynic::schema::Field for Id {
        type SchemaType = super::Id;
        fn name() -> &'static str {
            "id"
        }
    }
    impl ::cynic::schema::HasField<Id, super::Id> for super::Starship {}
}
pub struct StarshipFilmsConnection;
pub mod starship_films_connection_fields {
    pub struct PageInfo;
    impl ::cynic::schema::Field for PageInfo {
        type SchemaType = super::PageInfo;
        fn name() -> &'static str {
            "pageInfo"
        }
    }
    impl ::cynic::schema::HasField<PageInfo, super::PageInfo> for super::StarshipFilmsConnection {}
    pub struct Edges;
    impl ::cynic::schema::Field for Edges {
        type SchemaType = Option<Vec<Option<super::StarshipFilmsEdge>>>;
        fn name() -> &'static str {
            "edges"
        }
    }
    impl ::cynic::schema::HasField<Edges, Option<Vec<Option<super::StarshipFilmsEdge>>>>
        for super::StarshipFilmsConnection
    {
    }
    pub struct TotalCount;
    impl ::cynic::schema::Field for TotalCount {
        type SchemaType = Option<super::Int>;
        fn name() -> &'static str {
            "totalCount"
        }
    }
    impl ::cynic::schema::HasField<TotalCount, Option<super::Int>> for super::StarshipFilmsConnection {}
    pub struct Films;
    impl ::cynic::schema::Field for Films {
        type SchemaType = Option<Vec<Option<super::Film>>>;
        fn name() -> &'static str {
            "films"
        }
    }
    impl ::cynic::schema::HasField<Films, Option<Vec<Option<super::Film>>>>
        for super::StarshipFilmsConnection
    {
    }
}
pub struct StarshipFilmsEdge;
pub mod starship_films_edge_fields {
    pub struct Node;
    impl ::cynic::schema::Field for Node {
        type SchemaType = Option<super::Film>;
        fn name() -> &'static str {
            "node"
        }
    }
    impl ::cynic::schema::HasField<Node, Option<super::Film>> for super::StarshipFilmsEdge {}
    pub struct Cursor;
    impl ::cynic::schema::Field for Cursor {
        type SchemaType = super::String;
        fn name() -> &'static str {
            "cursor"
        }
    }
    impl ::cynic::schema::HasField<Cursor, super::String> for super::StarshipFilmsEdge {}
}
pub struct StarshipPilotsConnection;
pub mod starship_pilots_connection_fields {
    pub struct PageInfo;
    impl ::cynic::schema::Field for PageInfo {
        type SchemaType = super::PageInfo;
        fn name() -> &'static str {
            "pageInfo"
        }
    }
    impl ::cynic::schema::HasField<PageInfo, super::PageInfo> for super::StarshipPilotsConnection {}
    pub struct Edges;
    impl ::cynic::schema::Field for Edges {
        type SchemaType = Option<Vec<Option<super::StarshipPilotsEdge>>>;
        fn name() -> &'static str {
            "edges"
        }
    }
    impl ::cynic::schema::HasField<Edges, Option<Vec<Option<super::StarshipPilotsEdge>>>>
        for super::StarshipPilotsConnection
    {
    }
    pub struct TotalCount;
    impl ::cynic::schema::Field for TotalCount {
        type SchemaType = Option<super::Int>;
        fn name() -> &'static str {
            "totalCount"
        }
    }
    impl ::cynic::schema::HasField<TotalCount, Option<super::Int>> for super::StarshipPilotsConnection {}
    pub struct Pilots;
    impl ::cynic::schema::Field for Pilots {
        type SchemaType = Option<Vec<Option<super::Person>>>;
        fn name() -> &'static str {
            "pilots"
        }
    }
    impl ::cynic::schema::HasField<Pilots, Option<Vec<Option<super::Person>>>>
        for super::StarshipPilotsConnection
    {
    }
}
pub struct StarshipPilotsEdge;
pub mod starship_pilots_edge_fields {
    pub struct Node;
    impl ::cynic::schema::Field for Node {
        type SchemaType = Option<super::Person>;
        fn name() -> &'static str {
            "node"
        }
    }
    impl ::cynic::schema::HasField<Node, Option<super::Person>> for super::StarshipPilotsEdge {}
    pub struct Cursor;
    impl ::cynic::schema::Field for Cursor {
        type SchemaType = super::String;
        fn name() -> &'static str {
            "cursor"
        }
    }
    impl ::cynic::schema::HasField<Cursor, super::String> for super::StarshipPilotsEdge {}
}
pub struct StarshipsConnection;
pub mod starships_connection_fields {
    pub struct PageInfo;
    impl ::cynic::schema::Field for PageInfo {
        type SchemaType = super::PageInfo;
        fn name() -> &'static str {
            "pageInfo"
        }
    }
    impl ::cynic::schema::HasField<PageInfo, super::PageInfo> for super::StarshipsConnection {}
    pub struct Edges;
    impl ::cynic::schema::Field for Edges {
        type SchemaType = Option<Vec<Option<super::StarshipsEdge>>>;
        fn name() -> &'static str {
            "edges"
        }
    }
    impl ::cynic::schema::HasField<Edges, Option<Vec<Option<super::StarshipsEdge>>>>
        for super::StarshipsConnection
    {
    }
    pub struct TotalCount;
    impl ::cynic::schema::Field for TotalCount {
        type SchemaType = Option<super::Int>;
        fn name() -> &'static str {
            "totalCount"
        }
    }
    impl ::cynic::schema::HasField<TotalCount, Option<super::Int>> for super::StarshipsConnection {}
    pub struct Starships;
    impl ::cynic::schema::Field for Starships {
        type SchemaType = Option<Vec<Option<super::Starship>>>;
        fn name() -> &'static str {
            "starships"
        }
    }
    impl ::cynic::schema::HasField<Starships, Option<Vec<Option<super::Starship>>>>
        for super::StarshipsConnection
    {
    }
}
pub struct StarshipsEdge;
pub mod starships_edge_fields {
    pub struct Node;
    impl ::cynic::schema::Field for Node {
        type SchemaType = Option<super::Starship>;
        fn name() -> &'static str {
            "node"
        }
    }
    impl ::cynic::schema::HasField<Node, Option<super::Starship>> for super::StarshipsEdge {}
    pub struct Cursor;
    impl ::cynic::schema::Field for Cursor {
        type SchemaType = super::String;
        fn name() -> &'static str {
            "cursor"
        }
    }
    impl ::cynic::schema::HasField<Cursor, super::String> for super::StarshipsEdge {}
}
pub struct Vehicle;
pub mod vehicle_fields {
    pub struct Name;
    impl ::cynic::schema::Field for Name {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "name"
        }
    }
    impl ::cynic::schema::HasField<Name, Option<super::String>> for super::Vehicle {}
    pub struct Model;
    impl ::cynic::schema::Field for Model {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "model"
        }
    }
    impl ::cynic::schema::HasField<Model, Option<super::String>> for super::Vehicle {}
    pub struct VehicleClass;
    impl ::cynic::schema::Field for VehicleClass {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "vehicleClass"
        }
    }
    impl ::cynic::schema::HasField<VehicleClass, Option<super::String>> for super::Vehicle {}
    pub struct Manufacturers;
    impl ::cynic::schema::Field for Manufacturers {
        type SchemaType = Option<Vec<Option<super::String>>>;
        fn name() -> &'static str {
            "manufacturers"
        }
    }
    impl ::cynic::schema::HasField<Manufacturers, Option<Vec<Option<super::String>>>>
        for super::Vehicle
    {
    }
    pub struct CostInCredits;
    impl ::cynic::schema::Field for CostInCredits {
        type SchemaType = Option<super::Float>;
        fn name() -> &'static str {
            "costInCredits"
        }
    }
    impl ::cynic::schema::HasField<CostInCredits, Option<super::Float>> for super::Vehicle {}
    pub struct Length;
    impl ::cynic::schema::Field for Length {
        type SchemaType = Option<super::Float>;
        fn name() -> &'static str {
            "length"
        }
    }
    impl ::cynic::schema::HasField<Length, Option<super::Float>> for super::Vehicle {}
    pub struct Crew;
    impl ::cynic::schema::Field for Crew {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "crew"
        }
    }
    impl ::cynic::schema::HasField<Crew, Option<super::String>> for super::Vehicle {}
    pub struct Passengers;
    impl ::cynic::schema::Field for Passengers {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "passengers"
        }
    }
    impl ::cynic::schema::HasField<Passengers, Option<super::String>> for super::Vehicle {}
    pub struct MaxAtmospheringSpeed;
    impl ::cynic::schema::Field for MaxAtmospheringSpeed {
        type SchemaType = Option<super::Int>;
        fn name() -> &'static str {
            "maxAtmospheringSpeed"
        }
    }
    impl ::cynic::schema::HasField<MaxAtmospheringSpeed, Option<super::Int>> for super::Vehicle {}
    pub struct CargoCapacity;
    impl ::cynic::schema::Field for CargoCapacity {
        type SchemaType = Option<super::Float>;
        fn name() -> &'static str {
            "cargoCapacity"
        }
    }
    impl ::cynic::schema::HasField<CargoCapacity, Option<super::Float>> for super::Vehicle {}
    pub struct Consumables;
    impl ::cynic::schema::Field for Consumables {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "consumables"
        }
    }
    impl ::cynic::schema::HasField<Consumables, Option<super::String>> for super::Vehicle {}
    pub struct PilotConnection;
    impl ::cynic::schema::Field for PilotConnection {
        type SchemaType = Option<super::VehiclePilotsConnection>;
        fn name() -> &'static str {
            "pilotConnection"
        }
    }
    impl ::cynic::schema::HasField<PilotConnection, Option<super::VehiclePilotsConnection>>
        for super::Vehicle
    {
    }
    pub mod pilot_connection_arguments {
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::PilotConnection {
            type ArgumentSchemaType = Option<super::super::String>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "after"
            }
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::PilotConnection {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "first"
            }
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::PilotConnection {
            type ArgumentSchemaType = Option<super::super::String>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "before"
            }
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::PilotConnection {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "last"
            }
        }
    }
    pub struct FilmConnection;
    impl ::cynic::schema::Field for FilmConnection {
        type SchemaType = Option<super::VehicleFilmsConnection>;
        fn name() -> &'static str {
            "filmConnection"
        }
    }
    impl ::cynic::schema::HasField<FilmConnection, Option<super::VehicleFilmsConnection>>
        for super::Vehicle
    {
    }
    pub mod film_connection_arguments {
        pub struct After;
        impl ::cynic::schema::HasArgument<After> for super::FilmConnection {
            type ArgumentSchemaType = Option<super::super::String>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "after"
            }
        }
        pub struct First;
        impl ::cynic::schema::HasArgument<First> for super::FilmConnection {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "first"
            }
        }
        pub struct Before;
        impl ::cynic::schema::HasArgument<Before> for super::FilmConnection {
            type ArgumentSchemaType = Option<super::super::String>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "before"
            }
        }
        pub struct Last;
        impl ::cynic::schema::HasArgument<Last> for super::FilmConnection {
            type ArgumentSchemaType = Option<super::super::Int>;
            type ArgumentKind = ::cynic::schema::ScalarArgument;
            fn name() -> &'static str {
                "last"
            }
        }
    }
    pub struct Created;
    impl ::cynic::schema::Field for Created {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "created"
        }
    }
    impl ::cynic::schema::HasField<Created, Option<super::String>> for super::Vehicle {}
    pub struct Edited;
    impl ::cynic::schema::Field for Edited {
        type SchemaType = Option<super::String>;
        fn name() -> &'static str {
            "edited"
        }
    }
    impl ::cynic::schema::HasField<Edited, Option<super::String>> for super::Vehicle {}
    pub struct Id;
    impl ::cynic::schema::Field for Id {
        type SchemaType = super::Id;
        fn name() -> &'static str {
            "id"
        }
    }
    impl ::cynic::schema::HasField<Id, super::Id> for super::Vehicle {}
}
pub struct VehicleFilmsConnection;
pub mod vehicle_films_connection_fields {
    pub struct PageInfo;
    impl ::cynic::schema::Field for PageInfo {
        type SchemaType = super::PageInfo;
        fn name() -> &'static str {
            "pageInfo"
        }
    }
    impl ::cynic::schema::HasField<PageInfo, super::PageInfo> for super::VehicleFilmsConnection {}
    pub struct Edges;
    impl ::cynic::schema::Field for Edges {
        type SchemaType = Option<Vec<Option<super::VehicleFilmsEdge>>>;
        fn name() -> &'static str {
            "edges"
        }
    }
    impl ::cynic::schema::HasField<Edges, Option<Vec<Option<super::VehicleFilmsEdge>>>>
        for super::VehicleFilmsConnection
    {
    }
    pub struct TotalCount;
    impl ::cynic::schema::Field for TotalCount {
        type SchemaType = Option<super::Int>;
        fn name() -> &'static str {
            "totalCount"
        }
    }
    impl ::cynic::schema::HasField<TotalCount, Option<super::Int>> for super::VehicleFilmsConnection {}
    pub struct Films;
    impl ::cynic::schema::Field for Films {
        type SchemaType = Option<Vec<Option<super::Film>>>;
        fn name() -> &'static str {
            "films"
        }
    }
    impl ::cynic::schema::HasField<Films, Option<Vec<Option<super::Film>>>>
        for super::VehicleFilmsConnection
    {
    }
}
pub struct VehicleFilmsEdge;
pub mod vehicle_films_edge_fields {
    pub struct Node;
    impl ::cynic::schema::Field for Node {
        type SchemaType = Option<super::Film>;
        fn name() -> &'static str {
            "node"
        }
    }
    impl ::cynic::schema::HasField<Node, Option<super::Film>> for super::VehicleFilmsEdge {}
    pub struct Cursor;
    impl ::cynic::schema::Field for Cursor {
        type SchemaType = super::String;
        fn name() -> &'static str {
            "cursor"
        }
    }
    impl ::cynic::schema::HasField<Cursor, super::String> for super::VehicleFilmsEdge {}
}
pub struct VehiclePilotsConnection;
pub mod vehicle_pilots_connection_fields {
    pub struct PageInfo;
    impl ::cynic::schema::Field for PageInfo {
        type SchemaType = super::PageInfo;
        fn name() -> &'static str {
            "pageInfo"
        }
    }
    impl ::cynic::schema::HasField<PageInfo, super::PageInfo> for super::VehiclePilotsConnection {}
    pub struct Edges;
    impl ::cynic::schema::Field for Edges {
        type SchemaType = Option<Vec<Option<super::VehiclePilotsEdge>>>;
        fn name() -> &'static str {
            "edges"
        }
    }
    impl ::cynic::schema::HasField<Edges, Option<Vec<Option<super::VehiclePilotsEdge>>>>
        for super::VehiclePilotsConnection
    {
    }
    pub struct TotalCount;
    impl ::cynic::schema::Field for TotalCount {
        type SchemaType = Option<super::Int>;
        fn name() -> &'static str {
            "totalCount"
        }
    }
    impl ::cynic::schema::HasField<TotalCount, Option<super::Int>> for super::VehiclePilotsConnection {}
    pub struct Pilots;
    impl ::cynic::schema::Field for Pilots {
        type SchemaType = Option<Vec<Option<super::Person>>>;
        fn name() -> &'static str {
            "pilots"
        }
    }
    impl ::cynic::schema::HasField<Pilots, Option<Vec<Option<super::Person>>>>
        for super::VehiclePilotsConnection
    {
    }
}
pub struct VehiclePilotsEdge;
pub mod vehicle_pilots_edge_fields {
    pub struct Node;
    impl ::cynic::schema::Field for Node {
        type SchemaType = Option<super::Person>;
        fn name() -> &'static str {
            "node"
        }
    }
    impl ::cynic::schema::HasField<Node, Option<super::Person>> for super::VehiclePilotsEdge {}
    pub struct Cursor;
    impl ::cynic::schema::Field for Cursor {
        type SchemaType = super::String;
        fn name() -> &'static str {
            "cursor"
        }
    }
    impl ::cynic::schema::HasField<Cursor, super::String> for super::VehiclePilotsEdge {}
}
pub struct VehiclesConnection;
pub mod vehicles_connection_fields {
    pub struct PageInfo;
    impl ::cynic::schema::Field for PageInfo {
        type SchemaType = super::PageInfo;
        fn name() -> &'static str {
            "pageInfo"
        }
    }
    impl ::cynic::schema::HasField<PageInfo, super::PageInfo> for super::VehiclesConnection {}
    pub struct Edges;
    impl ::cynic::schema::Field for Edges {
        type SchemaType = Option<Vec<Option<super::VehiclesEdge>>>;
        fn name() -> &'static str {
            "edges"
        }
    }
    impl ::cynic::schema::HasField<Edges, Option<Vec<Option<super::VehiclesEdge>>>>
        for super::VehiclesConnection
    {
    }
    pub struct TotalCount;
    impl ::cynic::schema::Field for TotalCount {
        type SchemaType = Option<super::Int>;
        fn name() -> &'static str {
            "totalCount"
        }
    }
    impl ::cynic::schema::HasField<TotalCount, Option<super::Int>> for super::VehiclesConnection {}
    pub struct Vehicles;
    impl ::cynic::schema::Field for Vehicles {
        type SchemaType = Option<Vec<Option<super::Vehicle>>>;
        fn name() -> &'static str {
            "vehicles"
        }
    }
    impl ::cynic::schema::HasField<Vehicles, Option<Vec<Option<super::Vehicle>>>>
        for super::VehiclesConnection
    {
    }
}
pub struct VehiclesEdge;
pub mod vehicles_edge_fields {
    pub struct Node;
    impl ::cynic::schema::Field for Node {
        type SchemaType = Option<super::Vehicle>;
        fn name() -> &'static str {
            "node"
        }
    }
    impl ::cynic::schema::HasField<Node, Option<super::Vehicle>> for super::VehiclesEdge {}
    pub struct Cursor;
    impl ::cynic::schema::Field for Cursor {
        type SchemaType = super::String;
        fn name() -> &'static str {
            "cursor"
        }
    }
    impl ::cynic::schema::HasField<Cursor, super::String> for super::VehiclesEdge {}
}
impl ::cynic::schema::HasSubtype<Film> for Node {}
impl ::cynic::schema::HasSubtype<Node> for Node {}
impl ::cynic::schema::HasSubtype<Person> for Node {}
impl ::cynic::schema::HasSubtype<Planet> for Node {}
impl ::cynic::schema::HasSubtype<Species> for Node {}
impl ::cynic::schema::HasSubtype<Starship> for Node {}
impl ::cynic::schema::HasSubtype<Vehicle> for Node {}
impl ::cynic::schema::NamedType for Film {
    fn name() -> &'static str {
        "Film"
    }
}
impl ::cynic::schema::NamedType for FilmCharactersConnection {
    fn name() -> &'static str {
        "FilmCharactersConnection"
    }
}
impl ::cynic::schema::NamedType for FilmCharactersEdge {
    fn name() -> &'static str {
        "FilmCharactersEdge"
    }
}
impl ::cynic::schema::NamedType for FilmPlanetsConnection {
    fn name() -> &'static str {
        "FilmPlanetsConnection"
    }
}
impl ::cynic::schema::NamedType for FilmPlanetsEdge {
    fn name() -> &'static str {
        "FilmPlanetsEdge"
    }
}
impl ::cynic::schema::NamedType for FilmSpeciesConnection {
    fn name() -> &'static str {
        "FilmSpeciesConnection"
    }
}
impl ::cynic::schema::NamedType for FilmSpeciesEdge {
    fn name() -> &'static str {
        "FilmSpeciesEdge"
    }
}
impl ::cynic::schema::NamedType for FilmStarshipsConnection {
    fn name() -> &'static str {
        "FilmStarshipsConnection"
    }
}
impl ::cynic::schema::NamedType for FilmStarshipsEdge {
    fn name() -> &'static str {
        "FilmStarshipsEdge"
    }
}
impl ::cynic::schema::NamedType for FilmVehiclesConnection {
    fn name() -> &'static str {
        "FilmVehiclesConnection"
    }
}
impl ::cynic::schema::NamedType for FilmVehiclesEdge {
    fn name() -> &'static str {
        "FilmVehiclesEdge"
    }
}
impl ::cynic::schema::NamedType for FilmsConnection {
    fn name() -> &'static str {
        "FilmsConnection"
    }
}
impl ::cynic::schema::NamedType for FilmsEdge {
    fn name() -> &'static str {
        "FilmsEdge"
    }
}
impl ::cynic::schema::NamedType for Node {
    fn name() -> &'static str {
        "Node"
    }
}
impl ::cynic::schema::NamedType for PageInfo {
    fn name() -> &'static str {
        "PageInfo"
    }
}
impl ::cynic::schema::NamedType for PeopleConnection {
    fn name() -> &'static str {
        "PeopleConnection"
    }
}
impl ::cynic::schema::NamedType for PeopleEdge {
    fn name() -> &'static str {
        "PeopleEdge"
    }
}
impl ::cynic::schema::NamedType for Person {
    fn name() -> &'static str {
        "Person"
    }
}
impl ::cynic::schema::NamedType for PersonFilmsConnection {
    fn name() -> &'static str {
        "PersonFilmsConnection"
    }
}
impl ::cynic::schema::NamedType for PersonFilmsEdge {
    fn name() -> &'static str {
        "PersonFilmsEdge"
    }
}
impl ::cynic::schema::NamedType for PersonStarshipsConnection {
    fn name() -> &'static str {
        "PersonStarshipsConnection"
    }
}
impl ::cynic::schema::NamedType for PersonStarshipsEdge {
    fn name() -> &'static str {
        "PersonStarshipsEdge"
    }
}
impl ::cynic::schema::NamedType for PersonVehiclesConnection {
    fn name() -> &'static str {
        "PersonVehiclesConnection"
    }
}
impl ::cynic::schema::NamedType for PersonVehiclesEdge {
    fn name() -> &'static str {
        "PersonVehiclesEdge"
    }
}
impl ::cynic::schema::NamedType for Planet {
    fn name() -> &'static str {
        "Planet"
    }
}
impl ::cynic::schema::NamedType for PlanetFilmsConnection {
    fn name() -> &'static str {
        "PlanetFilmsConnection"
    }
}
impl ::cynic::schema::NamedType for PlanetFilmsEdge {
    fn name() -> &'static str {
        "PlanetFilmsEdge"
    }
}
impl ::cynic::schema::NamedType for PlanetResidentsConnection {
    fn name() -> &'static str {
        "PlanetResidentsConnection"
    }
}
impl ::cynic::schema::NamedType for PlanetResidentsEdge {
    fn name() -> &'static str {
        "PlanetResidentsEdge"
    }
}
impl ::cynic::schema::NamedType for PlanetsConnection {
    fn name() -> &'static str {
        "PlanetsConnection"
    }
}
impl ::cynic::schema::NamedType for PlanetsEdge {
    fn name() -> &'static str {
        "PlanetsEdge"
    }
}
impl ::cynic::schema::NamedType for Root {
    fn name() -> &'static str {
        "Root"
    }
}
impl ::cynic::schema::NamedType for Species {
    fn name() -> &'static str {
        "Species"
    }
}
impl ::cynic::schema::NamedType for SpeciesConnection {
    fn name() -> &'static str {
        "SpeciesConnection"
    }
}
impl ::cynic::schema::NamedType for SpeciesEdge {
    fn name() -> &'static str {
        "SpeciesEdge"
    }
}
impl ::cynic::schema::NamedType for SpeciesFilmsConnection {
    fn name() -> &'static str {
        "SpeciesFilmsConnection"
    }
}
impl ::cynic::schema::NamedType for SpeciesFilmsEdge {
    fn name() -> &'static str {
        "SpeciesFilmsEdge"
    }
}
impl ::cynic::schema::NamedType for SpeciesPeopleConnection {
    fn name() -> &'static str {
        "SpeciesPeopleConnection"
    }
}
impl ::cynic::schema::NamedType for SpeciesPeopleEdge {
    fn name() -> &'static str {
        "SpeciesPeopleEdge"
    }
}
impl ::cynic::schema::NamedType for Starship {
    fn name() -> &'static str {
        "Starship"
    }
}
impl ::cynic::schema::NamedType for StarshipFilmsConnection {
    fn name() -> &'static str {
        "StarshipFilmsConnection"
    }
}
impl ::cynic::schema::NamedType for StarshipFilmsEdge {
    fn name() -> &'static str {
        "StarshipFilmsEdge"
    }
}
impl ::cynic::schema::NamedType for StarshipPilotsConnection {
    fn name() -> &'static str {
        "StarshipPilotsConnection"
    }
}
impl ::cynic::schema::NamedType for StarshipPilotsEdge {
    fn name() -> &'static str {
        "StarshipPilotsEdge"
    }
}
impl ::cynic::schema::NamedType for StarshipsConnection {
    fn name() -> &'static str {
        "StarshipsConnection"
    }
}
impl ::cynic::schema::NamedType for StarshipsEdge {
    fn name() -> &'static str {
        "StarshipsEdge"
    }
}
impl ::cynic::schema::NamedType for Vehicle {
    fn name() -> &'static str {
        "Vehicle"
    }
}
impl ::cynic::schema::NamedType for VehicleFilmsConnection {
    fn name() -> &'static str {
        "VehicleFilmsConnection"
    }
}
impl ::cynic::schema::NamedType for VehicleFilmsEdge {
    fn name() -> &'static str {
        "VehicleFilmsEdge"
    }
}
impl ::cynic::schema::NamedType for VehiclePilotsConnection {
    fn name() -> &'static str {
        "VehiclePilotsConnection"
    }
}
impl ::cynic::schema::NamedType for VehiclePilotsEdge {
    fn name() -> &'static str {
        "VehiclePilotsEdge"
    }
}
impl ::cynic::schema::NamedType for VehiclesConnection {
    fn name() -> &'static str {
        "VehiclesConnection"
    }
}
impl ::cynic::schema::NamedType for VehiclesEdge {
    fn name() -> &'static str {
        "VehiclesEdge"
    }
}
pub type Boolean = bool;
pub type String = std::string::String;
pub type Float = f64;
pub type Int = i32;
pub type Id = cynic::Id;

