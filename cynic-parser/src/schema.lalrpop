use std::str::FromStr;

use crate::ast::{Schema, Field, Object};
use crate::lexer;

use crate::builder::{
    RootOperationTypeDefinition, OperationType, AstBuilder, NodeId, SchemaDefinition,
    ObjectDefinition, FieldDefinition
};

grammar<'input>(input: &'input str, builder: &mut AstBuilder);

pub SchemaDefinition: SchemaDefinition = {
    schema "{" <roots:RootOperationTypeDefinition*> "}" => SchemaDefinition { <> }
};

pub RootOperationTypeDefinition: RootOperationTypeDefinition = {
    query ":" <name:NamedType> => RootOperationTypeDefinition {
        operation_type: OperationType::Query,
        named_type: name
    }
}

pub Object: ObjectDefinition = {
    ty <name:Name> "{" <fields:FieldDefinitions> "}" => ObjectDefinition { <> }
};

FieldDefinitions: Vec<NodeId> = {
    (FieldDefinition+)
};

FieldDefinition: NodeId = <name:Name> ":" <ty:NamedType> =>
    builder.field_definition(FieldDefinition { <> });

Name: NodeId = <s:Ident> => builder.ident(s);

NamedType: NodeId = <s:Ident> => builder.ident(s);

// TODO: Make this NodeId probably...
Ident: &'input str = {
    <s:RawIdent> => s,
    schema => "schema",
    query => "query",
    ty => "type",
}

extern {
    type Location = usize;
    type Error = lexer::LexicalError;

    enum lexer::Token<'input> {
        "$" => lexer::Token::Dollar,

        ":" => lexer::Token::Colon,

        "{" => lexer::Token::OpenBrace,
        "}" => lexer::Token::CloseBrace,

        RawIdent => lexer::Token::Identifier(<&'input str>),

        // Would be nice if these could just be aliases of `Identifier` but LARLPOP doesn't
        // seem to support this well: https://github.com/lalrpop/lalrpop/issues/671
        schema => lexer::Token::Schema,
        query => lexer::Token::Query,
        ty => lexer::Token::Type,
    }
}