use std::str::FromStr;

use crate::lexer;

use crate::ast::{*, ids::NodeId};

grammar<'input>(input: &'input str, ast: &mut Ast);

pub TypeSystemDocument: () = {
    <defs:DefinitionAndDescription+> => ast.definitions(defs),
}

pub DefinitionAndDescription: (Option<NodeId>, NodeId) = {
    <description:StringValue?> <def:TypeSystemDefinition> => (description, def)
}

pub TypeSystemDefinition: NodeId = {
    <def:SchemaDefinition> => ast.schema_definition(def),
    <def:ObjectDefinition> => ast.object_definition(def),
    <def:InputObjectDefinition> => ast.input_object_definition(def)
}

pub SchemaDefinition: SchemaDefinition = {
    schema "{" <roots:RootOperationTypeDefinition*> "}" => SchemaDefinition { <> }
};

pub RootOperationTypeDefinition: RootOperationTypeDefinition = {
    query ":" <name:NamedType> => RootOperationTypeDefinition {
        operation_type: OperationType::Query,
        named_type: name
    }
}

pub ObjectDefinition: ObjectDefinition = {
    ty <name:Name> <fields:FieldsDefinition?> => ObjectDefinition {
        name,
        fields: fields.unwrap_or_default ()
    }
};

FieldsDefinition: Vec<NodeId> = {
    "{" <fields:FieldDefinition+> "}" => fields
};

// TODO: add description & directives in a minute
FieldDefinition: NodeId = {
    <description:StringValue?> <name:Name> <arguments:ArgumentsDefinition?> ":" <ty:NamedType> => ast.field_definition(FieldDefinition {
        name,
        ty,
        arguments: arguments.unwrap_or_default(),
        description,
    })
};

ArgumentsDefinition: Vec<NodeId> = {
    "(" <arguments:InputValueDefinition+> ")" => arguments,
};

pub InputObjectDefinition: InputObjectDefinition = {
    input <name:Name> <fields:InputFieldsDefinition?> => InputObjectDefinition {
        name,
        fields: fields.unwrap_or_default()
    }
};

InputFieldsDefinition: Vec<NodeId> = {
    "{" <fields:InputValueDefinition+> "}" => fields
};

// TODO: Add default value, directives
InputValueDefinition: NodeId =
    <description:StringValue?> <name:Name> ":" <ty:Type> => ast.input_value_definition(InputValueDefinition { <> });

Name: NodeId = <s:Ident> => ast.ident(s);

NamedType: NodeId = <s:Ident> => ast.ident(s);

// TODO: This needs to support wrappers - do that sometime...
Type: NodeId = <s:Ident> => ast.ident(s);

StringValue: NodeId = {
    <s:StringLiteral> => {
        let id = ast.intern_string(s);
        ast.string_literal(StringLiteral::Normal(id))
    },
    <s:BlockStringLiteral> => {
        let id = ast.intern_string(s);
        ast.string_literal(StringLiteral::Block(id))
    },
}

// TODO: Make this NodeId probably...
Ident: &'input str = {
    <s:RawIdent> => s,
    schema => "schema",
    query => "query",
    ty => "type",
    input => "input",
}

extern {
    type Location = usize;
    type Error = lexer::LexicalError;

    enum lexer::Token<'input> {
        "$" => lexer::Token::Dollar,

        ":" => lexer::Token::Colon,

        "{" => lexer::Token::OpenBrace,
        "}" => lexer::Token::CloseBrace,

        "(" => lexer::Token::OpenParen,
        ")" => lexer::Token::CloseParen,

        RawIdent => lexer::Token::Identifier(<&'input str>),

        StringLiteral => lexer::Token::StringLiteral(<&'input str>),
        BlockStringLiteral => lexer::Token::BlockStringLiteral(<&'input str>),

        // Would be nice if these could just be aliases of `Identifier` but LARLPOP doesn't
        // seem to support this well: https://github.com/lalrpop/lalrpop/issues/671
        schema => lexer::Token::Schema,
        query => lexer::Token::Query,
        ty => lexer::Token::Type,
        input => lexer::Token::Input,
    }
}