use crate::lexer;

use crate::ast::{storage::*, ids::*, writer::AstWriter, *};

grammar<'input>(input: &'input str, ast: &mut AstWriter);

pub ExecutableDocument: () = {
    <defs:DefinitionAndDescription+> => {}
}

DefinitionAndDescription: () = {
    <description:StringValue?> <def:ExecutableDefinition> => {
        ast.store_description(def, description)
    }
}

// TODO: Can't re-use DefinitionId here...
ExecutableDefinition: DefinitionId = {
    <def:OperationDefinition> => ast.operation_definition(def),
    <def:FragmentDefinition> => ast.fragment_definition(def),
}

OperationDefinition: OperationDefinition = {
    query => {}
};

FragmentDefinition: FragmentDefinition = {
    "$" => {}
};

StringValue: StringId = {
    <s:StringLiteral> => {
        ast.intern_string(s)
    },
    <s:BlockStringLiteral> => {
        ast.intern_string(s)
    },
}

Ident: &'input str = {
    <s:RawIdent> => s,
    schema => "schema",
    query => "query",
    mutation => "mutation",
    subscription => "subscription",
    ty => "type",
    input => "input",
    true => "true",
    false => "false",
    null => "null",
    implements => "implements",
    interface => "interface",
    "enum" => "enum",
    union => "union",
    scalar => "scalar",
    extend => "extend",
    directive => "directive",
    repeatable => "repeatable",
    on => "on",
}


extern {
    type Location = usize;
    type Error = lexer::LexicalError;

    enum lexer::Token<'input> {
        "$" => lexer::Token::Dollar,

        ":" => lexer::Token::Colon,

        "{" => lexer::Token::OpenBrace,
        "}" => lexer::Token::CloseBrace,

        "(" => lexer::Token::OpenParen,
        ")" => lexer::Token::CloseParen,

        "[" => lexer::Token::OpenBracket,
        "]" => lexer::Token::CloseBracket,

        "!" => lexer::Token::Exclamation,
        "=" => lexer::Token::Equals,
        "@" => lexer::Token::At,
        "&" => lexer::Token::Ampersand,
        "|" => lexer::Token::Pipe,

        RawIdent => lexer::Token::Identifier(<&'input str>),

        StringLiteral => lexer::Token::StringLiteral(<&'input str>),
        BlockStringLiteral => lexer::Token::BlockStringLiteral(<&'input str>),
        FloatLiteral => lexer::Token::FloatLiteral(<&'input str>),
        IntegerLiteral => lexer::Token::IntegerLiteral(<&'input str>),

        // Would be nice if these could just be aliases of `Identifier` but LARLPOP doesn't
        // seem to support this well: https://github.com/lalrpop/lalrpop/issues/671
        schema => lexer::Token::Schema,
        query => lexer::Token::Query,
        mutation => lexer::Token::Mutation,
        subscription => lexer::Token::Subscription,
        ty => lexer::Token::Type,
        input => lexer::Token::Input,
        true => lexer::Token::True,
        false => lexer::Token::False,
        null => lexer::Token::Null,
        implements => lexer::Token::Implements,
        interface => lexer::Token::Interface,
        "enum" => lexer::Token::Enum,
        union => lexer::Token::Union,
        scalar => lexer::Token::Scalar,
        extend => lexer::Token::Extend,
        directive => lexer::Token::Directive,
        repeatable => lexer::Token::Repeatable,
        on => lexer::Token::On,
    }
}