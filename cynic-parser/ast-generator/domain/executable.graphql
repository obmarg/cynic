# Defines most of the executable AST.
# The ast-generator reads this file and uses it to generate a ton of boilerplate

union ExecutableDefinition
  @file(name: "definition")
  @variant(names: ["Operation", "Fragment"]) =
    OperationDefinition
  | FragmentDefinition

type OperationDefinition @file(name: "operation") {
  operation_type: OperationType!
  name: String
  variable_definitions: [VariableDefinition]
  directives: [Directive]
  selection_set: [Selection]
  span: Span!
}

type FragmentDefinition @file(name: "fragment") {
  name: String!
  type_condition: String!
  directives: [Directive]
  selection_set: [Selection]
  span: Span!
}

union Selection
  @file(name: "selections")
  @variant(names: ["Field", "InlineFragment", "FragmentSpread"]) =
    FieldSelection
  | InlineFragment
  | FragmentSpread

type FieldSelection @file(name: "selections") {
  alias: String
  name: String!
  arguments: [Argument]
  directives: [Directive]
  selection_set: [Selection]
  span: Span!
}

type InlineFragment @file(name: "selections") {
  type_condition: String
  directives: [Directive]
  selection_set: [Selection]
  span: Span!
}

type FragmentSpread @file(name: "selections") {
  fragment_name: Name
  directives: [Directive]
  span: Span!
}

type Name @file(name: "name") {
  text: String!
  span: Span!
}

type Directive @file(name: "directive") {
  name: Name
  arguments: [Argument]
  span: Span!
}

type Argument @file(name: "argument") {
  name: Name
  value: Value!
  span: Span!
}

type VariableDefinition @file(name: "variable") {
  name: Name!
  ty: Type!
  default_value: ConstValue
  directives: [Directive]
  span: Span!
}

# OperationType & Scan are marked as @inline which means they just gets
# stored inside records instead of being stored by an Id in the root store
scalar OperationType @inline
scalar Span @inline

# Type & Value are kind of special cases that aren't worth automating
# so we make them scalars and implement them by hand
scalar Type @file(name: "types")
scalar Value @file(name: "value")
scalar ConstValue @file(name: "value")

# String is built in, but easier to implement stuff if its just in the .graphql file
# It is also special cased a bit in the rust code
scalar String
